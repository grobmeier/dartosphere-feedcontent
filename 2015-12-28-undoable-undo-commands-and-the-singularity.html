---
title: 'Undoable Undo Commands and the Singularity'
layout: post
published: '2015-12-28T22:48:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/0hfXoYWVjAQ/undoable-undo-commands-and-singularity.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'
    - naming
    - typedef

---

<div class=top-chain-links></div><br /><a href="https://plus.google.com/+AndersHolmgren1">Anders Holmgren</a> suggested a nifty implementation for the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> in <a href="http://dartlang.org">Dart</a>. Part of his solution has me flummoxed.<br /><br />I do not think the problem is with Anders' solution. Having spent two days exploring it, I think it is solid. After last night, I do not believe the problem is with Dart either. I think the problem is mostly between my ears. That or I am experiencing the second of the <a href="http://martinfowler.com/bliki/TwoHardThings.html">two hardest things</a> in programming:<ol><li>cache invalidation</li><li>naming things</li><li>off-by-one errors</li></ol>The naming problem that I may be experiencing is that I have been working with objects of type <code>Command</code>. Anders solution used <i>functions</i> named <code>Command</code> while his classes were named <code>CommandClass</code>. So whenever his solution referenced <code>Command</code>, it meant the function, but I kept thinking the object.<br /><br />This brings me to a question. When working with functions and function-like objects in Dart, how should I name them? Normally, I do not care for <a href="https://en.wikipedia.org/wiki/Hungarian_notation">Hungarian notation</a>. But I cannot think of anything better than calling one <code>Command</code> while the other gets the Hungarian treatment (either <code>CommandFunction</code> or <code>CommandClass</code>). I am not sure either is a good approach. Having already explored the other option, tonight I will explore how things look with a <code>Command</code> class and a <code>CommandFunction</code> typedef.<br /><br />I should stress that I am not attempting to argue with Anders' solution. He adapted a working solution to my existing code, which I <i>hugely</i> appreciate. The working solution neatly sidesteps this naming issue. I may adopt that solution, but I first would like to see how this plays out. I also note that I strongly risk <a href="https://en.wikipedia.org/wiki/Confirmation_bias">confirmation bias</a> here—<code>CommandClass</code> confused me when I first looked at it and I named my class my original class <code>Command</code>. That said...<br /><br />I start with a <code>CommandFunction</code> typedef:<pre class=prettyprint>typedef void CommandFunction();</pre>My commands will all have <code>void</code> return type and take no arguments. Thus, any functions with that signature are "Command Functions". For example, the functions supplied to the "Hi!" and "Scare" buttons are both a <code>CommandFunction</code>:<pre class=prettyprint><code>  var btnSayHi = new Button("Hi!", (){ robot.say("Hi!"); });<br />  var btnScare = new Button("Scare Robot", (){ robot.say("Ahhhhh!"); });</code></pre>In Dart, any class that declares a <code>call()</code> method is also a function. So any class that implements the abstract <code>Command</code> class will be a <code>CommandFunction</code>:<pre class=prettyprint>abstract class Command {<br />  void call();<br />}</pre>The <code>MoveNorthCommand</code>, for instance, should be a <code>CommandFunction</code>:<pre class=prettyprint>class MoveNorthCommand implements Command {<br />  Robot robot;<br />  MoveNorthCommand(this.robot);<br />  void call() { robot.move(Direction.NORTH); }<br />  void undo() { robot.move(Direction.SOUTH); }<br />}</pre>And indeed, when I check an instance of this class, it does report that it is a <code>CommandFunction</code>:<pre class=prettyprint><code>  var moveNorth = new MoveNorthCommand(robot);<br />  print("Is moveNorth and CommandFunction? ${moveNorth is CommandFunction}.");</code></pre>This results in:<pre class=prettyprint>Is moveNorth and CommandFunction? true.</pre>There is not much that I can do with the <code>CommandFunction</code> in my current implementation. The <code>Command</code> class cannot implement a typedef.  Classes in Dart, even Function classes, can only implement other classes, not typedefs. So this means that <code>Command</code> is implicitly a <code>CommandFunction</code>, but there is no way to make that relationship explicit:<pre class=prettyprint>typedef void CommandFunction();<br /><br />abstract class Command implements Function {<br />  void call();<br />}</pre>What I can do, as I have done with the <code>CommandClass</code> approach, is replace references to <code>Function</code> with the <code>CommandFunction</code> typedef. Thus, a command in the <code>Button</code> class must be a <code>CommandFunction</code>:<pre class=prettyprint>class Button {<br />  String name;<br />  CommandFunction command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />    History.add(command);<br />  }<br />}<br /></pre>I can also constrain <code>History</code> so that it can only add <code>CommandFunction</code> objects:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(CommandFunction c) {<br />   // ...<br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>While I am writing those, I have to admit that they do feel a little awkward. I want to talk about "command objects" or "command interface objects" instead of "command function objects." I can rationalize a little bit that these used to be "function objects" and the addition of "command" make the type clearer. But I honestly do not know if that stands up to the 6-months-later smell test. Regardless, I push on. <br /><br />Currently, were I declare an <code>UndoableCommand</code>, it would implement the <code>Command</code> class (making it a <code>CommandFunction</code>) and add an <code>undo()</code> method:<pre class=prettyprint>abstract class Command implements Function {<br />  void call();<br />}<br /><br />abstract class UndoableCommand implements Command {<br />  void undo();<br />}</pre>I can replace <code>Command</code> as the implemented class in most of my commands with <code>UndoableCommand</code> without missing a beat. There are some other benefits as well, but where things get really interesting is with last night's typedef-as-a-generic-upper-bound solution.<br /><br />This comes directly from Anders' solution and is pretty slick. Instead of declaring an <code>undo()</code> method in <code>UndoableCommand</code>, I make undo another command object:<pre class=prettyprint>abstract class UndoableCommand&lt;C extends CommandFunction> implements Command {<br />  C get undoCommand;<br />}</pre>As I found last night, I may not be able to extend a typedef in a class declaration, but I can do so in a generic. What this does is declare that the upper bound of the <code>undoCommand</code> has to be a <code>CommandFunction</code>. That is, I have explicitly constrained <code>undoCommand</code> to be a <code>CommandFunction</code>.  <br /><br />This allows me to rewrite my commands with commands that are themselves undoable commands:<pre class=prettyprint>class MoveNorthCommand implements UndoableCommand {<br />  Robot robot;<br />  MoveNorthCommand(this.robot);<br />  void call() { robot.move(Direction.NORTH); }<br />  UndoableCommand get undoCommand => new MoveSouthCommand(robot);<br />}</pre>Just like replacing callbacks with objects in the original implementation the command pattern, this gives me more control and options with undo commands. Plus I can explicitly constrain these beasties to be <code>CommandFunction</code> thanks to the extended typedef. That remains small comfort since I cannot explicitly constrain the original <code>Command</code> class to be a <code>CommandFunction</code>. Still it's something.<br /><br />As for the what gets the <code>Command</code> name question, I think I am going to give into confirmation bias here. I admit that <code>CommandFunction</code> got awkward in the <code>History</code> class, but I think that awkwardness was better than naming the typedef as <code>Command</code> and then mistaking it 6 months later for a command pattern object instead of a typedef. In the end, it is likely advisable to come up with different names altogether. Anders calls the typedef <code>Callable</code> in the working code, which is just another name for <code>Function</code> which might make it a bit too generic. Still, the resulting code reads nicely. <br /><br />In the end, I think I finally have a handle on this. Big thanks again to Anders for the suggestion—undoable undo actions was a very worthwhile exploration. The typedef thing I could have done without (brain hurts!), but I should know it better... and now I do!<br /><br /><i>Play with the code in DartPad: <a href="https://dartpad.dartlang.org/61b96c6edfb1074c77f4">https://dartpad.dartlang.org/61b96c6edfb1074c77f4</a>.</i><br /><br /><br /><span style="color: #ccc">Day #47</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/on-second-thought-extending-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/0hfXoYWVjAQ" height="1" width="1" alt=""/>
