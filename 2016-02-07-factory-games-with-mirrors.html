---
title: 'Factory Games with Mirrors'
layout: post
published: '2016-02-07T21:55:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/TY6VoCmDrn4/factory-games-with-mirrors.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Up tonight I finally carry through on my threat to apply mirrors to the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory method pattern</a> in <a href="http://dartlang.org">Dart</a>. I am unsure if my beloved mirrors can have their usual improving effect (in my eyes at least), but I am always happy to have an excuse to play with reflection and mirrors. <br /><br />Tonight's excuse comes in the form of the language specific implementations mentioned in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>. They mentioned that factory methods in Smalltalk often return the class to be created instead of an object. Aside from having to import the <code>dart:mirrors</code> library, it is not much more difficult to do the same thing in Dart.<br /><br />The prime mover in the factory method pattern is the creator class. In the "game factory" example with which I have been toying, the <code>GameFactory</code> class creates a series of games between two players, then allows them chose any number of board games to play. The returns-a-class version might look something like:<pre class=prettyprint>// Creator<br />class GameFactory {<br />  String playerOne, playerTwo;<br />  GameFactory(this.playerOne, this.playerTwo);<br />  // ...<br /><br />  // The factory method<br />  Type boardGameClass([String game]) {<br />    if (game == 'Checkers') return CheckersGame;<br />    if (game == 'Thermo Nuclear War') return ThermoNuclearWar;<br />    return ChessGame;<br />  }<br />}</pre>That will force the client code to reflect on the classes, which is an obnoxious thing to ask of client code. So instead, I import <code>dart:mirrors</code> and return a class mirror from the <code>boardGameClass()</code> method:<pre class=prettyprint>import 'dart:mirrors' show reflectClass, ClassMirror;<br /><br />// Creator<br />class GameFactory {<br />  // ...<br />  ClassMirror boardGameClass([String game]) {<br />    if (game == 'Checkers') return reflectClass(CheckersGame);<br />    if (game == 'Thermo Nuclear War') return reflectClass(ThermoNuclearWar);<br />    return reflectClass(ChessGame);<br />  }<br />}</pre>Let's take a look at the resulting client code next. When it worked directly with objects, the client code looked like:<pre class=prettyprint>main() {<br />  var series = new GameFactory('Professor Falken', 'Joshua');<br />  series.start();<br /><br />  var game;<br />  game = series.createBoardGame('Checkers');<br />  game.play();<br /><br />  game = series.createBoardGame('Thermo Nuclear War');<br />  game.play();<br /><br />  // Defaults to a nice game of chess<br />  game.createBoardGame();<br />  game.play();<br />}<br /></pre>That is pretty simple: start by creating a game factory instance, then create a game / play the game, create a game / play a game, etc.<br /><br />With mirrors, the code now becomes:<pre class=prettyprint>main() {<br />  var series = new GameFactory('Professor Falken', 'Joshua');<br />  series.start();<br /><br />  var game;<br />  game = series.<br />    boardGameClass('Checkers').<br />    newInstance(new Symbol(''), []).<br />    reflectee;<br />  game.play();<br /><br />  game = series.<br />    boardGameClass('Thermo Nuclear War').<br />    newInstance(new Symbol(''), []).<br />    reflectee;<br />  game.play();<br /><br />  // Defaults to a nice game of chess<br />  game = series.<br />    boardGameClass().<br />    newInstance(new Symbol(''), []).<br />    reflectee;<br />  game.play();<br />}</pre>Look, I love mirrors more than just about anyone, but even I have to admit that is horrible. There is far too much noise obscuring the relatively simple intent of the code. I am not a fan of being forced to supply a constructor as a <code>Symbol</code>â€”it seems like the default constructor could be inferred (I'm sure there is a good reason it is not though). Similarly, I do not like being forced to supply an empty list of arguments to the <code>newInstance()</code> constructor method. But the truth is, even if both of those complaints went away, the <code>newInstance()</code> and <code>reflectee</code> calls would still make a mirror approach significantly less desirable than the plain-old object approach.<br /><br />So mirrors are always undesirable in the factory method pattern, right? Well, not so fast. If there is a situation in which the client might want to create products with varying constructor arguments, then this mirror approach could come in handy.  For instance, if we want to teach Joshua about thermonuclear war, we can create a alternate constructor for assigning different starting values for the two players:<pre class=prettyprint>class ThermoNuclearWar extends BoardGame {<br />  List playerOnePieces = [ '1,000 warheads' ];<br />  List playerTwoPieces = [ '1,000 warheads' ];<br />  ThermoNuclearWar(): super();<br />  ThermoNuclearWar.withWarheads(this.playerOnePieces, this.playerTwoPieces);<br />  String get winner => "None";<br />}</pre>The client code can then run through as many scenarios as it takes to teach that thermonuclear war is a very strange game indeed:<pre class=prettyprint><code>  game = series.<br />    boardGameClass('Thermo Nuclear War').<br />    newInstance(new Symbol(''), []).<br />    reflectee;<br />  game.play();<br /><br />  game = series.<br />    boardGameClass('Thermo Nuclear War').<br />    newInstance(<br />      new Symbol('withWarheads'),<br />      [['1 warhead'], ['1 warhead']]<br />    ).<br />    reflectee;<br />  game.play();<br /><br />  game = series.<br />    boardGameClass('Thermo Nuclear War').<br />    newInstance(<br />      new Symbol('withWarheads'),<br />      [['1 warhead'], ['1,000 warheads']]<br />    ).<br />    reflectee;<br />  game.play();</code></pre>This would result in output like:<pre class=prettyprint>$ ./bin/board_game.dart<br />*** Professor Falken vs. Joshua ***<br /><br />  ThermoNuclearWar<br />    Player One starts with: 1,000 warheads<br />    Player Two starts with: 1,000 warheads<br />    --<br />    Winner: None<br /><br />  ThermoNuclearWar<br />    Player One starts with: 1 warhead<br />    Player Two starts with: 1 warhead<br />    --<br />    Winner: None<br /><br />  ThermoNuclearWar<br />    Player One starts with: 1 warhead<br />    Player Two starts with: 1,000 warheads<br />    --<br />    Winner: None<br /></pre>Afterwards, the game series can then switch back to a nice game of chess:<pre class=prettyprint><code>  // Defaults to a nice game of chess<br />  game = series.<br />    boardGameClass().<br />    newInstance(new Symbol(''), []).<br />    reflectee;<br />  game.play();</code></pre>So there is a reason for using mirrors in the factory method pattern after all. Yay! That said, they do not make as much sense as returning classes in Smalltalk. I will have to continue my search for Dart-specific features that can be brought to bear on the factory method pattern tomorrow.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/d2a79f59113c888d0788">https://dartpad.dartlang.org/d2a79f59113c888d0788</a>.</i><br /><br /><br /><span style="color: #ccc">Day #88</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/ive-got-factory-in-my-factory-in-my.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/silly-factories-in-factory-method.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/TY6VoCmDrn4" height="1" width="1" alt=""/>
