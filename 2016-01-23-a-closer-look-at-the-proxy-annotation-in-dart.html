---
title: 'A Closer Look at the Proxy Annotation in Dart'
layout: post
published: '2016-01-23T22:20:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/hlaUe332EJA/a-closer-look-at-proxy-annotation-in.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />I don't think I used it once. I enjoyed exploring the <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> in <a href="http://dartlang.org">Dart</a>. Trying to use <a href="https://api.dartlang.org/1.13.2/dart-isolate/dart-isolate-library.html">isolates</a> for simple remote proxies was probably ill-advised, but aside from that, my exploration went swimmingly. Except one thing that I was sure would happen never did.<br /><br />Not once did I use the <a href="https://api.dartlang.org/1.13.2/dart-core/proxy.html">@proxy</a> annotation for any of my proxy implementations. I am pretty sure that I understand what the <code>@proxy</code> annotation does, but "pretty sure" pretty much always translates into some mistake on my part. And since I never once had to use it when implementing a variety of proxy classes, there is a good chance that I have a knowledge gap.<br /><br />I had always assumed that <code>@proxy</code> annotated a class indicating that the class supported methods even if not specifically declared. Since Dart is optionally typed, this would be a static type analysis warning, not a compile or runtime issue. But I specifically run all my code through <code>dartanalyzer</code> before using it, so how did I avoid it?<br /><br />There would have been no need for the annotation with my websocket remote car implementation. All of the methods that were declared in the interface:<pre class=prettyprint>abstract class AsyncAuto {<br />  String get state;<br />  Future drive();<br />  Future stop();<br />}</pre>Were explicitly declared in the remote proxy class:<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  // ...<br />  String get state => _state;<br />  Future drive() => _send('drive');<br />  Future stop()  => _send('stop');<br />  // ...<br />}</pre>But how did I manage to avoid <code>@proxy</code> with my <code>noSuchMethod()</code> / protection proxy class? In that example, I was still working with cars, but the subject of the pattern, the <code>Automobile</code> interface, only declared a single method:<pre class=prettyprint>abstract class Automobile {<br />  void drive();<br />}</pre>The proxy class in this example does not explicitly declare the <code>drive</code> method even though it implements the <code>Automobile</code> interface:<pre class=prettyprint>class ProxyCar implements Automobile {<br />  Driver _driver;<br />  Car _car;<br /><br />  ProxyCar(this._driver);<br /><br />  Car get car => _car ??= new Car();<br /><br />  dynamic noSuchMethod(i) {<br />    if (_driver.age <= 16)<br />      throw new IllegalDriverException(_driver, "too young");<br /><br />    return reflect(car).delegate(i);<br />  }<br />}</pre>Without explicitly declaring <code>drive()</code>, I need <code>@proxy</code>, right? Well.. no. When I run <code>dartanalyzer</code> against this library and some client code, I get no issues in either:<pre class=prettyprint>$ dartanalyzer bin/drive.dart lib/car.dart<br />Analyzing [bin/drive.dart, lib/car.dart]...<br />No issues found<br />No issues found</pre>I also get no errors when using this <a href="https://dartpad.dartlang.org/3577ddd84876ebf310c4">DartPad</a>, so this seems to be expected and / or desired behavior.  So what is the point of <code>@proxy</code> then? As far as I can tell, it comes in handy when I lack a subject in the proxy pattern. That is, when you do not have an interface to implement, then warning will be issued. For example, if I remove the <code>implements</code> clause from the <code>ProxyCar</code> implementation, but leave the same <code>noSuchMethod()</code> implementation in place:<pre class=prettyprint>class ProxyCar {<br />  // ...<br />  dynamic noSuchMethod(i) {<br />    if (_driver.age <= 16)<br />      throw new IllegalDriverException(_driver, "too young");<br /><br />    return reflect(car).delegate(i);<br />  }<br />}</pre>Then my client code:<pre class=prettyprint><code>  // ...<br />  car = new ProxyCar(new Driver(25));<br />  car.drive();<br />  // ...</code></pre>Generates warnings:<pre class=prettyprint>$ dartanalyzer bin/drive.dart lib/car.dart<br />Analyzing [bin/drive.dart, lib/car.dart]...<br />[hint] The method 'drive' is not defined for the class 'ProxyCar' (/home/chris/repos/design-patterns-in-dart/proxy/bin/drive.dart, line 11, col 7)<br />1 hint found.</pre>In this situation, I can eliminate the warning with a <code>@proxy</code> annotation before the class:<pre class=prettyprint>@proxy<br />class ProxyCar {<br />  // ...<br />}</pre>But, as long as I have an interface to implement and a <code>noSuchMethod()</code> method declared, <code>@proxy</code> is not necessary. In <a href="http://www.pearsonhighered.com/educator/product/Dart-Programming-Language-The/9780321927705.page">The Dart Programming Language</a>, Gilad Bracha has a nice explanation of why one might want a proxy without a classic subject. I may take a closer look at that tomorrow. For now, I have a better understanding of <code>@proxy</code> and why it usually is not necessary.   <p><i>Play with the non-annotated code on DartPad: <a href="https://dartpad.dartlang.org/3577ddd84876ebf310c4">https://dartpad.dartlang.org/3577ddd84876ebf310c4</a>.</i></p>  <span style="color: #ccc">Day #73</span>    <p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/program-to-distant-interfaces.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/hlaUe332EJA" height="1" width="1" alt=""/>
