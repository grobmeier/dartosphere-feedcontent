---
title: 'Silly Factories in the Factory Method Pattern'
layout: post
published: '2016-02-08T22:13:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/hWs9lzoSjBQ/silly-factories-in-factory-method.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Tonight, I look into using <a href="http://dartlang.org">Dart</a> factory constructors in the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory method pattern</a>. Since they both have the word "factory" in them they can probably be used together, right? Well, probably not, but I can no longer resist pairing the two.<br /><br />Normal generative constructors in Dart behave like constructors in just about any object-oriented language. They create a new instance of the current class, optionally setting some instance variables. Factory constructors, on the other hand, are responsible for building and initializing the object being created. This means that factory constructors can return anythingâ€”not limited to the current class.<br /><br />Take, for instance, a <code>Person</code> class:<pre class=prettyprint>class Person {<br />  int age;<br />  Person(this.age);<br />}</pre>When a new <code>Person</code> is instantiated with <code>new Person(21)</code>, the generative constructor creates an instance of <code>Person</code> and assigns the <code>age</code> instance variable to <code>21</code>. Easy peasy.<br /><br />Now I introduce two subclasses (both still using plain-old generative constructors):<pre class=prettyprint>class Child extends Person {<br />  Child([age=12]) : super(age);<br />}<br /><br />class Adult extends Person {<br />  Adult([age=18]) : super(age);<br />}</pre>There is nothing special here. Both classes default to an age appropriate for the type of person being created. What these allow me to do is declare a (named) factory constructor back in <code>Person</code>:<pre class=prettyprint>class Person {<br />  factory Person.random() => <br />    new Random().nextBool() ? new Child() : new Adult();<br />}</pre>This <code>Person.random()</code> constructor creates and returns full-blown object. It cannot rely on the language to generate the object, instead it has to do all of the work itself. With that, I can randomly generate children and adults from the <code>Person</code> superclass:<pre class=prettyprint><code>  new Person.random();<br />  // => Instance of 'Adult'<br />  new Person.random();<br />  // => Instance of 'Adult'<br />  new Person.random();<br />  // => Instance of 'Child'</code></pre>What is really weird about these factory constructors is that they do not have to return an instance of the current class or a subclass. Instead, I can declare a <code>Person</code> constructor that returns a string:<pre class=prettyprint>class Person {<br />  // ...<br />  factory Person.string() { return "A person"; }<br />}</pre>And that works perfectly fine:<pre class=prettyprint><code>  new Person.random();<br />  // => Instance of 'Adult'<br />  new Person.random();<br />  // => Instance of 'Adult'<br />  new Person.random();<br />  // => Instance of 'Child'<br />  new Person.string();<br />  // => 'A person'</code></pre>To be completely honest, that is not "perfectly fine." The Dart type analyzer does complain:<pre class=prettyprint>[warning] The return type 'String' is not a 'Person', as defined by the method 'string'</pre>But despite the warning, the code compiles and runs (see <a href="https://dartpad.dartlang.org/a9d6e9a9b654300bf696">this DartPad</a>).<br /><br />Anyhow, back to the task at hand. How can I use these factory constructors in the factory method pattern? Well, I probably cannot since one is a constructor and the other a method, but let's do it anyway. I currently have a <code>GameFactory</code> class that creates a bunch of different board game products:<pre class=prettyprint>class GameFactory {<br />  // ...<br />  // The factory method<br />  createBoardGame([String game]) {<br />    if (game == 'Checkers') return new CheckersGame();<br />    if (game == 'Thermo Nuclear War') return new ThermoNuclearWar();<br />    return new ChessGame();<br />  }<br />}</pre>Instead of a factory method, I can use a factory constructor:<pre class=prettyprint>class GameFactory {<br />  // ...<br />  factory GameFactory.createBoardGame([String game]) {<br />    if (game == 'Checkers') return new CheckersGame();<br />    if (game == 'Thermo Nuclear War') return new ThermoNuclearWar();<br />    return new ChessGame();<br />  }<br />}<br /></pre>Since <code>BoardGame</code> is not a subclass of <code>GameFactory</code>, the Dart type analyzer complains something fierce about this. But it compiles and runs anyway:<pre class=prettyprint><code>  new GameFactory.createBoardGame('Checkers').play();<br />  new GameFactory.createBoardGame('Thermo Nuclear War').play();<br />  new GameFactory.createBoardGame().play();</code></pre>So what does this buy me? Like war, absolutely nothing.<br /><br />In fact, I lose the ability to associate the factory constructor board games with the rest of the series. Each of those three board games are completely independent of the game factory series, which can no longer keep a reference to each for a final score:<pre class=prettyprint><code>  var series = new GameFactory('Professor Falken', 'Joshua');<br />  series.start();<br /><br />  new GameFactory.createBoardGame('Checkers').play();<br />  new GameFactory.createBoardGame('Thermo Nuclear War').play();<br />  new GameFactory.createBoardGame().play();</code></pre>So in the end, factory constructors and the factory method pattern are amusing together, but I can see no practical benefit. It was still totally worth messing around with them though!<br /><br /><i>Play with the amusing code on DartPad: <a href="https://dartpad.dartlang.org/4a59d56472d11cde9354">https://dartpad.dartlang.org/4a59d56472d11cde9354</a>.</i><br /><br /><br /><span style="color: #ccc">Day #89</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/factory-games-with-mirrors.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/hWs9lzoSjBQ" height="1" width="1" alt=""/>
