---
title: 'Named Constructors in Dart Factory Method'
layout: post
published: '2014-06-23T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/oAsIRZB5gvI/named-constructors-in-dart-factory.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />As pointed out to me in <a href="http://japhr.blogspot.com/2014/06/dart-factory-method-pattern.html#comments">comments</a>, <a href="http://dartlang.org">Dart</a> mirrors are unlikely to be the most efficient means for implementing the Factory Method pattern in Dart. But I don't care, I love this dynamic language stuff too darn much.<br /><br />OK, OK, that's not 100% true. I do care about speed and efficiency in my code. I also very much care about speed a a factor for the solutions that will go into <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. That said, I am not trying to find the one and only solution when I first investigate a pattern. I am interested in finding as many reasonable implementations as possible so that I might have several to fit different use cases in the book. <br /><br />Sometimes speed might be the most important need, sometimes it might be clarity, and other times a programmer may need a solution that minimizes the number of classes and subclasses. I really also ought to include potential drawbacks to each pattern or, as the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> puts it, consequences of each. One of the consequences of the Factory Method pattern mentioned by the Gang of Four is the difficulty that arises when refactoring constructors. <br /><br />Since the Factory Method pattern concerns itself with creating new objects, the difficulty in refactoring arises when the constructor needs to change. Consider the concrete <i>creator</i> in the <a href="https://github.com/eee-c/hipster-mvc">Hipster MVC</a> framework:<pre class=prettyprint>class Comics extends HipsterCollection {<br /><b>  modelMaker(attrs) => new ComicBook(attrs);</b><br />  get url => '/comics';<br />}</pre>In this case, the <code>modelMaker()</code> method plays the role of Factory Method. Where the <code>HipsterCollection</code> base class leaves this method abstract, the concrete <i>creator</i> must define the implementation. But what happens when the constructor has to change because some unrelated client code needs to supply different arguments? What happens when Hipster MVC becomes super popular only to find that a single argument to <code>modelMaker()</code> is insufficient in 20% of the use cases? Is a huge rewrite inevitable? Is a breaking, major version change the only option?<br /><br />Thanks to Dart's optional method parameters, I could probably accommodate some change, but it would be nice if these kinds of changes could occur independently of each other. This seems like a job for Dart's named constructors. <br /><br />Currently, my Factory Pattern's abstract product class, <code>HispterModel</code>, declares a constructor that optionally accepts attributes:<pre class=prettyprint>class HipsterModel {<br />  // ...<br /><b>  HipsterModel([this.attributes]) {<br />    if (attributes == null) attributes = {};</b><br />    _onSave = new StreamController.broadcast();<br />    _onDelete = new StreamController.broadcast();<br />  }<br />  // ...<br />}</pre>It might make sense for this default constructor to treat <code>attributes</code> as optional, but when creating concrete products as part of a collection, this might prove problematic. With named constructors, I can leave the default case as optionally accepting mode attributes, but, when constructed from a collection, it can be required:<pre class=prettyprint>class HipsterModel {<br />  // ...<br />  HipsterModel([this.attributes]) {<br />    if (attributes == null) attributes = {};<br />    _onSave = new StreamController.broadcast();<br />    _onDelete = new StreamController.broadcast();<br />  }<br /><b>  HipsterModel.collectionMaker(Map attrs): this(attrs);</b><br />  // ...<br />}<br /></pre>My concrete creator would use this named constructor in the Factory Method:<pre class=prettyprint>class Comics extends HipsterCollection {<br /><b>  modelMaker(attrs) => new ComicBook.collectionMaker(attrs);</b><br />  get url => '/comics';<br />}</pre>This has the advantage of allowing the two constructors to evolve independently of each other, which is a decided win. This would also play nicely with last night's mirror-based Factory Method implementation.<br /><br />But all is not rosy with this approach—mostly due to Dart's treatment of constructors in subclasses. Specifically, they are not inherited. Because of this, I already had to declare a constructor for the optional arguments version. Now I have to do so for the named constructor as well:<pre class=prettyprint>class ComicBook extends HipsterModel {<br />  ComicBook([attributes]) : super(attributes);<br /><b>  ComicBook.collectionMaker(attributes) : super.collectionMaker(attributes);</b><br />}</pre>There is no way around this restriction in Dart. If concrete product classes like <code>ComicBook</code> are needed (because they define some additional, domain-specific properties or methods), then I will need to declare both constructors.<br /><br />There might be cases in which this overhead is acceptable—maybe even desirable. Even so, it is probably worth some more investigation in this area to see if more general purpose solutions exist. Toward that end, I will pick back up with factory constructors tomorrow.<br /><br /><br /><span style="color: #ccc">Day #102</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/06/dart-mirrors-for-better-factor-method.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/oAsIRZB5gvI" height="1" width="1"/>
