---
title: 'Memento Not As State'
layout: post
published: '2015-11-28T22:18:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/nss2McH_E8E/memento-not-as-state.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - memento

---

<div class=top-chain-links></div><br />I really need to cut out the extreme late night coding. I left off last night with a fully formed planned to increase the "Dartiness" in my <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a> example, but in the light of day I haven't the velvet foggiest notion what that plan might have been. No pity here though, there is still something to say about the existing code.<br /><br />I am curious about the relationship between the internal state of the originator and the memento object. In particular, should the memento object <i>be</i> the state in the originator class?  After last night, that is exactly what the <code>VelvetFogMachine</code> originator class does in its <code>play()</code> method:<pre class=prettyprint>// The "Originator"<br />class VelvetFogMachine {<br />  // The Memento<br />  Playing _nowPlaying;<br /><br />  // Set the state<br />  void play(String title, String album, [double time = 0.0]) {<br />    print("Playing $title // $album @ ${time.toStringAsFixed(2)}");<br />    _nowPlaying = new Playing(title, album, time);<br />  }<br />  // ...<br />}</pre>The second time around with the code, I think perhaps the memento-as-state is inappropriate. Oh, it worksâ€”especially in this short example. In real life code however, it is more likely that the <code>VelvetFogMachine</code> would want to track the current song and current time directly. Something along the lines of the following achieves a nearness to a more organic <code>VelvetFogMachine</code>:<pre class=prettyprint>class VelvetFogMachine {<br />  Song currentSong;<br />  double currentTime;<br /><br />  void play(String title, String album, [double time = 0.0]) {<br />    currentSong = new Song(title, album);<br />    currentTime = time;<br />    print("Playing $currentSong @ ${time.toStringAsFixed(2)}");<br />  }<br />  // ...<br />}</pre>My romance of a better example would push the song title and album into a new <code>Song</code> class:<pre class=prettyprint>class Song {<br />  String title, album;<br />  Song(this.title, this.album);<br />  String toString() => "$title // $album";<br />}</pre>Ah, Dart code, do I love you because you're beautiful? You certainly know my heart, but I still do not believe that is the "Dartiness" I was planning last night. Hopefully I can figure it out because it's really under my skin.<br /><br />Back to my example, the <code>currentSong</code> and <code>currentTime</code> feel like properties that could exist before realizing that a memento pattern was needed. In other words, I think this is a stronger memento example. Now what to do with the memento class? Previously, it stored separate song title, album and time properties:<pre class=prettyprint>class Playing {<br />  String title, album;<br />  double time;<br />  Playing(this.title, this.album, this.time);<br />}</pre>I am tempted to stick with with this structure in the memento class. After all, it mirrors the signature of the <code>play()</code> method in the <code>VelvetFogMachine</code>'s <code>play()</code> method that creates the internal state being memento-ized. In the end, I think it best for the memento class to mirror the internal structure of the originator class, so <code>title</code> and <code>album</code> are replaced with <code>song</code>:<pre class=prettyprint>class Playing {<br />  Song song;<br />  double time;<br />  Playing(this.song, this.time);<br />}</pre>Now that I have settled on this for the <code>Playing</code> memento, the method that creates the memento in <code>VelvetFogMachine</code> is trivial. The <code>nowPlaying</code> getter method simply instantiates the memento with the current song and time:<pre class=prettyprint>class VelvetFogMachine {<br />  // ...<br />  Playing get nowPlaying => new Playing(currentSong, currentTime);<br />  // ...<br />}</pre>Everyday's a holiday with Dart and hash-rocket return methods. That's good, clean fun.<br /><br />But what of the method that restores state from a previously recorded memento? It now has to translate the <code>Song</code>-based memento into the three argument <code>play()</code> method:<pre class=prettyprint>class VelvetFogMachine {<br />  // ...<br />  void backTo(Playing p) {<br />    print("  *** Whoa! This was a good one, let's hear it again :) ***");<br />    play(p.song.title, p.song.album, p.time);<br />  }<br />}</pre>Some indirection aside, that is not too horrible. Certainly it is better that the <code>VelvetFogMachine</code> be responsible for translating a memento of previous state into a <code>play()</code> instead of the caretaker context. The whole point of the memento after all, is to prevent exposing internal implementation details when saving state.<br /><br />If the indirection bothers me, I can replace the current <code>play()</code> with a call to a private, <code>Song</code>-based method:<pre class=prettyprint><code>  void play(String title, String album, [double time = 0.0]) {<br />    _play(new Song(title, album), time);<br />  }<br /><br />  void _play(Song s, double t) {<br />    currentSong = s;<br />    currentTime = t;<br />    print("Playing $currentSong @ ${currentTime.toStringAsFixed(2)}");<br />  }</code></pre>With that, the restore-from-memento method can invoke the same <code>_play()</code> method:<pre class=prettyprint><code>  void backTo(Playing p) {<br />    print("  *** Whoa! This was a good one, let's hear it again :) ***");<br />    _play(p.song, p.time);<br />  }</code></pre>I think I prefer that approach. That said, I might stick with the previous, non-private-based <code>play()</code> method in the book. The difference between the three argument <code>play()</code> method and the two-property memento better illuminates the need to hide implementation details of the originator from the outside world.<br /><br />That's about all for this bit of exploration. I am clearer on the need for the memento to encapsulate, but not be, the internal state of the originator. I had been glossing over that in my mind, but am happy for having cracked that chestnut.<br /><br />And I do think I remember that "Dartiness" factor I had hoped to explore. Hopefully we are not strangers in the late night and I will still remember it tomorrow. Stay tuned Mel fans!<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/35e0056a1f290c74d996">https://dartpad.dartlang.org/35e0056a1f290c74d996</a></i><br /><br /><span style="color: #ccc">Day #17</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/11/a-better-memento-example-now-with-more.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/nss2McH_E8E" height="1" width="1" alt=""/>
