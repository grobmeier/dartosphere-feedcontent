---
title: 'Visitor with a Little Composite in Dart'
layout: post
published: '2014-07-05T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/h5WfV3isabM/visitor-with-little-composite-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - 'composite pattern'
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />Translating the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four</a> example code for the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> into <a href="http://dartlang.org">Dart</a> went off without a hitch. Even without the complex data structure that really demonstrate the power the Visitor, the example is already illuminating.<br /><br />That said, to make it useful in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>, I should explore more complex data structures. Thankfully, I do not have to work too hard for this. Or at all. The GoF example inlcuded a  <a href="http://en.wikipedia.org/wiki/Composite_pattern">Composite Pattern</a> from the outset for just this reason. <br /><br />My purpose in making the data structure more complex is more than simply putting the pattern through its paces. I am also eager to experience where the pain lies in adding new types and structure. So I start with the <code>main()</code> entry point of my application which has a list of business inventory to which it supplies a Visitor that accumulates price:<pre class=prettyprint><code>  // ...<br />  var work_stuff = [<br />    new Mobile(),<br />    new Tablet(),<br />    new Laptop()<br />  ];<br /><br />  var cost = new PricingVisitor();<br />  work_stuff.forEach((e){ e.accept(cost); });<br />  print('Cost of work stuff: ${cost.totalPrice}.');<br />  // ...</code></pre>For the composite in this example, I will use “apps” on mobiles and tablets. Everyone knows that apps are not necessary on laptops, everything that is necessary on them comes from <code>apt-get</code> after all. So my work stuff might wind up looking like:<pre class=prettyprint><code>  // ...<br />  var work_stuff = [<br />    new Mobile()<br />      ..apps = [<br />          new App('2048')..netPrice = 10.0,<br />          new App('Pixel Dungeon')..netPrice = 7.0,<br />          new App('Monument Valley')..netPrice = 4.0<br />        ],<br />    new Tablet()<br />      ..apps = [<br />          new App('Angry Birds Tablet Platinum Edition')..netPrice = 1000.0<br />        ],<br />    new Laptop()<br />  ];<br />  // ...</code></pre>That is three relative cheap—but necessary—work apps on my mobile and one very expensive app on the tablet.<br /><br />The usage of <code>PricingVisitor</code> remains unchanged:<pre class=prettyprint><code>  var cost = new PricingVisitor();<br />  work_stuff.forEach((e){ e.accept(cost); });<br />  print('Cost of work stuff: ${cost.totalPrice}.');</code></pre>That is a nice advantage of the Visitor pattern. <br /><br />Also nice is that the Visitor class itself does not need to change much. I am still working with the same equipment from last night. The only new thing here is an “app.” In the Visitor class, that means that I will now need a <code>visitApp()</code> method:<pre class=prettyprint>abstract class InventoryVisitor {<br />  void visitMobile(Mobile i);<br />  void visitTablet(Tablet i);<br />  void visitLaptop(Laptop i);<br /><b>  void visitApp(App i);</b><br />}</pre>The concrete <code>PricingVisitor</code>, which accumulates the total cost of all inventory, can then do what it does best—applying a special rule for individual types. In this case, I only accumulate half the value of apps. In this case, I accumulate only half the value of apps:<pre class=prettyprint>class PricingVisitor extends InventoryVisitor {<br />  double _totalPrice = 0.00;<br /><br />  double get totalPrice => _totalPrice;<br /><br />  void visitMobile(i) { _totalPrice += i.netPrice; }<br />  void visitTablet(i) { _totalPrice += i.discountPrice(); }<br />  void visitLaptop(i) { _totalPrice += i.discountPrice(); }<br /><br /><b>  void visitApp(i) { _totalPrice += 0.5 * i.discountPrice(); }</b><br />}</pre>So far, so good. There really has not been any pain just yet. What is a pain is adding the new nodes—the composite and the App. Well, not so much a pain, but tedious:<pre class=prettyprint>abstract class Inventory {<br />  String name;<br />  Inventory(this.name);<br /><br />  double netPrice;<br />  double discountPrice() => netPrice;<br /><br />  void accept(vistor);<br />}<br /><br /><b>class App extends Inventory {<br />  App(name): super(name);<br />  void accept(visitor) { visitor.visitApp(this); }<br />}<br /><br />abstract class EquipmentWithApps extends Equipment {<br />  EquipmentWithApps(name): super(name);<br />  List&lt;App> apps = [];<br />}</b><br /></pre>Even with that, I still have to add concrete composites like the mobile phone class:<pre class=prettyprint>class Mobile extends EquipmentWithApps {<br />  Mobile(): super('Mobile Phone');<br />  double netPrice = 350.00;<br />  void accept(visitor) {<br />    apps.forEach((app) { app.accept(visitor); });<br />    visitor.visitMobile(this);<br />  }<br />}</pre>This is about as complex as things get tonight. The <code>Mobile</code> piece of inventory composites other kinds of inventory, apps. As such, when it accepts a visitor, it is responsible for telling each app that it needs to accept the visitor as well. Since <code>App</code> accepts visitors and the Visitor implements <code>visitApp()</code>, the pattern circle is complete.<br /><br />I can calculate the costs for all of my inventory, apps and all:<pre class=prettyprint>$ ./bin/cost.dart<br />Cost of work stuff: 2160.5.</pre>I begin to appreciate the GoF equipment / inventory example. I helps to highlight where the pain is. As they noted, adjusting the Visitor class is relatively lightweight. But adding a node or two really involves much work. While it might not be complex work—the pattern is one of those that emphasizes encapsulation—each new node requires the node class as well as new visit methods in each concrete visitor in use.<br /><br />I expect that adding a new visitor or tweaking the data structure (without adding a new node type) are the kinds of operations that require almost no work. I will pick back up exploring that tomorrow.<br /><br /><br /><br /><span style="color: #ccc">Day #113</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/simple-visitor-pattern-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/what-heck-is-double-dispatch-and-does.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/h5WfV3isabM" height="1" width="1"/>
