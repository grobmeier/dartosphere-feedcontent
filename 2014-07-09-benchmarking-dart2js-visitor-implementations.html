---
title: 'Benchmarking dart2js Visitor Implementations'
layout: post
published: '2014-07-09T23:58:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/G1-_HoEfxYA/benchmarking-dart2js-visitor.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />I learned a good lesson last night in regards to benchmarking <a href="http://dartlang.org">Dart</a> code: keep everything separate. Keep the different benchmark harnesses in separate scripts. I think it also a good idea to keep the implementations being benchmarked in separate libraries. With that in mind, I add a new approach tonight (bringing the number of implementations up to three) and try them out in JavaScript.<br /><br />I am still benchmarking the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> as background research for the future <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. Although I tend to hate the pattern when I come across it in the wild, I rather enjoy it in Dart. For my sample code, I have a settled on a data structure representing work stuff inventory:<pre class=prettyprint><code>  var work_stuff = new InventoryCollection([<br />    mobile()..apps = [<br />      app('2048', price: 10.0),<br />      app('Pixel Dungeon', price: 7.0),<br />      app('Monument Valley', price: 4.0)<br />    ],<br />    tablet()..apps = [<br />      app('Angry Birds Tablet Platinum Edition', price: 1000.0)<br />    ],<br />    laptop()<br />  ]);</code></pre>Each node in the work stuff data structure (laptop, mobile, app, etc.) implements the Visitor pattern by defining an <code>accept()</code> method that in turn calls a corresponding method in the Visitor object. The result is that I can throw together a new operation on the data structure without changing the structure or any nodes within it. By way of examples, I have simple total price and categorizing visitors:<pre class=prettyprint><code><b>  var cost = new PricingVisitor();</b><br />  work_stuff.accept(cost);<br />  print('Cost of work stuff: ${cost.totalPrice}.');<br /><br /><b>  var counter = new TypeCountVisitor();</b><br />  work_stuff.accept(counter);<br />  print('I have ${counter.apps} apps!');</code></pre>And it is fairly fast. Even adding 1500 apps to the data structure only requires a little over 100µs to run these. I took up suggestions from the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> and tried iterators inside the node structure with double and single dispatch. After realizing the need for keeping these in separate files, I found that the single dispatch approach was slightly faster (as expected).<br /><br />The other approach suggested by the GoF was to make the visitor itself responsible for traversing the node structure. I am unsure if my current node structure is sufficiently complex to notice a difference, but this is for SCIENCE! Actually, exploring how I approach benchmarking at this point is at least as important as the actual numbers so I forge ahead.<br /><br />I start by removing <code>forEach()</code> iterations from a copy of my data structure. The top-level <code>InventoryCollection</code> no longer iterates over its collection—it just calls the <code>visitInventoryCollection()</code> method in the visitor, expecting the visitor to perform the iterations. The various classes that have apps no longer iterate over each app—the corresponding method in the visitor will do that:<pre class=prettyprint>library inventory3; // visitor does the traversing<br />// ...<br />class InventoryCollection {<br />  String name;<br />  List&lt;Inventory> stuff = [];<br />  InventoryCollection(this.stuff);<br /><b>  void accept(visitor) {visitor.visitInventoryCollection(this);}</b><br />}<br />// ...<br />class Mobile extends EquipmentWithApps {<br />  Mobile(): super('Mobile Phone');<br />  double netPrice = 350.00;<br /><b>  void accept(visitor) {visitor.visitMobile(this);}</b><br />}<br />// ...</pre>Then I implement the iterating Visitor as:<pre class=prettyprint>library visitor;<br /><br />import 'inventory_non_traversing.dart';<br />export 'inventory_non_traversing.dart';<br /><br />abstract class InventoryVisitor {<br />  void visitMobile(Mobile i);<br />  void visitTablet(Tablet i);<br />  void visitLaptop(Laptop i);<br />  void visitApp(App i);<br />}<br /><br />class PricingVisitor extends InventoryVisitor {<br />  double _totalPrice = 0.00;<br /><br />  double get totalPrice => _totalPrice;<br /><br />  void visitInventoryCollection(i) {<br /><b>    _iterate(i.stuff);</b><br />  }<br />  void visitMobile(i) {<br /><b>    _iterate(i.apps);</b><br />    _totalPrice += i.netPrice;<br />  }<br />  // ...<br /><b>  void _iterate(list) {<br />    list.forEach((i){ i.accept(this); });<br />  }</b><br />}</pre>Thanks to double dispatching, the same <code>_iterate()</code> method can work regardless of the type of collection. Since this is the Visitor Pattern, every node in the structure defines a <code>accept()</code> (to call the appropriate method back in the same Visitor).<br /><br />With that, can throw together the usual benchmark_harness file for this new implementation:<pre class=prettyprint>#!/usr/bin/env dart<br /><br />import 'package:benchmark_harness/benchmark_harness.dart';<br />import 'package:visitor_code/traversing_visitor.dart';<br /><br />var visitor, nodes;<br /><br />_setup(){<br />  visitor = new PricingVisitor();<br /><br />  nodes = new InventoryCollection([mobile(), tablet(), laptop()]);<br />  for (var i=0; i&lt;1000; i++) {<br />    nodes.stuff[0].apps.add(app('Mobile App $i', price: i));<br />  }<br />  for (var i=0; i&lt;100; i++) {<br />    nodes.stuff[1].apps.add(app('Tablet App $i', price: i));<br />  }<br />}<br /><br />class TraversingVisitorBenchmark extends BenchmarkBase {<br />  const TraversingVisitorBenchmark() : super("Visitor Traverses");<br />  static void main() { new TraversingVisitorBenchmark().report(); }<br /><br />  void run() {<br />    nodes.accept(visitor);<br />  }<br />}<br /><br />main () {<br />  _setup();<br /><br />  TraversingVisitorBenchmark.main();<br />  TraversingVisitorBenchmark.main();<br />}<br /></pre>The benchmark code establishes simple node structure with one mobile, tablet, laptop and a bunch of apps. It then visits the node structure in the <code>run()</code> method to get the benchmark numbers.<br /><br />Comparing this approach with the single and double dispatch versions of the iterators inside the node structure, I find:<pre class=prettyprint>$ ./tool/benchmark_for_single_dispatch.dart; \<br />  ./tool/benchmark_for_double_dispatch.dart; \<br />  ./tool/benchmark_traversing_visitor.dart <br />Nodes iterate w/ single dispatch (RunTime): 116.5093790050099 us.<br />Nodes iterate w/ single dispatch (RunTime): 113.90818999886092 us.<br />Nodes iterate w/ double dispatch (RunTime): 128.8078830424422 us.<br />Nodes iterate w/ double dispatch (RunTime): 125.65971349585323 us.<br />Visitor Traverses(RunTime): 125.47838634795157 us.<br />Visitor Traverses(RunTime): 122.737035900583 us.<br /></pre>So the visitor traversing the structure is comparable to the internal double dispatching approach. That is not too unexpected since this approach also uses double dispatching.<br /><br />What is interesting is what happens when I compile to JavaScript:<pre class=prettyprint>$ dart2js -o tool/benchmark_for_single_dispatch.dart.js tool/benchmark_for_single_dispatch.dart<br />$ dart2js -o tool/benchmark_for_double_dispatch.dart.js tool/benchmark_for_double_dispatch.dart<br />$ dart2js -o tool/benchmark_traversing_visitor.dart.js tool/benchmark_traversing_visitor.dart  <br />$ node tool/benchmark_for_single_dispatch.dart.js<br />Nodes iterate w/ single dispatch (RunTime): 390.70130884938465 us.<br />Nodes iterate w/ single dispatch (RunTime): 391.00684261974584 us.<br />$ node tool/benchmark_for_double_dispatch.dart.js<br />Nodes iterate w/ double dispatch (RunTime): 378.57278061707365 us.<br />Nodes iterate w/ double dispatch (RunTime): 376.01052829479227 us.<br />$ node tool/benchmark_traversing_visitor.dart.js<br />Visitor Traverses(RunTime): 391.6960438699569 us.<br />Visitor Traverses(RunTime): 391.6960438699569 us.<br /></pre>For some reason the internal double dispatching approach is the winner in this case. It is not a huge win, but it is noticeable.<br /><br />Up tomorrow, I am going to play around with the benchmark_harness package itself. I have need to specialize an method or two.<br /><br /><br /><span style="color: #ccc">Day #117</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/wonky-benchmarks-for-single-and-double.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/G1-_HoEfxYA" height="1" width="1"/>
