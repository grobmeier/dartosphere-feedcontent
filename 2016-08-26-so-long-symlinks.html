---
title: 'So Long, Symlinks!'
layout: post
published: '2016-08-26T15:56:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/08/so-long-symlinks.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: ''

---

Long ago, back in the dawn of time, when nary a Dart file was to be found outside of the <a href="https://github.com/dart-lang/sdk">SDK repository</a>, imports in Dart only supported file paths. As the language got older and an ecosystem began to grow around it, it quickly became clear that paths weren’t enough: Dart needed a way to import libraries that didn’t care about the location of the file doing the importing. The language team talked to the VM team and they came up with a solution. In addition to <code>file:</code> URIs, Dart would support a new <code>package:</code> scheme by looking for packages in a <code>packages/</code> directory next to the entrypoint, wherever that happened to be.<br /><br />This worked pretty well—well enough to form the foundation for the pub package manager, written by <a href="https://github.com/munificent">Bob</a> and myself. But it also had flaws. A <em>lot</em> of symlinks had to be generated all over every package—the <code>test</code> package currently contains about four hundred. Not only was this messy, many tools ended up following the symlinks and corrupting the package cache. So the team came together again and came up with the idea of a <a href="https://github.com/dart-lang/dart_enhancement_proposals/blob/master/Accepted/0005%20-%20Package%20Specification/DEP-pkgspec.md">package configuration file</a> that lists available packages as well as the concrete URIs where they can be found.<br /><br />Support for package config was quickly added to all Dart implementations. In fact, pub has been generating them since Dart 1.12. The only task remaining was to gracefully turn off pub’s support for generating the <code>packages/</code> directory and all the symlinks that come with it… but that turned out to be easier said than done.<br /><br />The thing is, for all its flaws, the <code>packages/</code> directory was pretty easy to work with from Dart code. You just had to do some path manipulation with <a href="https://api.dartlang.org/stable/1.18.1/dart-io/Platform/script.html"><code>Platform.script</code></a> to figure out where the <code>packages/</code> directory was, and from there you could do whatever you wanted. It wasn’t clean, but it worked most of the time, and there was no way to do the same stuff with <code>.packages</code>.<br /><br />Once again conversation ensued. APIs were proposed, rejected, redesigned, tweaked, implemented, rolled back, iterated on, landed, stabilized<a class="footnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fn:1" id="fnref:1" title="See footnote">1</a>, and verified. It took seven releases to get everything just right, but we did it, and we’re ready for you to try it out. And I’m here to tell you how.<br /><br /><h2 id="disabling-the-packages-directory">Disabling The Packages Directory</h2><br />The first step on your journey to package enlightenment is to abandon your attachment to worldly directories. Relinquish your need for the comfort of familiarity by passing <code>--no-package-dir</code><a class="footnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fn:2" id="fnref:2" title="See footnote">2</a> to <code>pub get</code> (or <code>upgrade</code> or <code>downgrade</code>). Pub won’t generate a <code>packages/</code> directory, nor of course will it symlink to the directory that it doesn’t generate. If you already had a <code>packages/</code> directory, pub will get rid of it as well as any symlinks pointing its way.<br /><br />For most packages and applications, this is all you’ll need to do! The latest versions of core Dart tools like pub and <a href="https://pub.dartlang.org/packages/test"><code>test</code></a> fully support running with a package config. As long as your code isn’t manually dealing with packages, you’re good to go. And if it is, keep reading!<br /><br /><h2 id="core-package-apis">Core Package APIs</h2><br />The core libraries have a few primitive APIs for providing information about package resolution. They form the foundation of more advanced APIs implemented in packages, but they’re also straightforward enough to use on their own. They cover many of the most common use-cases for dealing with packages. It’s important to note, though, that they only work in the Dart VM; the JavaScript compilers only deal with packages at compile-time, so they have no way of reporting anything about them at runtime.<br /><br />The most broadly-applicable library package API is <a href="https://api.dartlang.org/stable/latest/dart-isolate/Isolate/resolvePackageUri.html"><code>Isolate.resolvePackageUri()</code></a>. It converts a <code>package:</code> URI into a <code>file:</code><a class="footnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fn:3" id="fnref:3" title="See footnote">3</a> URL that can be <a href="https://www.dartdocs.org/documentation/path/latest/path/fromUri.html">easily converted to a path</a>. This is the easiest way to find resources in your package, or even public resources in your dependencies.<br /><br />It’s important to note that this API is asynchronous, though: it returns a <code>Future&lt;Uri&gt;</code> rather than just a <code>Uri</code>. This is because the VM loads package information lazily, and the load process is asynchronous. If you have any <code>package:</code> imports in your code, the information will already be loaded, but it’s not safe to assume that—even code that uses lots of different packages may be run from a snapshot every now and then.<br /><br />The other important core APIs tell you where the package resolution comes from. <a href="https://api.dartlang.org/stable/latest/dart-isolate/Isolate/packageConfig.html"><code>Isolate.packageConfig</code></a> returns the URL of the package config file used for the current isolate, and <code>null</code> if a package root is being used. Its twin, <a href="https://api.dartlang.org/stable/latest/dart-isolate/Isolate/packageRoot.html"><code>Isolate.packageRoot</code></a>, returns the URL of the current isolate’s package root, and <code>null</code> if a package config is being used. These getters are useful for forwarding the current resolution scheme—for example, if you want to start a Dart process that uses the same resolution as the current isolate, you can use these to figure that out.<br /><br />I should probably also mention the <a href="https://api.dartlang.org/stable/latest/dart-io/Platform/packageConfig.html"><code>Platform.packageConfig</code></a> and <a href="https://api.dartlang.org/stable/latest/dart-io/Platform/packageRoot.html"><code>Platform.packageRoot</code></a> getters as well, but <em>I do not recommend using them</em>. They return exactly the text passed on the command-line for the <code>--packages</code> or <code>--package-root</code> flag, respectively. This means they’re unreliable: if the package resolution information was auto-detected, they’ll return <code>null</code>. If the current Isolate uses a different resolution scheme than the main isolate, they could return something completely irrelevant. Avoid them.<br /><br /><h2 id="the-packageresolver-package">The <code>package_resolver</code> Package</h2><br />If you want to go beyond the basics in your package code, <a href="https://pub.dartlang.org/packages/package_resolver"><code>package_resolver</code></a> is the package for you. It provides classes that encapsulate <em>strategies</em> for package resolution—using a package config, using a root, or using nothing at all. Where code used to just pass around a <code>packageRoot</code> string, it can now pass a <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver-class.html"><code>PackageResolver</code></a> that says how to resolve URIs.<br /><br />You can construct a <code>PackageResolver</code> by passing a package config map to <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/PackageResolver.config.html"><code>new PackageResolver.config()</code></a>, or by passing a package root to <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/PackageResolver.root.html"><code>new PackageResolver.root()</code></a>. If all you have is the URI for a package config, you can also use <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/loadConfig.html"><code>PackageResolver.loadConfig()</code></a>. But most of the time, all you need is information about the current isolate’s package resolution, which you can get from the <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/current.html"><code>PackageResolver.current</code></a> getter.<br /><br />The resolver supports more or less the same APIs that the Isolate does: <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/resolveUri.html"><code>resolveUri()</code></a> is equivalent to <code>Isolate.resolvePackageUri()</code>, <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/packageConfigUri.html"><code>packageConfigUri</code></a> to <code>Isolate.packageUri</code>, and <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/packageRoot.html"><code>packageRoot</code></a> to <code>Isolate.packageRoot</code>. But it builds other useful methods on top of these as well.<br />The <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/packagePath.html"><code>packagePath()</code></a> method returns the root of a package on the local filesystem. It assumes that you’re using pub, since it needs to look above packages’ <code>lib/</code> directories, but this works in practice for essentially all Dart code.<br /><br />The <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/packageUriFor.html"><code>packageUriFor()</code></a> method is the reverse of <code>Isolate.resolvePackageUri()</code>: it converts a <code>file:</code> URL into a <code>package:</code> URI that refers to the same file, if such a URI exists. This is useful for reporting nice-looking messages; it’s much easier to read a short <code>package:</code> URI than a long absolute path.<br /><br />The <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/processArgument.html"><code>processArgument</code></a> getter is useful when running Dart processes or compiling Dart to JS. It returns an argument that can be passed directly to the <code>dart</code>, <code>dart2js</code>, or <code>dartdevc</code> executables that will cause them to use the resolver’s resolution strategy. If you passed using a custom package config map, it’ll even manufacture a <code>data:</code> URI for you<a class="footnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fn:4" id="fnref:4" title="See footnote">4</a>.<br /><br />It even exposes the package config map directly through the <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/packageConfigMap.html"><code>packageConfigMap</code></a> getter. Note that since the isolate API doesn’t <a href="https://github.com/dart-lang/sdk/issues/25507">yet</a> provide this information directly, this may require re-loading it from disk.<br /><br /><h3 id="but-i-want-it-synchronous">But I Want It Synchronous!</h3><br />All the <code>PackageResolver</code> APIs are asynchronous because they might be implemented using the asynchronous Isolate APIs. But asynchrony can be annoying to work with, and sometimes it’s not necessary. That’s what the <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/SyncPackageResolver-class.html"><code>SyncPackageResolver</code></a> class is for. It exposes pretty much the same API as <code>PackageResolver</code>, but with no futures to be found.<br /><br />The catch is that if you want to get a <code>SyncPackageResolver</code>, all the information—the package config map or the package root URI—needs to be available up-front. So <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/SyncPackageResolver/current.html"><code>SyncPackageResolver.current</code></a> and <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/SyncPackageResolver/loadConfig.html"><code>SyncPackageResolver.loadConfig()</code></a> both return <code>Future&lt;SyncPackageResolver&gt;</code>, since they have to wait for Isolate API futures and/or load information from disk.<br /><br />You can convert back and forth between synchronous and asynchronous package resolvers easily using the <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/PackageResolver/asSync.html"><code>asSync</code></a> and <a href="https://www.dartdocs.org/documentation/package_resolver/latest/package_resolver/SyncPackageResolver/asAsync.html"><code>asAsync</code></a> APIs. This makes it possible for packages to take whichever one they work best with without causing pain for their users. For example, <a href="https://www.dartdocs.org/documentation/source_map_stack_trace/latest/source_map_stack_trace/mapStackTrace.html"><code>source_map_stack_trace</code></a> takes a <code>SyncPackageResolver</code> so it can work synchronously, but <a href="https://www.dartdocs.org/documentation/shelf_packages_handler/latest/shelf_packages_handler/packagesHandler.html"><code>shelf_packages_handler</code></a> takes a <code>PackageResolver</code> since serving handling requests is already inherently async.<br /><br /><h3 id="why-bother-with-the-package-root">Why Bother With The Package Root?</h3>The <code>package_resolver</code> package goes to pains to work well with both package configs and package roots, and to make it easy for users to support both. This raises a question: if pub is moving away from generating a <code>packages/</code> directory, what’s the point of supporting it?<br /><br />First of all, there’ll be a transition period where both modes will be fairly common. Pub still generates the <code>packages/</code> directory by default for now, and the language implementations prefer it if it exists. A smooth transition relies on code’s ability to be used in both old and new settings.<br />But even in the future when <code>packages/</code> files aren’t generated by default, support for package roots will be sticking around, and it can still be useful. It may not be the best way to run code manually, but a lot of code isn’t run manually—Pub’s transformer support, for example, loads isolates over HTTP, where it serves virtual <code>packages/</code> directories.<br /><br />In addition to supporting current tools, we want leave the door open for future tools to innovate as-yet-undreamed-of ways to handle Dart code. So we choose flexibility and continue to support package roots.<br /><br /><h2 id="on-into-the-future">On Into The Future</h2>Once there’s been a release or two with the <code>--no-package-dir</code> flag and users have a chance to make sure their packages work with only a package config, we’ll disable the flag by default. You’ll need to pass <code>--packages-dir</code> explicitly if you want it generated. A while after that, we’ll hide the flag and stop officially supporting it. We may get rid of it entirely one day, but there’s no hurry—it’s not that hard to support.<br /><br />So go forth and update your packages! Use the core library APIs and the <code>package_resolver</code> package, or one of the helpful packages I didn’t have a chance to get to: <a href="https://pub.dartlang.org/packages/resource"><code>resource</code></a> provides an abstraction for loading resources, and <a href="https://pub.dartlang.org/packages/shelf_packages_handler"><code>shelf_packages_handler</code></a> makes it easy for a Shelf server to support a package root. Or write your own! The underlying tools are powerful, and I’m excited to see what you can do with them.<br /><div class="footnotes"><hr /><ol><li id="fn:1">Well, <em>mostly</em> stabilized. There are still a few corners of the API that are still in the process of being thoroughly tested. Bear with us if you run into them, and maybe wait another release cycle before you depend <em>too</em> heavily on running without the <code>packages/</code> directory. <a class="reversefootnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fnref:1" title="Return to article">↩</a></li><li id="fn:2">This flag is new in 1.19, but some readers may notice its similarity to the undocumented <code>--no-package-symlinks</code> that pub used to support. <code>--no-package-symlinks</code> was added ages ago to let the Dart analyzer team experiment with their package config support, and we decided to tweak it a bit when making it public. <a class="reversefootnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fnref:2" title="Return to article">↩</a></li><li id="fn:3">Since the Dart VM supports loading packages over HTTP, it’s theoretically possible for it to return an <code>http:</code> URL. This doesn’t happen that often in practice, but it is a possibility—for example, the <code>test</code> runner can load test suites over HTTP from a <code>pub serve</code> instance. <a class="reversefootnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fnref:3" title="Return to article">↩</a></li><li id="fn:4">Note that there are usually limits on how long command-line arguments can be, so this may not work if the package config is too big. <a class="reversefootnote" href="https://draft.blogger.com/blogger.g?blogID=1636601191077561071#fnref:4" title="Return to article">↩</a></li></ol></div>
