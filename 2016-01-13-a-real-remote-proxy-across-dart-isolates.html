---
title: 'A Real Remote Proxy Across Dart Isolates'
layout: post
published: '2016-01-13T22:25:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/x5cEuKNNmto/a-real-remote-proxy-across-dart-isolates.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - isolates
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />My many adventures with the <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> in <a href="http://dartlang.org">Dart</a> continues. After day 1, I workable, if ugly code. After day 2, I have nicer, if not-quite-a-proxy-pattern code. So tonight I hope to actually implement a somewhat nice looking version of an actual remote proxy across Dart <a href="https://api.dartlang.org/1.13.2/dart-isolate/dart-isolate-library.html">isolates</a>. <br /><br />Let's see how I can mess that up.<br /><br />The setup between the main worker and the isolate worker is pretty typical isolate setup. The main worker holds a <code>ProxyCar</code> and will communicate to a real <code>Car</code> in the isolate. It starts by creating a <code>ReceivePort</code> on which it can listen for messages <i>from</i> the isolate, spawns the isolate, then waits for the first message back from that isolate which will be a <code>SentPort</code> to send messages back <i>to</i> the isolate:<pre class=prettyprint>main() async {<br />  var r = new ReceivePort();<br />  var receiveStream = r.asBroadcastStream();<br /><br />  await Isolate.spawn(other, r.sendPort);<br /><br />  SendPort s = await receiveStream.first;<br />  // Remote car stuff will follow...<br />}</pre>Similarly, the <code>other()</code> isolate that holds a real <code>Car</code> instance accepts the <code>SendPort</code> from <code>main()</code> and creates its own <code>ReceivePort</code> to send to <code>main()</code>:<pre class=prettyprint>other(SendPort s) {<br />  var r = new ReceivePort();<br />  var receiveStream = r.asBroadcastStream();<br />  s.send(r.sendPort);<br /><br />  new Car(receiveStream, s);<br />}</pre>Thanks to the very nice <a href="https://www.dartlang.org/articles/await-async/">async / await</a> syntax in Dart, I was able to clean up a lot of initial async messiness. But now I realize that my remote proxy class does not match the real subject. The <code>ProxyCar</code> class returns <code>Future</code> instances for car actions:<pre class=prettyprint>class ProxyCar implements Automobile {<br />  // ...<br />  Future drive() => _send(#drive);<br />  Future stop()  => _send(#stop);<br />  // ...<br />}</pre>The real subject (and the interface that both classes implement) declares <code>start()</code> and <code>stop()</code> as returning nothing:<pre class=prettyprint>class Car implements Automobile {<br />  // ...<br />  void drive() { state = 'driving'; }<br />  void stop()  { state = 'idle'; }<br />}</pre>Interestingly (at least to me) is that the Dart type analyzer does not consider this a problem. I would still feel more comfortable if the remote proxy class and the real subject class both implemented the same interface. <br /><br />There is nothing to be done about the <code>ProxyCar</code> interface. Communication across isolates is inherently asynchronous. So I will experiment with the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a>, adapting a synchronous <code>Car</code> class to an asynchronous version. This might not be the best idea, but...<br /><br />It does have the advantage of producing a nice, clear <code>Car</code> class:<pre class=prettyprint>// Adaptee<br />class Car implements Automobile {<br />  String state = 'idle';<br />  void drive() { state = 'driving'; }<br />  void stop()  { state = 'idle'; }<br />}</pre>For the remote proxy, I define a new interface for both the <code>AsyncCar</code> and <code>ProxyCar</code> classes to implement, this time with futury goodness:<pre class=prettyprint>// Subject<br />abstract class AsyncAuto implements Automobile {<br />  String get state;<br />  void drive();<br />  void stop();<br />}</pre>The <code>AsyncCar</code> class then become both the adapter and real subject. The async messiness as well as the send and receive ports pile into it:<pre class=prettyprint>// Real Subject & Adapter<br />class AsyncCar implements AsyncAuto {<br />  SendPort _s;<br />  ReceivePort _r;<br />  Car _car;<br />  AsyncCar(this._r, this._s) {<br />    _car = new Car();<br /><br />    _r.listen((message) {<br />      print("[AsyncCar] $message");<br />      if (message == #drive) _car.drive();<br />      if (message == #stop)  _car.stop();<br />      _s.send(state);<br />    });<br />  }<br /><br />  String get state => _car.state;<br />  Future drive() => new Future((){ _car.drive(); });<br />  Future stop()  => new Future((){ _car.stop(); });<br />}</pre>Not much has changed in there from the previous two nights aside from <code>state</code>, <code>drive()</code>, and <code>stop()</code> methods which now forward requests to a concrete <code>Car</code> instance. The <code>drive()</code> and <code>stop()</code> methods also return <code>Future</code> instances for completeness.<br /><br />Nothing in the <code>ProxyCar</code> class needs to change other than the interface that it implements, which the new <code>AsyncAuto</code> interface:<pre class=prettyprint>// Proxy Subject<br />class ProxyCar implements AsyncAuto {<br />  // ...<br />}</pre>Last, I change the isolate to create an <code>AsyncCar</code>:<pre class=prettyprint>other(SendPort s) {<br />  var r = new ReceivePort();<br />  var receiveStream = r.asBroadcastStream();<br />  s.send(r.sendPort);<br /><br />  new AsyncCar(receiveStream, s);<br />}</pre>With that, I have more traditional version of the remote proxy in which both the remote subject and real subject implement the same interface. I appreciate that the <code>Car</code> class is very clean now. Aside from that, I am unsure that I have bought myself any improvements in code readability or maintainability. So, for now, I would have to rate the benefit of this exercise inconclusive... but fun.<br /><br /><br /><span style="color: #ccc">Day #63</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/await-async-code-cleanup-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/x5cEuKNNmto" height="1" width="1" alt=""/>
