---
title: 'Precision vs Accuracy in Benchmarking'
layout: post
published: '2014-07-10T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/DLwRiq_sGyc/precision-vs-accuracy-in-benchmarking.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />I continue to explore benchmarking design patterns for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. I am still in the preliminary stages of research for the book so the actual benchmarks are not as important as how I want to benchmark. The simple answer is to use <a href="https://github.com/dart-lang/benchmark_harness">benchmark_harness</a>—the official benchmark harness for <a href="http://dartlang.org">Dart</a>. As I have found over the past couple of days, there is more involved than simply using it.<br /><br />I have already determined that it is best to <a href="http://japhr.blogspot.com/2014/07/wonky-benchmarks-for-single-and-double.html">run implementation comparisons in separate files</a>. Further investigation by Vyacheslav Egorov (aka <a href="https://twitter.com/mraleph">@mraleph</a>) suggests that I need to run the benchmark code longer than I currently am:<br /><blockquote class="twitter-tweet" data-conversation="none" lang="en"><p><a href="https://twitter.com/eee_c">@eee_c</a> I looked a bit at it today, but there are some seriously confusing performance flakes there. I recommend making run() longer running</p>&mdash; Vyacheslav Egorov (@mraleph) <a href="https://twitter.com/mraleph/statuses/487219911245451264">July 10, 2014</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet" data-conversation="none" lang="en"><p><a href="https://twitter.com/eee_c">@eee_c</a> e.g. by adding a loop in run() --- I can&#39;t explain flakes though they come and go when I try to catch them</p>&mdash; Vyacheslav Egorov (@mraleph) <a href="https://twitter.com/mraleph/statuses/487220117651353600">July 10, 2014</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><blockquote class="twitter-tweet" data-conversation="none" lang="en"><p><a href="https://twitter.com/eee_c">@eee_c</a> everything stabilizes with longer running run()</p>&mdash; Vyacheslav Egorov (@mraleph) <a href="https://twitter.com/mraleph/statuses/487220186312114176">July 10, 2014</a></blockquote><script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script><br />Taking Vyacheslav up on his advice, I work through each of my three <a href=""http://en.wikipedia.org/wiki/Visitor_pattern>Visitor Pattern</a> implementations (in the <a href="https://github.com/eee-c/design-patterns-in-dart/tree/master/visitor/tool">visitor/tool</a> directory of the <a href="https://github.com/eee-c/design-patterns-in-dart">Design Patterns public repository</a>). To each, I add a loop to the <code>run()</code> method of the harness:<pre class=prettyprint>class NodesDoubleBenchmark extends BenchmarkBase {<br />  const NodesDoubleBenchmark() : super("Nodes iterate w/ double dispatch ");<br />  static void main() { new NodesDoubleBenchmark().report(); }<br /><br /><b>  void run() {<br />    for (var i=0; i<10^6; i++) {<br />      visitor.totalPrice = 0.0;<br />      nodes.accept(visitor);<br />    }</b><br />}<br /></pre>In each of the three benchmarks, I loop over the visit a million times. For good measure, I run each benchmark report 3 times.<br /><br />When I run the code, I find:<pre class=prettyprint>$ ./tool/benchmark_for_single_dispatch.dart; \<br />  echo "--"; \<br />  ./tool/benchmark_for_double_dispatch.dart; \<br />  echo "--"; \<br />  ./tool/benchmark_traversing_visitor.dart <br />Nodes iterate w/ single dispatch (RunTime): 1373.6263736263736 us.<br />Nodes iterate w/ single dispatch (RunTime): 1331.5579227696405 us.<br />Nodes iterate w/ single dispatch (RunTime): 1344.0860215053763 us.<br />--<br />Nodes iterate w/ double dispatch (RunTime): 1381.9060773480662 us.<br />Nodes iterate w/ double dispatch (RunTime): 1322.7513227513227 us.<br />Nodes iterate w/ double dispatch (RunTime): 1345.8950201884254 us.<br />--<br />Visitor Traverses(RunTime): 1452.4328249818445 us.<br />Visitor Traverses(RunTime): 1417.4344436569809 us.<br />Visitor Traverses(RunTime): 1411.4326040931546 us</pre>I notice two things here. First, the difference between single and double dispatching is negligible. Also, the default reporter has a precision vs. accuracy.<br /><br />When the objects structure is responsible for traversing itself, double dispatching surprisingly has no effect. I can only speculate that the VM recognizes the double dispatch target method and is able to optimize calls to it. Oddly (and unlike last night's non-looping benchmark), making the visitor responsible for traversing object structure is the loser.<br /><br />Since this is an exercise more focused on how to benchmark than the actual results, I will let those slide for now. Besides, I am far more bothered by benchmark_harness' incredible precision (13 decimal places!) when the runs vary by 40µs. The reported precision implies an accuracy that is simply not possible.<br /><br />If the numbers are varying at the third significant digit, it makes no sense to report more than 4 significant digits. This means that I need a new benchmark reporter. The benchmark_harness package defines a simple interface for its “emitters”:<pre class=prettyprint>abstract class ScoreEmitter {<br />  void emit(String testName, double value);<br />}</pre>I implement this locally as <code>ProperPrecisionScoreEmitter</code>:<pre class=prettyprint>class ProperPrecisionScoreEmitter implements ScoreEmitter {<br />  const ProperPrecisionScoreEmitter();<br /><br />  void emit(String testName, double value) {<br />    print("$testName (RunTime): ${<b>value.toStringAsPrecision(4)</b>} µs.");<br />  }<br />}</pre>The key difference between the default implementation and mine is that I explicitly request a sane precision with <code>double</code>'s <code>toStringAsPrecision()</code> method.<br /><br />To use this sane precision emitter, I update my redirecting constructor in the benchmark class. The constructor in the <code>BenchmarkBase</code> accepts an optional named <code>emitter</code>:<pre class=prettyprint>class NodesDoubleBenchmark extends BenchmarkBase {<br />  const NodesDoubleBenchmark() :<br />    super(<br />      "Nodes iterate w/ double dispatch",<br /><b>      emitter: const ProperPrecisionScoreEmitter()</b><br />    );<br />  static void main() { new NodesDoubleBenchmark().report(); }<br /><br />  void run() {<br />    // run the benchmarked code here ...<br />  }<br />}</pre>After doing that for each of my implementation benchmarks, I have:<pre class=prettyprint>$ ./tool/benchmark_for_single_dispatch.dart; echo "--"; ./tool/benchmark_for_double_dispatch.dart; echo "--"; ./tool/benchmark_traversing_visitor.dart <br />Nodes iterate w/ single dispatch (RunTime): 1371 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1322 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1328 µs.<br />--<br />Nodes iterate w/ double dispatch (RunTime): 1377 µs.<br />Nodes iterate w/ double dispatch (RunTime): 1324 µs.<br />Nodes iterate w/ double dispatch (RunTime): 1316 µs.<br />--<br />Visitor Traverses (RunTime): 1476 µs.<br />Visitor Traverses (RunTime): 1417 µs.<br />Visitor Traverses (RunTime): 1445 µs.<br /></pre>Ahhh. Much better.<br /><br />The deviation between runs remains an open question. Certainly other activity on my machine plays some part in it, but it would be nice if the numbers could have a little more precision. I will investigate the actual benchmark code tomorrow to see if this is possible.<br /><br /><br /><span style="color: #ccc">Day #118</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/benchmarking-dart2js-visitor.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/DLwRiq_sGyc" height="1" width="1"/>
