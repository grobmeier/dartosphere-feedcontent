---
title: 'Cleaning Up that Dart Isolate Mess'
layout: post
published: '2016-01-14T23:43:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/KCTHSGzTF0s/cleaning-up-that-dart-isolate-mess.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - isolates
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />I am kinda OK with my current remote <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> implementation in <a href="http://dartlang.org">Dart</a>. Sorta.<br /><br />Actually, the proxy itself is decent, thanks in large part to the <a href="https://www.dartlang.org/articles/await-async/">async / await</a> syntax introduced the other night:<pre class=prettyprint>main() async {<br />  // Spawn remote isolate worker here...<br /><br />  ProxyCar car = new ProxyCar(receiveStream, s);<br /><br />  await car.drive();<br />  print("Car is ${car.state}");<br /><br />  await car.stop();<br />  print("Car is ${await car.state}");<br />}</pre>Futures and promises are nice constructs, but they sure can get noisy. Dart uses <code>await</code> inside of an <code>async</code> function as syntactic sugar. <br /><br />That code looks so nice that the code responsible for spawning the isolate worker is bugging me:<pre class=prettyprint>main() async {<br />  var r = new ReceivePort();<br />  var receiveStream = r.asBroadcastStream();<br /><br />  await Isolate.spawn(other, r.sendPort);<br /><br />  SendPort s = await receiveStream.first;<br /><br />  ProxyCar car = new ProxyCar(receiveStream, s);<br />  // ...<br />}</pre>I think I would prefer my client code to look something like:<pre class=prettyprint><code>  ProxyCar car = new ProxyCar();<br />  await Isolate.spawn(other, car.sendPort);<br />  await car.ready;<br />  // ...</code></pre>I initially try to jam all of the isolate communication code directly into the <code>ProxyCar</code>. As most would expect, that made for a messy <code>ProxyCar</code>. So instead, I define a <code>Talker</code> class to establish a <code>ReceivePort</code> in the current isolate, listen on that same <code>ReceivePort</code> for a <code>SendPort</code> sent by the spawned isolate, and a method for sending messages on that <code>SendPort</code>:<pre class=prettyprint>class Talker {<br />  SendPort _s;<br />  ReceivePort _r;<br />  Stream _inStream;<br />  Future ready;<br /><br />  Talker() {<br />    _r = new ReceivePort();<br />    _inStream = _r.asBroadcastStream();<br />    ready = _inStream.first.then((message){<br />      _s = message;<br />    });<br />  }<br /><br />  // For others to talk to us<br />  SendPort get sendPort => _r.sendPort;<br /><br />  Future send(message) {<br />    _s.send(message);<br />    return _inStream.first;<br />  }<br />}</pre>I find myself getting confused by the <code>SendPort</code> from the other isolate and the <code>SendPort</code> that this has to expose for the other isolate to communicate back. As a first pass, I make the <code>SendPort</code> from the other isolate private. It is only used internally as is the <code>ReceivePort</code> for communicating back to <code>Talker</code>. I like that except that the <code>SendPort</code> associated with the private <code>ReceivePort</code> is publicly available. So I get confused. I really want to find better names for these beasties, but I have to admit that "send port" and "receive port" capture the intent as well as anything. Oh well.<br /><br />With <code>Talker</code>, I can redefine <code>ProxyCar</code> as:<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  String state = "???";<br />  Talker _t;<br /><br />  ProxyCar() {<br />    _t = new Talker();<br />  }<br /><br />  Future drive() => _send(#drive);<br />  Future stop()  => _send(#stop);<br /><br />  SendPort get sendPort => _t.sendPort;<br />  Future get ready => _t.ready;<br /><br />  Future _send(message) =><br />    _t.<br />      send(message).<br />      then((response){<br />        print("[ProxyCar] $response");<br />        state = response;<br />      });<br />}</pre>That is still a little heavy on the communication side, but I can live with it as all of it delegates to <code>Talker</code> or to the proxied methods (<code>drive()</code>, <code>stop()</code>, etc.). <br /><br />With that, my original goal is met. The client code becomes simply:<pre class=prettyprint>main() async {<br />  ProxyCar car = new ProxyCar();<br /><br />  await Isolate.spawn(other, car.sendPort);<br />  await car.ready;<br /><br />  await car.drive();<br />  print("Car is ${car.state}");<br />  print("--");<br /><br />  await car.stop();<br />  print("Car is ${await car.state}");<br />}</pre>While I like some of this approach, it is proving difficult to explain. I may have to revisit the example or the approach before it is ready for inclusion in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. <br /><br /><br /><span style="color: #ccc">Day #64</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/a-real-remote-proxy-across-dart-isolates.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/KCTHSGzTF0s" height="1" width="1" alt=""/>
