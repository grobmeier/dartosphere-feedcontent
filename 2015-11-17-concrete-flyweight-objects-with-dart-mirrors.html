---
title: 'Concrete Flyweight Objects with Dart Mirrors'
layout: post
published: '2015-11-17T22:23:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/8nbRsIKRHHg/concrete-flyweight-objects-with-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - flyweight
    - mirrors

---

<div class=top-chain-links></div><br />I worried that last night's post on concrete <a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight</a> objects in <a href="http://dartlang.org">Dart</a> would be too easy to warrant a post. Then I actually tried to write the code.<br /><br />So it turns out that we are not allowed to create compile-time static variables in Dart—and haven't been allowed for quite some time. Well, we are allowed, but they will not be evaluated until explicitly invoked. This thwarted my plan to use these static variable declarations to register themselves as flyweight implementations.<br /><br />But the challenge remains. I would very much like to create concrete instances of flyweight objects without resorting to ickery like <code>case</code> statements. Tonight, I explore the dreaded mirrors to accomplish this.<br /><br />Sidenote: I understand that there is a StackOverflow topic on this very question. I am purposefully not reading that discussion so that I can explore the topic fresh here. The answer on StackOverflow is likely far superior to mine. So let's get to mine!<br /><br />In my current coffee shop example, I would like to register orders along the lines of:<pre class=prettyprint>var shop = new CoffeeShop()<br />    ..order('Cappuccino', 'large', who: 'Fred', fooFoo: 'Extra Shot')<br />    ..order('Espresso',   'small', who: 'Bob')<br />    ..order('Frappe',     'large', who: 'Alice')<br />    ..order('Frappe',     'large', who: 'Elsa', fooFoo: '2 Percent Foam')<br />    ..order('Coffee',     'small')<br />    ..order('Coffee',     'medium', who: 'Chris');</pre>Over the course of the day, I expect there to be a large number of orders so I want to minimize the number of objects retained in memory. Enter the flyweight.<br /><br />Specifically, the intrinsic properties of a coffee flavor like “Cappuccino” do not change. The size, the orderer, and silly additional instructions change with each order, but a Cappuccino stays a Cappuccino all day long. So I make this a flyweight object. <br /><br />Thanks to Dart's factory constructors, I do not even require a factory class to accomplish this. From the outside, creating new <code>CoffeeFlavor</code> instances looks just like creating any other object:<pre class=prettyprint>class CoffeeShop {<br />  void order(name, sizeName, {who, fooFoo}) {<br /><b>    var flavor = new CoffeeFlavor(name); // Looks like a regular constructor!!!</b><br />    int size = sizes[sizeName];<br />    _orders.add(new Order(flavor, size, who, fooFoo));<br />  }<br />  // ...<br />}</pre>Before introducing concrete classes for the various coffee flavors, this factory constructor simply looked up a previously used flyweight in a cache:<pre class=prettyprint>class CoffeeFlavor {<br />  // ... <br />  factory CoffeeFlavor(name) =><br />      _cache.putIfAbsent(name, () => new CoffeeFlavor._(name));<br />  // ...<br />}</pre>Instead of a vanilla <code>CoffeeFlavor</code> object, I want an actual instance of <code>Cappuccino</code>:<pre class=prettyprint>class FakeCoffee implements CoffeeFlavor {<br />  String get name => "Fake Coffee";<br />  double get profitPerOunce => 0.0;<br />}</pre>For that, I think I will need mirrors. I start by importing <code>dart:mirrors</code>:<pre class=prettyprint>library coffee_shop;<br /><br />import 'dart:mirrors';<br /></pre>Next, I need to find a mirror for the current library (<code>coffee_shop</code>):<pre class=prettyprint><code>      var m = currentMirrorSystem().findLibrary(#coffee_shop);</code></pre>In the list of declarations of my library mirrors, I can get a class mirror for a given <code>name</code> (e.g. <code>"Cappuccino"</code>):<pre class=prettyprint><code>      var c = m.declarations[new Symbol(name)];</code></pre>Finally, I can get a new instance of that class:<pre class=prettyprint><code>      return c.newInstance(new Symbol(''), []).reflectee;</code></pre>Putting this altogether, my factory constructor becomes:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  factory CoffeeFlavor(name) =><br />    _cache.putIfAbsent(name, (){<br />      var m = currentMirrorSystem().findLibrary(#coffee_shop);<br /><br />      var c = m.declarations[new Symbol(name)];<br />      return c.newInstance(new Symbol(''), []).reflectee;<br />    });<br />  // ...<br />}</pre>I still use a <code>putIfAbsent()</code> to build up the cache—only now it creates concrete instances from mirrors. <br /><br />There are several things to like about this approach. The client context is still blissfully unaware that the Flyweight pattern is in play—it still creates new <code>CoffeeFlavor</code> objects only to receive a flyweight subclass instead. I also like that this approach returns concrete instances of flyweight objects. I may not always need to do so, but it is good to know that this is possible. Lastly, I appreciate that I can accomplish this without a <code>case</code> statement.<br /><br />There are drawbacks, however, to this approach. The Flyweight is intended to save memory, ideally to speed the code up. This approach relies entirely on mirrors which are not exactly high-performance beasties. That said, once the cache is populated, reflection is no longer used so the initial performance hit of mirrors could easily be overcome by later optimizations. It all depends on the context in which the code is being used.<br /><br />(Play with this code on DartPad: <a href="https://dartpad.dartlang.org/c731673e2055fc97db79">https://dartpad.dartlang.org/c731673e2055fc97db79</a>)<br /><br /><br /><span style="color: #ccc">Day #6</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/11/lazy-loading-wins-out.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/11/locking-down-flyweights-mirrors-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/8nbRsIKRHHg" height="1" width="1" alt=""/>
