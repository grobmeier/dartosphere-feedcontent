---
title: 'Robotic Commands'
layout: post
published: '2015-12-14T22:48:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/y6d4oI9wd9Y/robotic-commands.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartang
    - 'design patterns'

---

<div class=top-chain-links></div><br />My daughter loves <a href="https://en.wikipedia.org/wiki/BB-8_(Star_Wars)">BB-8</a> (yes, I'm that guy). She can't walk into my office without asking for her friend "BB." I think she could spend hours chasing him around.<br /><br />At some point while mucking around with it, I realized that a robot controlled by a <a href="http://dartlang.org">Dart</a> application would a good example of the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>. In fact, I think it might be better example for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> than the Velvet Fog Machine that I have been using. Hard as it may be for me to accept, there are more folks familiar with robots than with Mel Tormé.<br /><br />So tonight, I write an implementation of the command pattern for a robot. The command pattern has three components: the invoker, the receiver, and the command. The invoker in this robot example will be a button within an app. There will be multiple buttons for moving in different directions, executing macros, and capturing video. For the command receivers, I will stick with the robot and a camera. The commands will link the receiver with an action.<br /><br />I find the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> confusing when it includes an interface and the client code as "participants" in the pattern. There are three specific objects in this pattern, but the inclusion of these other two consistently makes me think that I am missing a participant. I'm sure it is just semantics, but an interface does not actively do anything in the pattern—it describes the methods that concrete commands must have. <br /><br />Every application has a client, so it is hard to think of that as a participant—it is the context of the application, not a participant, darn it. That said, the client does participate in this pattern—it is responsible for associating commands with receivers. The robot and its camera are the receivers in this case:<pre class=prettyprint>// Client<br />main() {<br />  // Receivers<br />  var robot = new Robot();<br />  var camera = robot.camera;<br />  // ...<br />}</pre>The commands could be a variety of directional movements and camera actions:<pre class=prettyprint><code>  // Concrete command instances<br />  var moveNorth = new MoveNorthCommand(robot),<br />    moveSouth = new MoveSouthCommand(robot),<br />    moveEast = new MoveEastCommand(robot),<br />    moveWest = new MoveWestCommand(robot),<br />    startRecording = new StartRecordingCommand(camera),<br />    stopRecording = new StopRecordingCommand(camera);</code></pre>With that, the commands are linked with specific instances of the receivers.<br /><br />There is nothing special about the <code>Robot</code> and <code>Camera</code> classes. Any class can be a receiver in this pattern and that is what they do here.<br /><br />The command classes need to support a <code>call()</code> as the mechanism for executing concrete commands:<pre class=prettyprint>abstract class Command {<br />  void call();<br />}</pre>For this particular case, the commands need to associate the receiver with the action:<pre class=prettyprint>class MoveNorthCommand implements Command {<br />  Robot robot;<br />  MoveNorthCommand(this.robot);<br />  void call() { robot.move(Direction.NORTH); }<br />}</pre>The <code>robot</code> instance is assigned by client code. When this command is called, that <code>robot</code> instance moves north. The other direction command are identical save for the directions.<br /><br />All that remains is the invoker. In this case, buttons in the UI will invoke commands. The buttons have names and are assigned commands, so the class definition is:<pre class=prettyprint>class Button {<br />  String name;<br />  Command command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />  }<br />}</pre>Back in the client, these are instantiated as:<pre class=prettyprint><code>  // Invokers<br />  var btnUp = new Button("Up", moveNorth);<br />  // ...<br />  var btnRecord = new Button("Record", startRecording);<br />  var btnStopRecord = new Button("Stop Recording", stopRecording);</code></pre>That is all there is. I can press a bunch of buttons:<pre class=prettyprint><code>  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br />  btnRight.press();<br />  btnRight.press();<br />  btnRight.press();<br />  btnLeft.press();<br />  btnDown.press();<br /><br />  btnRecord.press();<br />  btnStopRecord.press();<br /><br />  print("\nRobot is now at: ${robot.location}"</code></pre>And, thanks to a few judicious <code>print()</code> statements, I see:<pre class=prettyprint>./bin/play_robot.dart                          <br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Down<br />  I am moving Direction.EAST<br />[pressed] Down<br />  I am moving Direction.EAST<br />[pressed] Down<br />  I am moving Direction.EAST<br />[pressed] Left<br />  I am moving Direction.WEST<br />[pressed] Down<br />  I am moving Direction.SOUTH<br />[pressed] Record<br />  Capturing video record<br />[pressed] Stop Recording<br />  Video record complete<br /><br />Robot is now at: 2, 2</pre>So it works! And now that I see it... I am not quite as sure that I ought to use it instead of the Velvet Fog Machine example.<br /><br />The commands feel too literal. They are quite explicit commands issued to a robot. Although that is a legitimate use of the command pattern, it has an artificial taste. I would prefer the examples in the book to be a bit closer to real-life examples. Sure, this kind of thing can happen, but the more interesting uses of the pattern occur when the commands are not obvious from the outset.<br /><br />I will sleep on that. For now, here is the DartPad for further experimenting with the command and robots: <a href="https://dartpad.dartlang.org/3b2ac3f421db89c2b56a">https://dartpad.dartlang.org/3b2ac3f421db89c2b56a</a>.<br /><br /><br /><span style="color: #ccc">Day #33</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/repeating-undos-in-command.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/y6d4oI9wd9Y" height="1" width="1" alt=""/>
