---
title: 'Flyweight in Dart'
layout: post
published: '2015-11-12T22:06:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/sh6Ft3CrV84/flyweight-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - flyweight.

---

<div class=top-chain-links></div><br />I lack a clear idea what I want <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> to be. Scholarly like the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>? Visually stimulating like <a href="http://shop.oreilly.com/product/9780596007126.do">Head First Design Patterns</a>? Whimsical? Likely some combination thereof, but until I decide, I explore.<br /><br />Up tonight, I start with the <a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight Pattern</a>. It is a simple enough pattern—so simple that it hardly seems a pattern in some languages, but I need to start somewhere. And since the Wikipedia article was kind enough to include a lovely Ruby example, I start tonight by adapting that example into <a href="http://dartlang.org">Dart</a>.<br /><br />The idea behind the Flyweight Pattern is to save storage space via specialized caching. In the Ruby example of decorating a tree with lamps, the goal is to limit the number of lamp objects that are created. After all, there might be hundreds of lamps on larger tree. There is no real value to creating 200 blue lamp objects, 400 green lamp objects, and 300 red lamp objects. The lamps are all the same—only the branch on the tree changes. In GoF terms, the lamp color is an intrinsic property and the branch on which they reside is extrinsic.<br /><br />Working from the outside, I expect to create a new <code>Tree</code>, hang a bunch of lamps, and then report on it:<pre class=prettyprint>main() {<br />  var tree = new Tree()<br />    ..hang_lamp('red', 1)<br />    ..hang_lamp('blue', 1)<br />    ..hang_lamp('yellow', 1)<br />    ..hang_lamp('red', 2)<br />    ..hang_lamp('blue', 2)<br />    ..hang_lamp('yellow', 2)<br />    ..hang_lamp('red', 3)<br />    ..hang_lamp('blue', 3)<br />    ..hang_lamp('yellow', 3)<br />    ..hang_lamp('red', 4)<br />    ..hang_lamp('blue', 4)<br />    ..hang_lamp('yellow', 4)<br />    ..hang_lamp('red', 5)<br />    ..hang_lamp('blue', 5)<br />    ..hang_lamp('yellow', 5)<br />    ..hang_lamp('red', 6)<br />    ..hang_lamp('blue', 6)<br />    ..hang_lamp('yellow', 6)<br />    ..hang_lamp('red', 7)<br />    ..hang_lamp('blue', 7)<br />    ..hang_lamp('yellow', 7);<br /><br />  print(tree.report);<br />}</pre>Dart method cascades work nicely here to hang a bunch of lamps, but still return the original <code>Tree</code> object. <br /><br />A skeleton of the <code>Tree</code> class might look like:<pre class=prettyprint>class Tree {<br />  int count=0;<br />  void hang_lamp(color, branch) {<br />    count++;<br />  }<br />  String get report => "Added ${count} lamps.";<br />}</pre>I will still need to add a Dart equivalent of the <code>LampFactory</code> from the Wikipedia example, but so far, so good. I can report on the total number of lamps that are added to the tree:<pre class=prettyprint>Added 21 lamps.</pre>The "flyweight" object will be the <code>Lamp</code>, whose intrinsic property (the color) does not change regardless of where it is placed on the tree. The class definition is wonderfully brief in Dart:<pre class=prettyprint>class Lamp {<br />  String color;<br />  Lamp(this.color);<br />}</pre>I never thought I'd say this about Ruby, but the Ruby version from Wikipedia sure is wordy, isn't it?<br /><br />The <code>LampFactory</code> in Dart is even more terse:<pre class=prettyprint>class LampFactory {<br />  var cache = {};<br />  Lamp find_lamp(color) {<br />    return cache.putIfAbsent(color, () => new Lamp(color));<br />  }<br />  int get total_number_of_lamps_made => cache.length;<br />}</pre>The <code>cache</code> is a <code>Map</code> of objects whose key is the color of the lamp. If the color is already present in the cache, then the <code>putIfAbsent()</code> in <code>find_lamp()</code> returns it. If the lamp is not already present, then the second argument to <code>putIfAbsent()</code> is evaluated, added to the cache, and returned. That is a nice example of why I love Dart so much.<br /><br />Last is the <code>TreeBranch</code> class, which has an associated branch number and needs to know how to hang a lamp:<pre class=prettyprint>class TreeBranch {<br />  int number;<br />  TreeBranch(this.number);<br />  void hang(lamp) {<br />    print("  Hangs ${lamp.color} on branch #${number}.");<br />  }<br />}</pre>For now, hanging a lamp just prints to STDOUT a summary of the action.<br /><br />That pretty much does it for the pattern. Back in the <code>Tree</code> class, I modify the <code>hang_lamp()</code> method to create a <code>TreeBranch</code> on which a factory <code>Lamp</code> can be hung. I also modify the <code>report</code> getter to report on the number of flyweight objects used:<pre class=prettyprint>class Tree {<br />  int count=0;<br /><b>  var lamp_factory;<br /><br />  Tree(){ lamp_factory = new LampFactory(); }</b><br /><br />  void hang_lamp(color, branch_number) {<br /><b>    new TreeBranch(branch_number)<br />      ..hang(lamp_factory.find_lamp(color));</b><br /><br />    count++;<br />  }<br /><br /><b>  String get report => "Added ${count} lamps.\n"<br />    "Used ${lamp_factory.total_number_of_lamps_made} kinds of lamps.";</b><br />}<br /></pre>With that, I can now report:<pre class=prettyprint>Hangs red on branch #1.<br />  Hangs blue on branch #1.<br />  Hangs yellow on branch #1.<br />  Hangs red on branch #2.<br />  Hangs blue on branch #2.<br />  Hangs yellow on branch #2.<br />  Hangs red on branch #3.<br />  Hangs blue on branch #3.<br />  Hangs yellow on branch #3.<br />  Hangs red on branch #4.<br />  Hangs blue on branch #4.<br />  Hangs yellow on branch #4.<br />  Hangs red on branch #5.<br />  Hangs blue on branch #5.<br />  Hangs yellow on branch #5.<br />  Hangs red on branch #6.<br />  Hangs blue on branch #6.<br />  Hangs yellow on branch #6.<br />  Hangs red on branch #7.<br />  Hangs blue on branch #7.<br />  Hangs yellow on branch #7.<br />Added 21 lamps.<br />Used 3 kinds of lamps.</pre>That was a quick and easy implementation of the Flyweight pattern in Dart. Up tomorrow, I may explore this pattern a little more. For now, this was a good day #1!<br /><br /><br /><span style="color: #ccc">Day #1</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/11/factory-class-vs-factory-constructor-in.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/sh6Ft3CrV84" height="1" width="1" alt=""/>
