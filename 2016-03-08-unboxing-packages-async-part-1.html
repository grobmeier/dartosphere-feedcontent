---
title: 'Unboxing Packages: async Part 1'
layout: post
published: '2016-03-08T12:33:00-08:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p>Writing asynchronous code is <em>hard</em>. Even with Dart’s lovely async/await syntax, asynchrony inherently involves code running in a nondeterministic order, intermingled in a way that’s often difficult to understand and debug. Because there are so many possible ways to execute a program, and which one happens is so contingent on little details of timing, it’s not even possible to test asynchronous code in the same exhaustive way you might test something synchronous.</p> <p>This is why it’s so important to have abstractions and utilities that are simple and robust and can be used as building blocks for more complex programs. The core libraries provide the most fundamental abstractions: <a href="https://api.dartlang.org/latest/dart-async/Future-class.html"><code>Future</code></a> for an asynchronous value, and <a href="https://api.dartlang.org/latest/dart-async/Stream-class.html"><code>Stream</code></a> for an asynchronous collection or signal. But it’s up to packages to build the next layer on top of those fundamental primitives.</p> <p>The <a href="https://pub.dartlang.org/packages/async"><code>async</code> package</a> is where the next-most-basic abstractions live. It’s a <a href="http://news.dartlang.org/2016/01/unboxing-packages-collection.html">core library expansion pack</a> that contains APIs that are just a little more advanced than would fit in <code>dart:async</code> itself. The classes it exposes are well-tested and as straightforward as you can hope from asynchrony, and using them properly can make your code vastly clearer and more reliable.</p> <p>The <code>async</code> package is just chock-full of cool stuff. So full, in fact, that it won’t all fit in a single blog post—I have to split it up. Today I’ll mostly talk about APIs that deal with individual values. I’ll save <code>Stream</code>s for the next post, and I may even need a third to cover the whole package.</p> <h2 id="asyncmemoizer"><code>AsyncMemoizer</code></h2> <p>If you’re writing synchronous code and you want to provide access to a value in a class, you just define it as a field. If that value should only be computed when it’s accessed, you can <em>memoize</em> it by writing a getter that sets a field the first time it’s accessed.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="typ">String</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> contents </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">_contents </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> _contents </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">File</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">path</span><span class="pun">).</span><span class="pln">readAsStringSync</span><span class="pun">();</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> _contents</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /></span><span class="typ">String</span><span class="pln"> _contents</span><span class="pun">;</span></code></pre> <p>But what if the value can only be computed asynchronously? You still want to compute it lazily, but you don’t want to have every access recompute it from scratch. Once the computation has started, future accesses should return the same future. You can implement this manually, but it’s a pain; <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/AsyncMemoizer-class.html"><code>AsyncMemoizer</code></a> makes it easy:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="typ">Future</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> contents </span><span class="pun">=&gt;</span><span class="pln"> _contentsMemo</span><span class="pun">.</span><span class="pln">runOnce</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">File</span><span class="pun">(</span><span class="kwd">this</span><span class="pun">.</span><span class="pln">path</span><span class="pun">).</span><span class="pln">readAsString</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">});</span><span class="pln"><br /></span><span class="kwd">final</span><span class="pln"> _contentsMemo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AsyncMemoizer</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;();</span></code></pre> <p>The first time you call <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/AsyncMemoizer/runOnce.html"><code>runOnce()</code></a> on a given memoizer, it invokes the callback and returns its return value as a <code>Future</code>. After that, all calls to <code>runOnce()</code> don’t use the callback at all; they just return the same value. Make sure you always pass the same callback—otherwise you may not be able to tell which one will run!</p> <p>Some readers may be wondering why the callback isn’t passed to the constructor. After all, it’s only invoked once—future calls to <code>runOnce()</code> just throw it away! The answer is that we want code using <code>AsyncMemoizer</code> to be able to look like the snippet above, with the code the getter executes right there in the body of the getter. We also want the memoizer itself to be usable as a final variable, which means that its constructor couldn’t refer to other fields in the class (like <code>this.path</code>).</p> <p>Another common use of <code>AsyncMemoizer</code> doesn’t even use the return value of the callback. It just uses the memoizer to ensure that a method’s body is only executed once, and that it always returns the same future. Which, it turns out, is exactly how <code>close()</code> methods work for a lot of classes.</p> <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">bool</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> isClosed </span><span class="pun">=&gt;</span><span class="pln"> _closeMemo</span><span class="pun">.</span><span class="pln">hasRun</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="typ">Future</span><span class="pln"> close</span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> _closeMemo</span><span class="pun">.</span><span class="pln">runOnce</span><span class="pun">(()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  await _engine</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln"><br />  await _loader</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln"><br /></span><span class="pun">});</span><span class="pln"><br /></span><span class="kwd">final</span><span class="pln"> _closeMemo </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">AsyncMemoizer</span><span class="pun">();</span></code></pre> <p>Notice the <code>isClosed</code> getter in that example. <code>AsyncMemoizer</code> exposes a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/AsyncMemoizer/hasRun.html"><code>hasRun</code></a> property specifically to make that sort of getter possible: <code>hasRun</code> returns <code>true</code> if <code>runOnce()</code> has been called, regardless of whether the callback has completed. It also has a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/AsyncMemoizer/future.html"><code>future</code></a> property, which returns the same future as <code>runOnce()</code> without actually running the memoizer.</p>   <h2 id="result"><code>Result</code></h2> <p>When working asynchronously, values and errors are often treated as two sides of the same coin. A future completes with either a value or an error, and a stream emits value events and error events. But in the synchronous world, errors are completely different than values, and that can cause friction when moving between synchronous and asynchronous code.</p> <p>That’s what the <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result-class.html"><code>Result</code></a> class is for. Each <code>Result</code> is either a value or an error, and whichever it is is accessible synchronously. It has two subclasses, one for each state: <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ValueResult-class.html"><code>ValueResult</code></a> has a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ValueResult/value.html"><code>value</code></a> getter, and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ErrorResult-class.html"><code>ErrorResult</code></a> has a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ErrorResult/error.html"><code>error</code></a> and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ErrorResult/stackTrace.html"><code>stackTrace</code></a> getters. If you have a <code>Result</code>, you can use <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ValueResult/isValue.html"><code>isValue</code></a> and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ValueResult/isError.html"><code>isError</code></a> to easily check its type, followed by <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ValueResult/asValue.html"><code>asValue</code></a> and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async.results/ValueResult/asError.html"><code>asError</code></a> to easily cast it to the proper type.</p> <p>You can create <code>Result</code>s manually using <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/Result.value.html"><code>new Result.value()</code></a> or <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/Result.error.html"><code>new Result.error()</code></a>, but there are utility functions to convert from asynchronous objects: <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/capture.html"><code>Result.capture()</code></a> turns a <code>Future</code> into a <code>Future&lt;Result&gt;</code>, and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/captureStream.html"><code>Result.captureStream()</code></a> turns a <code>Stream</code> into a <code>Stream&lt;Result&gt;</code>. Errors that would have been emitted using the normal future or stream error channels are turned into <code>ErrorResult</code>s instead.</p> <p>You can also reverse this process using <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/release.html"><code>Result.release()</code></a> and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/releaseStream.html"><code>Result.releaseStream()</code></a>. These take a <code>Future&lt;Result&gt;</code> and a <code>Stream&lt;Result&gt;</code>, respectively, and convert <code>ErrorResult</code>s to normal error events.</p> <p><code>Result</code> has some instance methods for moving back to the async world too. The <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/asFuture.html"><code>asFuture</code></a> getter returns a future that completes to the <code>Result</code>’s value or error, and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/complete.html"><code>complete()</code></a> completes a <code>Completer</code> so that its future does the same.  For streams, you can use <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/Result/addTo.html"><code>addTo()</code></a> to add the value or the error to an <code>EventSink</code>.</p>   <h3 id="resultfuture"><code>ResultFuture</code></h3> <p>Sometimes you want limited synchronous access to a future. Maybe you want to do something with its value if it exists, but not wait for it if it doesn’t. The <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/ResultFuture-class.html"><code>ResultFuture</code></a> class makes this possible by exposing a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/ResultFuture/result.html"><code>result</code></a> getter. Before the future has completed, this is just <code>null</code>; afterwards, it’s a <code>Result</code>. Otherwise, the <code>ResultFuture</code> is just a normal future that works like futures work.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">// A Shelf handler that forwards requests to a `Future&lt;Handler&gt;`.</span><span class="pln"><br /></span><span class="kwd">class</span><span class="pln"> </span><span class="typ">AsyncHandler</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">ResultFuture</span><span class="pun">&lt;</span><span class="pln">shelf</span><span class="pun">.</span><span class="typ">Handler</span><span class="pun">&gt;</span><span class="pln"> _future</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="typ">AsyncHandler</span><span class="pun">(</span><span class="typ">Future</span><span class="pun">&lt;</span><span class="pln">shelf</span><span class="pun">.</span><span class="typ">Handler</span><span class="pun">&gt;</span><span class="pln"> future</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> _future </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ResultFuture</span><span class="pun">(</span><span class="pln">future</span><span class="pun">);</span><span class="pln"><br /><br />  call</span><span class="pun">(</span><span class="pln">shelf</span><span class="pun">.</span><span class="typ">Request</span><span class="pln"> request</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">_future</span><span class="pun">.</span><span class="pln">result </span><span class="pun">==</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />      </span><span class="kwd">return</span><span class="pln"> _future</span><span class="pun">.</span><span class="kwd">then</span><span class="pun">((</span><span class="pln">handler</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> handler</span><span class="pun">(</span><span class="pln">request</span><span class="pun">));</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="com">// Because [_future]'s a [Future], we can return it to throw error.</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">_future</span><span class="pun">.</span><span class="pln">result</span><span class="pun">.</span><span class="pln">isError</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> _future</span><span class="pun">;</span><span class="pln"><br /><br />    </span><span class="kwd">return</span><span class="pln"> _future</span><span class="pun">.</span><span class="pln">result</span><span class="pun">.</span><span class="pln">asValue</span><span class="pun">.</span><span class="pln">value</span><span class="pun">(</span><span class="pln">request</span><span class="pun">);</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h2 id="cancelableoperation"><code>CancelableOperation</code></h2> <p>One cool feature of streams in Dart is that their subscriptions can be <em>cancelled</em>. In addition to stopping any more events callbacks from firing, this indicates to the stream producer that it can stop generating events at all. Unfortunately, there’s no similar facility for futures, which is where <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableOperation-class.html"><code>CancelableOperation</code></a> comes in.</p> <p>A <code>CancelableOperation</code> represents an asynchronous operation that will ultimately produce <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableOperation/value.html">a single value</a> which is exposed as a future (and which may complete to <code>null</code>). It can also <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableOperation/cancel.html">be canceled</a>, which causes the <code>value</code> future never to complete and lets the code that created it know to stop work on the operation.</p> <p>Normally when a <code>CancelableOperation</code> is canceled, it just doesn’t complete—which is analogous to a stream subscription not emitting any events once it’s canceled. But sometimes, especially when using async/await, this isn’t what you want. In that case, you can call <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableOperation/valueOrCancellation.html"><code>valueOrCancellation()</code></a>, which returns a future that completes even if the operation was canceled. By default it completes to <code>null</code>, but you can pass in a custom value if you want.</p> <p>There are two ways to create a <code>CancelableOperation</code>. If you already have a value future and you just want to wrap it, you can call <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableOperation/CancelableOperation.fromFuture.html"><code>new CancelableOperation.fromFuture()</code></a>. This also takes an <code>onCancel</code> callback that is called if the operation is canceled.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="typ">CancelableOperation</span><span class="pln"> runSuite</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> path</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> suite</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> canceled </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">CancelableOperation</span><span class="pun">(()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />    suite </span><span class="pun">=</span><span class="pln"> await loadSuite</span><span class="pun">(</span><span class="pln">path</span><span class="pun">);</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">canceled</span><span class="pun">)</span><span class="pln"> </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">;</span><span class="pln"><br /><br />    </span><span class="kwd">return</span><span class="pln"> suite</span><span class="pun">.</span><span class="pln">run</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">}(),</span><span class="pln"> onCancel</span><span class="pun">:</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    canceled </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">true</span><span class="pun">;</span><span class="pln"><br />    </span><span class="kwd">return</span><span class="pln"> suite</span><span class="pun">?.</span><span class="pln">close</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>If the <code>onCancel</code> callback returns a <code>Future</code>, it will be forwarded to the return value for the call to <code>cancel()</code>. This is just like how cancelling a <code>StreamSubscription</code> works, except that for consistency <code>CancelableOperation.cancel()</code> never returns <code>null</code>.</p> <p>You can also create a <code>CancelableOperation</code> using a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableCompleter-class.html"><code>CancelableCompleter</code></a>. This works a lot like a <code>Completer</code> for a future: it has <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableCompleter/complete.html"><code>complete()</code></a> and <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableCompleter/completeError.html"><code>completeError()</code></a> methods, and it exposes the operation it controls through the <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableCompleter/operation.html"><code>operation</code></a> getter. But <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableCompleter/CancelableCompleter.html">its constructor</a> takes an <code>onCancel</code> callback that’s called if the operation is canceled, and it has an <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/CancelableCompleter/isCanceled.html"><code>isCanceled</code></a> getter.</p> <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Like [Stream.first], but cancelable.</span><span class="pln"><br /></span><span class="typ">CancelableOperation</span><span class="pln"> cancelableFirst</span><span class="pun">(</span><span class="typ">Stream</span><span class="pln"> stream</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> subscription</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> completer </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">CancelableCompleter</span><span class="pun">(</span><span class="pln"><br />    onCancel</span><span class="pun">:</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> subscription</span><span class="pun">.</span><span class="pln">cancel</span><span class="pun">());</span><span class="pln"><br /><br />  subscription </span><span class="pun">=</span><span class="pln"> stream</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">((</span><span class="pln">value</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    completer</span><span class="pun">.</span><span class="pln">complete</span><span class="pun">(</span><span class="pln">value</span><span class="pun">);</span><span class="pln"><br />    subscription</span><span class="pun">.</span><span class="pln">cancel</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">},</span><span class="pln"> onError</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln">error</span><span class="pun">,</span><span class="pln"> stackTrace</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    completer</span><span class="pun">.</span><span class="pln">completeError</span><span class="pun">(</span><span class="pln">error</span><span class="pun">,</span><span class="pln"> stackTrace</span><span class="pun">);</span><span class="pln"><br />    subscription</span><span class="pun">.</span><span class="pln">cancel</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br /><br />  </span><span class="kwd">return</span><span class="pln"> completer</span><span class="pun">.</span><span class="pln">operation</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <h2 id="futuregroup"><code>FutureGroup</code></h2> <p>Fun fact: at least three different versions of the <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/FutureGroup-class.html"><code>FutureGroup</code></a> class existed across the Dart world before a canonical implementation finally ended up in the <code>async</code> package. That’s a pretty good indication that it’s a broadly-applicable abstraction!</p> <p>A <code>FutureGroup</code> collects a bunch of input futures and exposes a single output future that completes when all the inputs have completed. Inputs are added using <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/FutureGroup/add.html"><code>add()</code></a>, and the output is called <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/FutureGroup/future.html"><code>future</code></a>.</p> <p>Once you’ve added all the futures you want to the group, call <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/FutureGroup/close.html"><code>close()</code></a> to tell it that no more are coming. Some astute students of the core libraries will recognize the pattern of <code>add()</code> followed by <code>close()</code> as the hallmark of a sink—and indeed, <code>FutureGroup</code> implements <a href="https://api.dartlang.org/1.14.2/dart-core/Sink-class.html"><code>Sink</code></a>.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">// An engine for running tests.</span><span class="pln"><br /></span><span class="kwd">class</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> _group </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">FutureGroup</span><span class="pun">();</span><span class="pln"><br /><br />  </span><span class="com">// Completes when all tests are done.</span><span class="pln"><br />  </span><span class="typ">Future</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> onDone </span><span class="pun">=&gt;</span><span class="pln"> _group</span><span class="pun">.</span><span class="pln">future</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="kwd">void</span><span class="pln"> addTest</span><span class="pun">(</span><span class="typ">Test</span><span class="pln"> test</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    _group</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">test</span><span class="pun">.</span><span class="pln">run</span><span class="pun">());</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /><br />  </span><span class="kwd">void</span><span class="pln"> noMoreTests</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    _group</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>If all the futures that have been added to a <code>FutureGroup</code> have completed but it hasn’t been closed, we say that the group is <em>idle</em>. You can tell whether a group is idle using the <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/FutureGroup/isIdle.html"><code>isIdle</code></a> getter. You can also use the <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/FutureGroup/onIdle.html"><code>onIdle</code></a> stream to get an event whenever the group becomes idle—that is, whenever the last running future completes.</p> <h2 id="iscompleted"><code>!isCompleted</code></h2> <p>I hope I’ve whet your appetite for asynchrony, because there’s plenty more to come. Working with individual values is useful, but the bulk of the package—and, in my opinion, some of the coolest stuff it contains—has to do with streams. Check back in two weeks, when I tell you all about it!</p>
