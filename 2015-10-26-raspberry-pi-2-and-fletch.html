---
title: 'Raspberry Pi 2 and Fletch'
layout: post
published: '2015-10-26T03:13:50+00:00'
feed: 'Dart – Matt''s Blog'
link: 'http://blog.butlermatt.me/2015/10/raspberry-pi-2-and-fletch/'
author:
    name: 'Matthew Butler'
    email: null
    url: null
tags:
    - Dart
    - Fletch
    - 'Raspberry Pi 2'

---

<p><img class="aligncenter size-full wp-image-257" src="http://blog.butlermatt.me/wp-content/uploads/2015/10/IMG_20151023_161803408.jpg" alt="IMG_20151023_161803408" width="600" height="337" /></p>
<p>So I received my Raspberry Pi (2) on Friday evening. I spent the evenings this weekend playing with it. The Raspberry Pi&#8217;s are nothing new, and I&#8217;m admittedly late to the game here. While I&#8217;ve been interested, I didn&#8217;t have the money or time to invest into one before. There just wasn&#8217;t a factor to say &#8220;Hey look at me!&#8221; for it. However with my new position with DG Logik, working with IoT, it becomes more interesting subject for me to look into. And recently, the Dart team at Google started a side project called Fletch, which is designed not just to run on this, but eventually on a plethora of embedded, IoT devices. I missed my chance to be part of the first users of the Raspberry Pi and making &#8220;oh cool look!&#8221; projects. And honestly, it probably wouldn&#8217;t have been the right time for me to do so, as my limited knowledge with electronics would have kept me to more the OS level anyways.</p>
<p>But now with Fletch, I get to be one of the first users of Dart in this capacity on the Raspberry Pi. It is true, you can compile the Dart VM, SDK to ARM7 and run the full VM on the OS anyways. And I will do so too no doubt. But Fletch starts with the idea of getting right to the hardware level. It currently comes with packages all set for accessing the GPIO pins on the board, plus some gentle changes to how the VM runs.</p>
<p>The biggest change they made changes the VM to be two different parts. The first is a compiler. Dart compiles to bytecode. This bytecode is then sent over the wire to a smaller VM running on your Pi which executes it and returns any output back over the wire. Additionally, they made the decision to allow Dart to be blocking, but at the same time does not hog the CPU. If the VM is blocking on some operation, it can actually hand control back to the CPU until its done. This will be much more important when it comes to running on smaller devices in the future and makes for simpler programming for those devices, more akin to how they may be written now in Python (for the Pi) or C.</p>
<p>But <strong>please</strong> don&#8217;t take my word for it, as I&#8217;m sure I&#8217;ll mess up some of the finer details. Please check out the <a href="http://dart-lang.github.io/fletch/" target="_blank">Fletch Homepage</a> and get the details directly (who am I fooling, if you&#8217;re reading my blog, you&#8217;ve already checked out the page long before now).</p>
<p>The Fletch page has some nice <a href="http://dart-lang.github.io/fletch/samples.html">samples</a> to check out as well. I recommend doing the first couple verbatim, especially if you&#8217;ve not used electronics a lot yourself in the past. However after that I recommend that you actually start writing your own source copying the existing source and making alterations where you need to, this will generally be things like specifying different GPIO pins to work easier with what you have hardwired. I actually ran into issues with the second project due to a hardware issue which is known to happen. Basically there was feedback too close to the GPIO pin I was using, and it caused the pin to be in a state called &#8220;floating&#8221;. Where the input thought there was input based on background nose, and not actual value flowing into the pin (in fact it was totally disconnected from any wiring at all and still showed the same).</p>
<p>There are ways to resolve a floating value with both hardware, and internally. It&#8217;s called <a href="http://playground.arduino.cc/CommonTopics/PullUpDownResistor">a pull up resistor, or a pull down resistor</a>. One configuration will set the default value to &#8216;on&#8217; and the other will set it to &#8216;off&#8217;. Because they&#8217;re so frequently used, particularly when using switches/buttons, each GPIO on the Raspberry Pi has it built in. In the Python libraries that comes with the Pi, it&#8217;s possible to set this value when setting up the GPIO pin for use. However, currently this same functionality is missing from the Fletch packages. <a href="https://github.com/dart-lang/fletch/issues/255">I&#8217;ve filed a bug</a>. Fortunately I was able to overcome that issue by using a different GPIO pin in the end, as well as using a GPIO Extension Board. (Not all extension boards are created equally. I have two, one from Sunfounder and one from Vilros, and the Vilros one I have is a much nicer extension board in layout.</p>
<p>That&#8217;s, however, not the only issue I&#8217;ve run into with Fletch at this point. The other main one, would be documentation. The API is fairly similar to Dart in most cases. However, particularly with the built in packages, there is no API documentation. The few times I&#8217;ve wanted to look up a method/function, it involved manually digging through the repository and trying to find the right package a method came from and hope there are doc comments there. For instance, what does <a href="https://github.com/dart-lang/fletch/blob/master/pkg/gpio/lib/gpio.dart#L289">SysfsGPIO.waitFor</a> actually take for arguments (what&#8217;s the true and -1 from the samples?). Oh.</p>
<p>There&#8217;s a lot more I&#8217;d like to broach on the Raspberry Pi, and my experiences. But it&#8217;s getting late and I have a busy day tomorrow. More on it soon. It&#8217;s fun!</p>

