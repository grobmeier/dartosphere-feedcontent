---
title: 'The Bridge Pattern in Dart'
layout: post
published: '2016-01-25T22:46:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/wPLuIcyFmgo/the-bridge-pattern-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />The <a href="">bridge pattern</a> definition sounds like little more than a jargon generator seeded with object-oriented terms. From the  <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>, the intent is to:<blockquote>Decouple an abstraction from its implementation so that the two can vary independently.</blockquote>Some day I hope to be able to reduce computer science-y terms with such whimsy. Until then, I'll settle for attempting to implement the pattern in <a href="http://dartlang.org">Dart</a>.<br /><br />For my first pass, I borrow the Java implementation from the Wikipedia article. It is a nice example in which the abstraction is a shape and the implementation is a drawing API. Part of the abstraction's job is to maintain a reference to the implementation, so I start with the latter.<br /><br />The implementor is <code>DrawingApi</code>:<pre class=prettyprint>abstract class DrawingApi {<br />  void drawCircle(double x, double y, double radius);<br />}</pre>Obviously, what will vary between concrete implementors is that <code>drawCircle()</code> method. In this very simple string-based example, the only thing that changes is the first part of the string printed by <code>drawCircle()</code>:<pre class=prettyprint>class DrawingApi1 implements DrawingApi {<br />  void drawCircle(double x, double y, double radius) {<br />    print(<br />      "[DrawingApi1] "<br />      "circle at ($x, $y) with "<br />      "radius ${radius.toStringAsFixed(3)}"<br />    );<br />  }<br />}<br /><br />class DrawingApi2 implements DrawingApi {<br />  void drawCircle(double x, double y, double radius) {<br />    print(<br />      "[DrawingApi2] "<br />      "circle at ($x, $y) with "<br />      "radius ${radius.toStringAsFixed(3)}"<br />    );<br />  }<br />}<br /></pre>With that out of the way, it is time to check out the abstraction. Again, the abstraction maintains a reference to an implementor. It also defines the public-facing interface:<pre class=prettyprint>abstract class Shape {<br />  DrawingApi _drawingApi;<br /><br />  Shape(this._drawingApi);<br /><br />  void draw();                         // low-level<br />  void resizeByPercentage(double pct); // high-level<br />}</pre>What I appreciate about this example is that it identifies where changes will occur. Implementator changes are low-level changes such as variations in the  <code>DrawingApi</code>. Abstraction variations are considered "high-level" such as resizing the shape.<br /><br />The refined abstraction for <code>Shape</code> is a <code>Circle</code>. It needs to store properties for a circle and supply the implementor to the <code>Shape</code> superclass:<pre class=prettyprint>class Circle extends Shape {<br />  double _x, _y, _radius;<br />  Circle(this._x, this._y, this._radius, DrawingApi api) :<br />    super(api);<br />  // ...<br />}</pre>The private instance variables are assigned with Dart's wonderful <code>this</code> constructor shorthand. I curse at any language that does not support this. The <code>DrawingApi</code> is assigned via a redirection to the superclass' constructor. That is nice &amp; clean and could be a one-liner if I did not abhor long lines.<br /><br />The low-level <code>draw()</code> method delegates to the supplied implementor:<pre class=prettyprint>class Circle extends Shape {<br />  // ...<br />  void draw() {<br />    _drawingApi.drawCircle(_x, _y, _radius);<br />  }<br />  // ...<br />}</pre>As long as the implementor continues to support that <code>DrawingApi</code> interface, it can change as much as it likes. As for the high-level, abstraction specific resize method, it simply multiplies the radius by a percentage:<pre class=prettyprint>class Circle extends Shape {<br />  // ...<br />  void resizeByPercentage(double pct) {<br />    _radius *= (1.0 + pct/100.0);<br />  }<br />}</pre>And that is the pattern. If I had to change the implementation details of the resize function, I could do so with no fear of breaking the low-level implementor. The same goes for the implementorâ€”if I need to change how drawing works or add another type of implementor, I can do so without affecting the abstraction.<br /><br />Client code can create a 2 shape list, each with a different drawing implementor. I can then loop over each to resize and draw:<pre class=prettyprint>main() {<br />  List<shape> shapes = [<br />    new Circle(1.0, 2.0, 3.0, new DrawingApi1()),<br />    new Circle(5.0, 7.0, 11.0, new DrawingApi2())<br />  ];<br /><br />  shapes.forEach((shape){<br />    shape.resizeByPercentage(2.5);<br />    shape.draw();<br />  });<br />}</pre>This results in:<pre class=prettyprint>$ ./bin/draw.dart           <br />[DrawingApi1] circle at (1.0, 2.0) with radius 3.075<br />[DrawingApi2] circle at (5.0, 7.0) with radius 11.275</pre>Nice! There is still much to explore in this pattern, but that is a nice start.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/2b092185cb17ebebecef">https://dartpad.dartlang.org/2b092185cb17ebebecef</a>.</i><br /><br /><br /><span style="color: #ccc">Day #75</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/is-it-real-proxy-pattern-without-types.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/degenerate-bridges.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/wPLuIcyFmgo" height="1" width="1" alt=""/>
