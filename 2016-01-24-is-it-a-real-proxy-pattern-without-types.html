---
title: 'Is It a Real Proxy Pattern Without Types?'
layout: post
published: '2016-01-24T22:13:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/lBrvpLNP1js/is-it-real-proxy-pattern-without-types.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />It turns out that I may be too rigid at times with my types in <a href="http://dartlang.org">Dart</a>. That's just insane. Me. An old Perler, an ancient Rubyist, and old-timey JavaScripter, someone who fled Java because of the type craziness — using types too darn often. What a world.<br /><br />When I first explored protection <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy patterns</a> I almost headed down the path of generic proxies, but decided against it because... types. The particular example that I was using to explore protection proxies probably influence me to a fair extent. I was using a <code>Driver</code> to determine if a particular driver instance was old enough to legally start a <code>Car</code>. I opted against a generic proxy class (probably rightly) since a proxy class protecting against drivers was certain to be an automobile of some kind. Following from there, if the proxy class always worked with automobiles, it might as well implement the <code>Automobile</code> interface.<br /><br />That suited me just fine because it kept me on the happy <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four</a> path. All of my proxy pattern explorations followed the same patterns as in the original book: a subject (the interface), a real subject (e.g. a <code>Car</code>) and a proxy (e.g. <code>RemoteCar</code>). But in Gilad Bracha's <a href="http://www.pearsonhighered.com/educator/product/Dart-Programming-Language-The/9780321927705.page">The Dart Programming Language</a>, it struck me reading that, not only was it OK to use a generic proxy, but that "being able to define transparent proxies for any sort of object is an important property."<br /><br />So, I go back to my protection proxy example to see how it will work with a proxy that will work with any kind of object. In addition the object serving as the real subject of my protection proxy, I also need a driver instance through which access will be allowed or denied:<pre class=prettyprint>class ProxyProtect {<br />  final Driver _driver;<br />  final _realSubject;<br /><br />  ProxyProtect(this._driver, this._realSubject);<br />  // ...<br />}</pre>As a quick aside, I must point out that I really enjoy Gilad's book. It is wonderful getting insights into the language from one of the primary designers. The little notes about things like variables almost almost always being used in a <code>final</code> way are wonderful. I will make a concerted effort to use <code>final</code> in most of my real code. I likely won't use it teaching for the same reason that it is not the default in the language—it is not expected by most developers. Anyhow...<br /><br />I have my <code>ProxyProtext</code> constructor, now I need the calls to the real subject. I continue to use <code>noSuchMethod()</code> for this:<pre class=prettyprint>import 'dart:mirrors' show reflect;<br /><br />@proxy class ProxyProtect {<br />  // ...<br />  dynamic noSuchMethod(i) {<br />    if (_driver.age <= 16)<br />      throw new IllegalDriverException(_driver, "too young");<br /><br />    return reflect(_realSubject).delegate(i);<br />  }<br />}</pre>If no other methods are defined, then Dart will invoke <code>noSuchMethod()</code> with information about the method being invoked. With that, no matter what method is invoked, I first check the driver. If the driver is too young, an exception is thrown and nothing else occurs. The real subject is protected against illegal actions. If the driver is of age, then it is time for mirrors—the kind that allow dynamic calls and inspection. In this case, I get a mirror of the real subject with <code>reflect()</code>, then delegate whatever was invoked to the real subject with <code>delegate()</code>.  <p>Easy peasy. Now I have a <code>ProxyProtect</code> for any object that might have a driver: a car, an R/C toy, a train, as spaceship, etc. If I create a car and an of-age driver in client code, I can drive the car:</p><pre class=prettyprint><code>  var _car = new Car(),<br />      _driver = new Driver(25);<br />  print("* $_driver here:");<br /><br />  var car = new ProxyProtect(_driver, _car);<br />  car.drive();</code></pre>When run, this results in:<pre class=prettyprint>$ ./bin/drive.dart<br />* 25 year-old driver here:<br />Car has been driven!</pre>If an underage drive attempts to pilot the vehicle:<pre class=prettyprint><code>  var _car = new Car(),<br />      _driver = new Driver(16);<br />  print("* $_driver here:");<br /><br />  var car = new ProxyProtect(_driver, _car);<br />  car.drive();</code></pre>Then this results in:<pre class=prettyprint>$ ./bin/drive.dart<br />* 16 year-old driver here:<br />Unhandled exception:<br />IllegalDriverException: 16 year-old driver is too young!</pre>As I found out last night, I am not quite done here. When I run the code through the Dart static type analyzer, I find that my protection proxy does not seem to fit the correct types. Specifically, a <code>drive()</code> method is being invoked when one is not declared <i>and</i> the class does not explicitly specify an interface that it is implementing:<pre class=prettyprint>[hint] The method 'drive' is not defined for the class 'ProxyProtect' (/home/chris/repos/design-patterns-in-dart/proxy/bin/drive.dart, line 19, col 7)</pre>To address this, I use the built-in <code>@proxy</code> annotation, which tells the analyzer to give my proxy class a pass:<pre class=prettyprint>@proxy class ProxyProtect {<br />  // ...<br />}</pre>With that, I have a working protection proxy for any sort of object... and it passes static type analysis. Nothing too surprising here, though I do have figure out how and if to work this into the discussion of the pattern in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. For now, I think I may be done with my exploration of the proxy pattern—it was a fun one!    <i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/6d8f76cab3f9d1bb97ff">https://dartpad.dartlang.org/6d8f76cab3f9d1bb97ff</a>.</i>     <span style="color: #ccc">Day #74</span>    <p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/a-closer-look-at-proxy-annotation-in.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/the-bridge-pattern-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/lBrvpLNP1js" height="1" width="1" alt=""/>
