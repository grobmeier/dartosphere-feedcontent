---
title: 'Subclass Just to Support One Method?'
layout: post
published: '2015-12-25T22:22:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/4OR6e4vhfLU/subclass-just-to-support-one-method.html'
author:
    name: Anonymous
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/00135361916531185929'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'
    - mirrors

---

<div class=top-chain-links></div><br />I kinda like <a href="http://dartlang.org">Dart</a> mirrors. <br /><br />As a long time dynamic language programmer, I didn't think that I would, but it can be quite pleasant. Other times, however...<br /><br />In the code from last night's video, the <code>call()</code> method in the <code>SimpleCommand</code> class is nice:<pre class=prettyprint>import 'dart:mirrors';<br /><br />class SimpleCommand&lt;T> implements Command {<br />  T receiver;<br />  Symbol action;<br />  List args=[];<br />  SimpleCommand(this.receiver, this.action, [this.args]);<br />  void call() {<br />    reflect(receiver).invoke(action, this.args);<br />  }<br />}</pre>This reflects on the object, then invokes a method with arguments. What could be easier or cleaner? <br /><br />What I do not like is what I did with the <code>History</code> class, which holds a list of undoable commands in an application. The guard clause at the beginning of the <code>add()</code> method is too long and obtuse:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(Function c) {<br />    if (!reflect(c).type.instanceMembers.containsKey(#undo)) return;<br /><br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>What that line does is return when the command does not support an <code>undo()</code> method. That is, commands that cannot undo should not be added to this history list. It works, but...<br /><br />I cannot work directly with the object mirror—there is no way for the object mirror in Dart to reflect on its methods or properties. So instead, I have to get a class mirror from the object mirror's <code>type</code> property. Then, I get a map of the supported methods with <code>instanceMembers</code>. Finally, I can ask if the list of instance members (methods) includes the <code>undo()</code> by asking if the map contains the <code>#undo</code> symbol. But I do not want to know if it contains the key—I want to know if it does <i>not</i> contain the key—so I have to go all the way back to the beginning of the expression to negate it. <br /><br />I might simplify slightly by breaking parts out into helper methods or switching from a returning, negated guard clause to a curly-brace enclosing expression. Neither of those options really helps cut through the dense, hard-to-read code. I breezed through this implementation last night in the hopes that something better would appear today. Sadly, I cannot find anything in Dart mirrors that can make this any better. <br /><br />I could switch my undoable command classes to support a different interface—<code>UndoableCommand</code> instead of <code>Command</code>:<pre class=prettyprint>abstract class Command implements Function {<br />  void call();<br />}<br /><br />abstract class UndoableCommand implements Command {<br />  void call();<br />  void undo();<br />}</pre>Then commands that support undo, like move-north, can implement this new interface:<pre class=prettyprint>class MoveNorthCommand implements UndoableCommand {<br />  Robot robot;<br />  MoveNorthCommand(this.robot);<br />  void call() { robot.move(Direction.NORTH); }<br />  void undo() { robot.move(Direction.SOUTH); }<br />}</pre>Making use of that, my guard clause is <i>much</i> clearer:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(Function c) {<br />    if (c is! UndoableCommand) return;<br /><br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>That is much clearer than my mirror based approach. But I hate it.<br /><br />It seems crazy to declare a class whose sole purpose is to describe that it supports a single method. Why not just ask it if it supports the method?<br /><br />In the end, it is a good thing I punted this question until today. I finished the video and this certainly would have side-tracked me. I remain unsure what I would do if presented with this in live code. From a code maintainability perspective, I prefer the mirror approach (I'd likely put the obtuse path to the answer into a helper method). From a performance perspective, I would likely favor the subclass-just-to-support-one-method approach, avoiding mirrors. So it depends.<br /><br />And last night's quick and dirty solution just might end up being my real solution in many instances.<br /><br /><br /><i>Maybe you can come up with a better approach on DartPad! <a href="https://dartpad.dartlang.org/78fca73a983abe26476c">https://dartpad.dartlang.org/78fca73a983abe26476c</a></i><br /><br /><br /><span style="color: #ccc">Day #44</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/video-different-kinds-of-commands-in.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/typedef-and-dart-command-pattern.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/4OR6e4vhfLU" height="1" width="1" alt=""/>
