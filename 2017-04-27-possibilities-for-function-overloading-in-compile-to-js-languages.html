---
title: 'Possibilities for function overloading in compile-to-JS languages'
layout: post
published: '2017-04-27T17:03:27+00:00'
feed: 'Stories by Matan Lurey on Medium'
link: 'https://medium.com/@matanlurey/possibilities-for-function-overloading-in-compile-to-js-languages-bee87e97c161?source=rss-abdbfcd4679f------2'
author:
    name: 'Matan Lurey'
    email: null
    url: null
tags:
    - javascript
    - dartlang
    - typescript
    - programming

---

<p>We’re constantly talking on the Dart team about how to improve the language (<a href="https://groups.google.com/a/dartlang.org/d/msg/core-dev/nibahmEeiXE/oUzbg-H0BAAJ">like non-nullable types</a>), and one of the features that has come up informally a few times is <a href="https://en.wikipedia.org/wiki/Function_overloading">function overloading</a>:</p><blockquote>In some programming languages, function overloading or method overloading is the ability to create multiple methods of the same name with different implementations. Calls to an overloaded function will run a specific implementation of that function appropriate to the context of the call, allowing one function call to perform different tasks depending on context.</blockquote><figure><img alt="" src="https://cdn-images-1.medium.com/max/813/1*EANgU23Sdyk84Z4PjjAfRg.gif" /></figure><p>In short, this means you can write code like this (here’s a Java example):</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/c96e739afd8ebf9f4863873af56e318b/href">https://medium.com/media/c96e739afd8ebf9f4863873af56e318b/href</a></iframe><blockquote><strong>A quick note</strong>: This is not an official stance of either Dart or Google, and also is not meant to be seen as a negative portrayal of TypeScript, but rather just a comparison of various benefits (and deficiencies) of both languages — for example TypeScript supports union types today and Dart does not.</blockquote><p>We can’t do this (yet) in Dart, (or JavaScript, or TypeScript) but you can do:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b4b0a95be0a294571401a43db767a81c/href">https://medium.com/media/b4b0a95be0a294571401a43db767a81c/href</a></iframe><p>Of course, this isn’t very ergonomic. We could also <em>omit</em> the type definition entirely, and rely on a runtime check (in Dart) or use a union type (in TypeScript):</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f7e70105fa41284363921c7ab27ea02d/href">https://medium.com/media/f7e70105fa41284363921c7ab27ea02d/href</a></iframe><p>Note that in both cases I needed to do additional runtime type-checks to know how to dispatch <em>something</em> to the appropriate code block. I didn’t have to do that in Java.</p><p>You might want to ask — what’s wrong with that? Well, nothing is <em>wrong</em> — but certainly you can see problems with both implementations, at least compared with Java and other languages:</p><ol><li>In both TypeScript and Dart there are no language-level runtime checks — you have to manually assert that an unexpected type was provided. This has to be maintained as you change the type hierarchy.</li><li>In both TypeScript and Dart there is runtime performance overhead — imagine calling <em>consume</em> in a tight-loop hundreds or thousands of time — the compiler.</li><li>In TypeScript there is <em>code size</em> overhead — even if you only drink water, and never eat food you’ll still compile and ship the error case and water case to production (this isn’t the case in Dart, see below).</li><li>In Dart, there are no static checks when you provide incorrect types. The type is implicitly <em>dynamic </em>(<em>any</em> in TypeScript), which is not the experience most users are used to with strongly-typed Dart APIs.</li><li>In TypeScript, static checks are limited to <em>structural, </em>not nominal, types. Which means this is <em>totally </em>legal, and will not produce any static errors:</li></ol><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/257ef2fe77bf3e1fb221a17645a78ad8/href">https://medium.com/media/257ef2fe77bf3e1fb221a17645a78ad8/href</a></iframe><h3>Tree-shaking partially to the rescue</h3><p>As noted above, Dart does not have method overloads — yet — but does have pretty powerful tree-shaking. For example, assume the following (now familiar) Dart program:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/ed072dd0435e576a63909b9f790ec366/href">https://medium.com/media/ed072dd0435e576a63909b9f790ec366/href</a></iframe><p>Can you guess what JavaScript code this compiles to?</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/85a50bbef55c019bc7d1f2bdaec74742/href">https://medium.com/media/85a50bbef55c019bc7d1f2bdaec74742/href</a></iframe><p>That’s right — dart2js has optimized it down to a single print statement. You can learn more about the advanced optimizations dart2js does in this Dart developer summit talk from a past year:</p><iframe src="https://cdn.embedly.com/widgets/media.html?src=https%3A%2F%2Fwww.youtube.com%2Fembed%2FxneWkyKLuk0%3Ffeature%3Doembed&amp;url=http%3A%2F%2Fwww.youtube.com%2Fwatch%3Fv%3DxneWkyKLuk0&amp;image=https%3A%2F%2Fi.ytimg.com%2Fvi%2FxneWkyKLuk0%2Fhqdefault.jpg&amp;key=d04bfffea46d4aeda930ec88cc64b87c&amp;type=text%2Fhtml&amp;schema=youtube" width="854" height="480" frameborder="0" scrolling="no"><a href="https://medium.com/media/f3c5785e6a1c239a3dcd6133be2ed335/href">https://medium.com/media/f3c5785e6a1c239a3dcd6133be2ed335/href</a></iframe><h3>OK, but what about overloading?</h3><p>Dart, unlike TypeScript, uses a <a href="https://en.wikipedia.org/wiki/Nominal_type_system"><em>nominal type system</em></a><em>, </em>not a <a href="https://en.wikipedia.org/wiki/Structural_type_system"><em>structural type system</em></a>. It’s possible with our new <em>sound type system</em> to <em>prove</em> what the incoming type of something is, and we could statically dispatch it. Imagine this compiled JavaScript (not yet supported):</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/bdef7f604d3e5b1aeaddf69708b35bc5/href">https://medium.com/media/bdef7f604d3e5b1aeaddf69708b35bc5/href</a></iframe><p>If this is something you’d like to see in Dart please feel free to comment here or on GitHub so we can help prioritize. I hope you enjoyed this short blog!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=bee87e97c161" width="1" height="1">
