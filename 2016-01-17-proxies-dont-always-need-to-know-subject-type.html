---
title: 'Proxies Don''t Always Need to Know Subject Type'
layout: post
published: '2016-01-17T21:00:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/14d-gqyiVgQ/proxies-dont-always-need-to-know.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />Up today, I explore types when implementing the <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> in <a href="http://dartlang.org">Dart</a>. The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> states that proxies do not necessarily need to know the type of the real subject. This seems reasonable to me, but I prefer to at least run the theory through somewhat practical application to see if I am overlooking something.<br /><br />For the proxy class to not know the type of its real subject, the real subject must be created outside of the proxy and then supplied to the constructor. For the car example that I had been using previously, the client code for this might look something like:<pre class=prettyprint><code>  Automobile realCar =  new Car();<br />  Automobile proxy = new ProxyAutomobile(realCar);<br />  proxy.drive();</code></pre>The proxy class does not need to know the specific class, but it needs to have an interface that is being implemented—the proxy class needs to know that the interface supports a common set of actions.<br /><br />The subject in this pattern remains the <code>Automobile</code> interface, which declares that all implementations must support the <code>drive()</code> method:<pre class=prettyprint>// Subject<br />abstract class Automobile {<br />  void drive();<br />}</pre>Next, I declare three different real subjects that will be used by the proxy class:<pre class=prettyprint>// Real Subjects<br />class Car implements Automobile {<br />  void drive() {<br />    print("Car has been driven!");<br />  }<br />}<br /><br />class Truck implements Automobile {<br />  void drive() {<br />    print("Truck has been driven!");<br />  }<br />}<br /><br />class Motorcycle implements Automobile {<br />  void drive() {<br />    print("Motorcycle has been driven!");<br />  }<br />}</pre>The proxy class is still a protection proxy from the other night, so it requires both a type of <code>Automobile</code> and a <code>Driver</code> when constructed:<pre class=prettyprint>// Proxy Subject<br />class ProxyAutomobile implements Automobile {<br />  Driver _driver;<br />  Automobile _auto;<br /><br />  ProxyAutomobile(this._auto, this._driver);<br />  // ...<br />}</pre>As for the <code>drive()</code> method itself, it needs to first verify that the driver is legal, then will invoke the <code>drive()</code> method on the real subject:<pre class=prettyprint>class ProxyAutomobile implements Automobile {<br />  // ...<br />  void drive() {<br />    if (_driver.age <= 16)<br />      throw new IllegalDriverException(_driver, "too young");<br /><br />    _auto.drive();<br />  }<br />}</pre>And that works exactly as expected. A driver that is of age can drive any of these automobiles through the proxy class:<pre class=prettyprint><code>  // Proxy will allow access to real subject<br />  driver = new Driver(25);<br />  print("== $driver here:");<br />  new ProxyAutomobile(new Car(),        driver)..drive();<br />  new ProxyAutomobile(new Truck(),      driver)..drive();<br />  new ProxyAutomobile(new Motorcycle(), driver)..drive();</code></pre>The output of that code confirms that the 25 year-old driver can driver each of these:<pre class=prettyprint>$ ./bin/drive.dart<br />== 25 year-old driver here:<br />Car has been driven!<br />Truck has been driven!<br />Motorcycle has been driven!</pre>And a 16 year-old driver results in an illegal driver exception:<pre class=prettyprint><code>  driver = new Driver(16);<br />  print("== $driver here:");<br />  new ProxyAutomobile(new Car(), new Driver(16))..drive();<br />  // => == 16 year-old driver here:<br />  //    Unhandled exception:<br />  //    IllegalDriverException: 16 year-old driver is too young!</code></pre>I mentioned earlier that when the proxy does not know the real subject's type ahead of time, then client code needs to supply the real subject. That is not strictly necessary because... mirrors! Instead of supplying the real subject, the client code can supply the type, or even a symbol representation of the type:<pre class=prettyprint><code>  new ProxyAutomobile(#Car,        driver)..drive();<br />  new ProxyAutomobile(#Truck,      driver)..drive();<br />  new ProxyAutomobile(#Motorcycle, driver)..drive();</code></pre>The proxy class can then use this to create a real subject:<pre class=prettyprint>class ProxyAutomobile implements Automobile {<br />  Driver _driver;<br />  Symbol _autoType;<br /><br />  ProxyAutomobile(this._autoType, this._driver);<br /><br />  Automobile get auto => _autoMirror.reflectee;<br /><br />  InstanceMirror get _autoMirror =><br />    _classMirror.newInstance(new Symbol(''), []);<br /><br />  ClassMirror get _classMirror =><br />    currentMirrorSystem().<br />      findLibrary(#car).<br />      declarations[_autoType];<br /><br />  void drive() {<br />    if (_driver.age <= 16)<br />      throw new IllegalDriverException(_driver, "too young");<br /><br />    auto.drive();<br />  }<br />}</pre>Sure that's some gnarly <code>ClassMirror</code> → <code>InstanceMirrror</code> → <code>reflectee</code> code, but it is possible. And some of us really enjoy mirrors for some reason.  <p>I am more or less done with the proxy pattern in Dart now. I may have another go at remote proxies because I was never quite satisfied with my previous efforts. The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> also mentions <a href="https://en.wikipedia.org/wiki/Smart_pointer">smart references</a> as a possible application of the pattern. I am hard pressed to come up with an illustrative example in a garbage collected language. Regardless, the proxy pattern with unknown types works well.</p><p><i>Play with the (pre-mirror) code on DartPad: <a href="https://dartpad.dartlang.org/6a163b3c6708564bb13b">https://dartpad.dartlang.org/6a163b3c6708564bb13b</a>.</i></p><p><span style="color: #ccc">Day #67</span>  </p><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/a-real-virtual-proxy-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/a-naming-convention-for-dart-isolate.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/14d-gqyiVgQ" height="1" width="1" alt=""/>
