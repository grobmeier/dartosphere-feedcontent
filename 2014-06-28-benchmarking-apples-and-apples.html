---
title: 'Benchmarking Apples and Apples'
layout: post
published: '2014-06-28T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Nh5RvuI4iKU/benchmarking-apples-and-apples.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />I left off yesterday with some initial benchmarks for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. The <a href="https://github.com/dart-lang/benchmark_harness">benchmark_harness</a> makes that pretty darn easy. What I found was that one of my <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> pattern implementation was not the same as the other.<br /><br />Speed is not the only concern when picking an implementation, but it is certainly good to know. For the Factory Method, the fastest that I found was the classic subclass approach:<pre class=prettyprint>abstract class Creator {<br />  Product productMaker();<br />}<br /><br />abstract class Product {}<br /><br />class ConcreteCreator extends Creator {<br />  productMaker()=> new ConcreteProduct();<br />}<br /><br />class ConcreteProduct extends Product {}</pre>The abstract creator describes that subclasses will be responsible for choosing the class to instantiate. In this case it is a new <code>ConcreteProduct</code>, mirroring the role in the pattern. When I use the pattern in <a href="https://github.com/eee-c/dart-comics">Dart Comics</a>, the collection chooses to create a concrete <code>ComicBook</code>. The point being that the subclass can choose whatever it likes. And it is fast.<br /><br />The alternate approach uses a <code>Map</code> of factories, enabling the top-level creator to sport a default implementation:<pre class=prettyprint>typedef Product productFactory();<br />Map&lt;Type, productFactory> Factory = {<br />  ConcreteCreator: (){ return new ConcreteProduct(); }<br />};<br /><br />abstract class Creator {<br />  Product productMaker()=> Factory[this.runtimeType]();<br />}<br /><br />abstract class Product {}<br /><br />class ConcreteCreator extends Creator {}<br />class ConcreteProduct extends Product {}</pre>Yesterday, I found that subclass approach was roughly 600% faster than the map-of-factories implementation. It is actually even better than that. After updating to Dart 1.5, the results are now:<pre class=prettyprint>$ dart tool/benchmark.dart<br />Factory Method — Subclass(RunTime): 0.08871921437716161 us.<br />Factory Method — Map of Factories(RunTime): 1.7642425092468361 us.</pre>1800% faster. That's craziness. But...<br /><br />It is not quite a fair comparison. The <code>productMaker()</code> from the subclass version immediately creates the concrete instance. Calling the <code>productMaker()</code> method in the map-of-factories version does not immediately instantiate the concrete instance. Instead, it calls a closure that creates and returns the object. Perhaps this indirection makes a difference?<br /><br />To find out, I replace the <code>productMaker()</code> method in the map-of-factories approach with a <code>getter</code> that returns the factory method:<pre class=prettyprint>typedef Product productFactory();<br />Map&lt;Type, productFactory> Factory = {<br />  ConcreteCreator: (){ return new ConcreteProduct(); }<br />};<br /><br />abstract class Creator {<br /><b>  productFactory get productMaker=> Factory[this.runtimeType];</b><br />}<br />// ...</pre>The dynamic language dork in me loves this kind of thing, but it is probably a little hard to read. The <code>productMaker</code> getter returns the Map lookup in <code>Factory</code>. The value returned from the <code>Factory</code> lookup, and hence from the <code>productMaker</code> getter, is a closure—an anonymous function. This return value can be invoked with the call operator—open and closing parenthesis. So it looks just like a method call:<pre class=prettyprint>new MapOfFactories.ConcreteCreator().productMaker();</pre>But is is not a method—I am immediately invoking the result of the Map lookup.<br /><br />Cool, eh? Well, I like it. Anyway, the result of all that? No change whatsoever:<pre class=prettyprint>dart tool/benchmark.dart<br />Factory Method — Subclass(RunTime): 0.08664997297170718 us.<br />Factory Method — Map of Factories(RunTime): 1.7268800975341878 us.</pre>Well, maybe a <i>slight</i> improvement, but it is unclear if the improvement is statistically significant.<br /><br />So, unless I am missing some obvious way to improve things, my map-of-factories approach is 20 times slower than the subclass approach. There are time in which this will not matter (e.g. when I am not creating a large quantity of concrete products), but this certainly needs to factor into choosing an implementation.<br /><br /><br /><span style="color: #ccc">Day #106</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/06/benchmarking-factory-method-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Nh5RvuI4iKU" height="1" width="1"/>
