---
title: 'Non-Trivial Undo in the Command Pattern'
layout: post
published: '2015-12-09T23:00:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/ZeRMclDok14/non-trivial-undo-in-command-pattern.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Wither undo? Contemplating that question in regards to the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>, I could not decide between the receiver and the invoker. Naturally, the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> opts for the concrete command object. Perplexed, I delve into that tonight.<br /><br />Lacking a better example, I am still working with a <a href="http://dartlang.org">Dart</a> take of the classic light switch example for the command pattern. The command object from last night did place the <code>undo()</code> in the concrete command object, but I felt that I could get away with that in this simplistic example. The "on" command, for instance, inherently knows how to undo switching a light on... by turning it off:<pre class=prettyprint>// Concrete Command<br />class OnCommand implements Command {<br />  Light light;<br />  OnCommand(this.light);<br />  void call() { light.turn('ON'); }<br />  void undo() { light.turn('OFF'); }<br />}</pre>But what if the switch supports a third state, say 50% lighting? The power of the command pattern, of course, is that it is easy to add new commands. No existing classes need to change, I just need to add the <code>FiftyCommand</code>:<pre class=prettyprint>class FiftyCommand implements Command {<br />  Light light;<br />  FiftyCommand(this.light);<br />  void call() { light.turn('50%'); }<br />  void undo() { /* ???? */  }<br />}</pre>Ah, I see how to implement undo in the concrete class. When the command is called, I can save the receivers previous state, then reuse it when undoing:<pre class=prettyprint>class FiftyCommand implements Command {<br />  Light light;<br />  String _prev;<br />  FiftyCommand(this.light);<br />  void call() {<br />    _prev = light.state;<br />    light.turn('50%');<br />  }<br />  void undo() {<br />    light.turn(_prev);<br />  }<br />}</pre>I again see the weakness of this particular example (even with a third state). The command pattern is likely most appropriate when working with multiple kinds of receivers instead of a single light as I am doing here. The simplicity of working with a single light means that the on, off, and 50% commands can all extend a common baseclass that defines the undo behavior:<pre class=prettyprint>class LightCommand implements Command {<br />  Light light;<br />  String _prev;<br />  LightCommand(this.light);<br />  void call() {<br />    _prev = light.state;<br />  }<br />  void undo() {<br />    light.turn(_prev);<br />  }<br />}</pre>The on, off, and fifty classes can then extend this class to send the appropriate message to the receiver and rely on the baseclass to store the previous state:<pre class=prettyprint>class FiftyCommand extends LightCommand {<br />  FiftyCommand(light): super(light);<br />  void call() {<br />    super.call();<br />    light.turn('50%');<br />  }<br />}</pre>With that, if I turn the light on, 50%, off, and on:<pre class=prettyprint>$ ./bin/press_switch.dart on 50 off on                     <br />Light ON<br />Light 50%<br />Light OFF<br />Light ON</pre>Then undoing everything should move back to off, then 50%, then on, then back to the original state (off). Which is exactly what gets reported:<pre class=prettyprint>$ ./bin/press_switch.dart on 50 off on                     <br />Light ON<br />Light 50%<br />Light OFF<br />Light ON<br />--<br />Light OFF<br />Light 50%<br />Light ON<br />Light OFF</pre>I think that I have a good handle on this, which means that I'm probably ignoring 5 or 6 major implications that I will discover in the next few days. Even if I do have a complete understanding of command-undo, I think that I need a better example to include in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. The switch example is good first pass example, but it lacks legitimate motivation for using this pattern. I will likely try to improve on the example tomorrow.<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/c188204c7a4a5194bfe1">https://dartpad.dartlang.org/c188204c7a4a5194bfe1</a>.</i><br /><br /><br /><span style="color: #ccc">Day #28</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/limited-command-callbacks.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/argument-passing-in-command-pattern.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/ZeRMclDok14" height="1" width="1" alt=""/>
