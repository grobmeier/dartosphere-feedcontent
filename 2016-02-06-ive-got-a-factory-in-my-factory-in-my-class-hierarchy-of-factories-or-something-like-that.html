---
title: 'I''ve Got a Factory in My Factory in My Class Hierarchy of Factories (or Something Like That)'
layout: post
published: '2016-02-06T22:05:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/gnOdXrIZdcQ/ive-got-factory-in-my-factory-in-my.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Yesterday I worked up a <a href="http://dartlang.org">Dart</a> example of the <a href="">factory method pattern</a> in which a "game factory" could pit two players against each other in a series of board games:<pre class=prettyprint>main() {<br />  var series = new GameFactory('Professor Falken', 'Joshua');<br /><br />  series<br />    ..start()<br />    ..createBoardGame('Checkers').play()<br />    ..createBoardGame('Thermo Nuclear War').play()<br />    ..createBoardGame().play();<br />}</pre>Most of the concrete implementation of the pattern is placeholder <code>print()</code> statements. The code so far establishes a series of games between two players, creates a board game via the factory method from which the pattern gets its name, then plays the game. Currently, this results in output along the lines of:<pre class=prettyprint>$ ./bin/board_game.dart<br />*** Professor Falken vs. Joshua ***<br />  CheckersGame<br />    Player One starts with: 12 pieces<br />    Player Two starts with: 12 pieces<br />    --<br />    Winner: Player One<br /><br />  ThermoNuclearWar<br />    Player One starts with: 1,000 warheads<br />    Player Two starts with: 1,000 warheads<br />    --<br />    Winner: None<br /><br />  ChessGame<br />    Player One starts with: 1 king, 1 queen, 2 rooks, 2 bishops, 2 knights, 8 pawns<br />    Player Two starts with: 1 king, 1 queen, 2 rooks, 2 bishops, 2 knights, 8 pawns<br />    --<br />    Winner: Player One</pre>That seems a decent example of the pattern except that the placeholder code is starting out with ugliness. Specifically, the products in the patterns—the various board games—are on the repetitive side:<pre class=prettyprint>class ChessGame extends BoardGame {<br />  List playerOnePieces = [<br />    '1 king', '1 queen', '2 rooks', '2 bishops', '2 knights', '8 pawns'<br />  ];<br />  List playerTwoPieces = [<br />    '1 king', '1 queen', '2 rooks', '2 bishops', '2 knights', '8 pawns'<br />  ];<br />}</pre>What the various <code>BoardGame</code> classes need is a common way to create the initial set of pieces on the board. If only there were a design pattern that could help with that…<br /><br />Say, that sounds like a factory method pattern! Now, I know what you're thinking, a factory inside a factory—that's typical pattern fanboyism. I'm not going to argue with you, but I beg your patience for just a bit...<br /><br />If <code>BoardGame</code> is now a factory, I need it to declare a factory method for its subclasses to implement. Since it needs to generate game pieces for the start of a game, I have it require a <code>_createPieces()</code> method:<pre class=prettyprint>abstract class BoardGame {<br />  GamePieces playerOnePieces, playerTwoPieces;<br />  BoardGame() {<br />    playerOnePieces = _createPieces();<br />    playerTwoPieces = _createPieces();<br />  }<br />  GamePieces _createPieces();<br />  // ...<br />}</pre>Both player one and player two will be assigned the same number of pieces to begin, so the constructor assigns both player one's and player two's pieces to the results of the <code>_createPieces</code> factory method. But the abstract <code>BoardGame</code> does not know how to create chess, checkers, etc. pieces. Subclasses need to define these:<pre class=prettyprint>class ChessGame extends BoardGame {<br />  GamePieces _createPieces() => new ChessPieces();<br />}<br /><br />class CheckersGame extends BoardGame {<br />  GamePieces _createPieces() => new CheckersPieces();<br />}<br /><br />class ThermoNuclearWar extends BoardGame {<br />  GamePieces _createPieces() => new ThermoNuclearPieces();<br />  String get winner => "None";<br />}</pre>With that, my board game classes are significantly DRYer and better able to define the functionality behind the actual game play.<br /><br />But back to the factory-in-a-factory craziness that I have inflicted on myself. I think it actually makes sense. From an illustrative standpoint, it is over the top, but it feels like a reasonable, organic structure. Perhaps last night's <code>GameFactory</code> → <code>GameBoard</code> creator/product was somewhat artificial, but I need to generate different gameboards at runtime, so that makes a decent amount of sense. If anything, tonight's approach feels even better. Each boardgame needs to layout and assign pieces to the players, so a factory method serves nicely in that capacity.<br /><br />In fact, it makes so much sense that it is a flavor of the factory method pattern: the parallel class hierarchy variation. By taking this approach, I know that, for each type of board game in the <code>BoardGame</code> class hierarchy, there will be a corresponding entry in the hierarchy of the <code>GamePieces</code> classes. The <code>ChessGame</code> needs to use <code>ChessPieces</code> in order to populate the game:<pre class=prettyprint>class ChessGame extends BoardGame {<br />  GamePieces _createPieces() => new ChessPieces();<br />}</pre>Armed with that knowledge, the client code can make use of this as well. For example it could restart a game or start a new one:<pre class=prettyprint><code>  series.start();<br />  var game;<br />  game = series.createBoardGame('Checkers');<br />  game.play();<br />  // Start over<br />  game.playerOnePieces = game._createPieces();<br />  game.playerTwoPieces = game._createPieces();<br />  game.play();</code></pre>That might be a little more useful in another example (a <code>restart()</code> method would make most sense in this example), but it still serves to illustrate some of the potential of this parallel hierarchy approach. I may examine a different example tomorrow to get a better handle on this. Or I may switch to mirrors. Either way, it is sure to be more fun with factories!<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/639e49cfc1b2ee3cb82a">https://dartpad.dartlang.org/639e49cfc1b2ee3cb82a</a>.</i><br /><br /><br /><span style="color: #ccc">Day #87</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/factory-method-without-factory.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/factory-games-with-mirrors.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/gnOdXrIZdcQ" height="1" width="1" alt=""/>
