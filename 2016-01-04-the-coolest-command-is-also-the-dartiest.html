---
title: 'The Coolest Command is Also the Dartiest'
layout: post
published: '2016-01-04T20:59:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/OjPuNbHNiYA/the-coolest-command-is-also-dartiest.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'
    - tearoffs

---

<div class=top-chain-links></div><br />Something strange happened yesterday. I wrote some <a href="http://dartlang.org">Dart</a> code that just worked™. <br /><br />OK, that's not too strange—Dart is designed to be familiar and easy to understand, after all. What's strange is that I did something that would not have worked in nearly any other language—passing a reference to the method of an object instance. I cannot recall if I knew this would work or if I wasn't thinking and just got lucky. Probably the latter, but either way, it worked.<br /><br />This definitely will not work in JavaScript, for example. If I have a <code>Robot</code> class in JavaScript:<pre class=prettyprint>Robot = function(){<br />  this.x=0; <br />  this.y=0;<br />}<br />Robot.prototype.getXyLocation = function() { <br />  return "" + this.x + ", " + this.y; <br />}<br />Robot.prototype.moveForward = function() { <br />  this.y++;<br />}</pre>Then I can create an instance of <code>Robot</code> and move it forward by calling the <code>moveForward()</code> method:<pre class=prettyprint>var r = new Robot();<br />r.moveForward();<br />r.getXyLocation();<br />// => "0, 1"</pre>But I cannot grab a reference to the <code>moveForward()</code> method from <code>r</code>, call that reference directly, and expect it to update <code>r</code>:<pre class=prettyprint>var c = r.moveForward;<br />c();<br />r.getXyLocation();<br />// => "0, 1"</pre>The <code>r</code> remains at <code>0, 1</code> because of <code>this</code>, of course. Undesirable or unexpected behavior in JavaScript always comes back to <code>this</code>.<br /><br />In this case, <code>c</code> is a function—the same one defined on the <code>Robot</code> prototype. Invoking it did increment <code>this.y</code> just as it did in the <code>Robot</code> method, but the <code>this</code> inside <code>c</code> refers to the top-level client object. I could <code>apply()</code> or <code>call()</code> the <code>c</code> function with the appropriate <code>this</code> context:<pre class=prettyprint>c.call(r);<br />r.getXyLocation();<br />// => "0, 2"</pre>By explicitly setting the method context with <code>call()</code> I am able to update <code>r</code>. But that's a pain, like just about everything dealing with <code>this</code> in JavaScript. If I wanted to pass that method in code, I would always have to pass it along with the object. In other words, I would need some explicit form of the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>.<br /><br />But in Dart, that turns out to be unnecessary. I can define a similar <code>Robot</code> class:<pre class=prettyprint>class Robot {<br />  int x=0, y=0;<br />  String get xyLocation => "$x, $y";<br />  void moveForward() { y++; }<br />}</pre>Then I can move the robot forward, tear off the method into a variable and move the robot forward using that variable method:<pre class=prettyprint>main () {<br />  var robot = new Robot();<br />  robot.moveForward();<br />  <br />  var c = robot.moveForward;<br />  c();<br />  <br />  print("The robot is now at: ${robot.xyLocation}.");<br />}</pre>After that, the robot has moved forward twice:<pre class=prettyprint>The robot is now at: 0, 2.</pre>It turns out that I should have remembered this. There was a minor brouhaha over this on the Dart list over the summer. These tear-off methods are closures built into the language. This is a pretty cool feature, so the kerfuffle was not over this, rather over a more generalized tear-off syntax. <br /><br />If I wanted to tearoff a getter like <code>xyLocation</code>, for instance, I could not assign <code>robot.xyLocation</code>—that would assign the value of the getter. To obtain a reference to getter method, I would have to use <code>robot#xyLocation</code>:<pre class=prettyprint>main () {<br />  var robot = new Robot();<br />  var loc = robot#xyLocation;<br />  var c = robot.moveForward;<br /><br />  // Regular method invocation...<br />  robot.moveForward();<br /><br />  // Tear-off method invocations...<br />  c();<br />  print("The robot is now at: ${loc()}.");<br />}</pre>It is a little strange to tearoff a getter and have to invoke it with parenthesis, but the main source of consternation was the hash symbol to obtain the tearoff. I would tend to agree with those that object to that particular syntax—it is uglier than the regular syntax and it it easy to confuse with Dart symbols which start with the hash symbol as well. Still, it is nice to know that it is possible should I ever need it.<br /><br />More importantly, I think I have identified the Dartiest possible command pattern. I can't believe that I almost overlooked it!<br /><br /><i>Play with this on DartPad (the generalized/hash tearoff syntax is not supported): <a href="https://dartpad.dartlang.org/f3a717a9743953733de8">https://dartpad.dartlang.org/f3a717a9743953733de8</a>.</i><br /><br /><br /><span style="color: #ccc">Day #54</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/asynchronous-delegator-adapters-and.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/OjPuNbHNiYA" height="1" width="1" alt=""/>
