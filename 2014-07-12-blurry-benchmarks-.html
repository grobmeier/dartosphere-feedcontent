---
title: 'Blurry Benchmarks '
layout: post
published: '2014-07-12T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/KACDL3tc_Xk/blurry-benchmarks.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br /><b>tl;dr</b> You may regret reading this post. I am grateful that I wrote it because I wound up correctly a major problem in my thinking because of a dumb mistake, but it was a really dumb mistake....<br /><br />At the risk of overdoing my benchmark exploration for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>, there is one other facet of them that I would like to make sure I understand.<br /><br />After a bit of code reorganization last night, I found that my three approaches to the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> broken down like:<pre class=prettyprint>Classic Visitor Pattern (RunTime): 1374 µs.<br />--<br />Nodes iterate w/ single dispatch (RunTime): 1290 µs.<br />--<br />Visitor Traverses (RunTime): 1362 µs.</pre>This more or less breaks down like I expected from the outset. There is a slight win for the second approach, which exploits some knowledge of the structure being visited in order to invoke a collection with single dispatch.<br /><br />What strikes me as odd is that, prior to reorganizing the file locations, I was seeing numbers like:<pre class=prettyprint>Classic Visitor Pattern (RunTime): 1345 us.<br />--<br />Nodes iterate w/ single dispatch (RunTime): 1344 us.<br />--<br />Visitor Traverses(RunTime): 1411 us.</pre>Only the location of the code changed. Not of the actual code changed—well except for one thing...<br /><br />I have settled on laying out the code for the public facing book repository like this:<pre class=prettyprint>lib<br />├── inventory.dart<br />├── visitor.dart<br />└── alt<br />    ├── single_dispatch_iteration<br />    │   ├── inventory.dart<br />    │   └── visitor.dart<br />    └── visitor_traverse<br />        ├── inventory.dart<br />        └── visitor.dart</pre>The preferred solution (either because of suitability or performance) will reside at the top the package's <code>lib</code> directory. Alternate approaches will reside in <code>lib/alt</code>. Before this file reorganization, all implementations resided in the top level of the <code>lib</code> directory. And some <i>shared code</i>.<br /><br />I am fairly sure that the sharing of the code inadvertently caused the slowness in the pre-file-reorg benchmarks. I would actually be somewhat surprised if that is the case because it would be an issue caused by types which I thought Dart ignored. Anyway, enough speculation.<br /><br />Previously, the “classic” visitor pattern implementation (e.g. with double dispatch) and the single-dispatch code shared <code>visitor.dart</code>. Once I re-organized files, they are still identical copies:<pre class=prettyprint>$ diff -s lib/visitor.dart lib/alt/single_dispatch_iteration/visitor.dart<br />Files lib/visitor.dart and lib/alt/single_dispatch_iteration/visitor.dart are identical</pre>But previously they were the same file and both benchmarks loaded the same file. To reproduce the prior situation, I change the top-level benchmark to use the single-dispatch's visitor:<pre class=prettyprint>#!/usr/bin/env dart<br /><br />import 'package:benchmark_harness/benchmark_harness.dart';<br /><br />import 'package:visitor_code/alt/single_dispatch_iteration/visitor.dart';<br />import 'package:visitor_code/inventory.dart';<br /><br />main () {<br />  _setup();<br /><br />  VisitorBenchmark.main();<br />  VisitorBenchmark.main();<br />  VisitorBenchmark.main();<br />}<br />//  ...</pre>When I run the benchmarks, however, I find no change. The single dispatch approach still runs the quickest and the double dispatch implementation still runs slightly slower. So it seems like my supposition about types was wrong after all. I had begun to suspect that importing the single dispatch's visitor was in turn pulling in the single dispatch node structure (where the single dispatch actually resides). But that is not the case.<br /><br />So why did I get nearly identical single and double benchmark numbers? Well, it turns out that the explanation is much simpler. I luckily saved my work in git, so I can git checkout the benchmarks in question:<pre class=prettyprint>$ git checkout HEAD~1</pre>The previous double dispatch benchmark looked like:<pre class=prettyprint>#!/usr/bin/env dart<br /><br />import 'package:benchmark_harness/benchmark_harness.dart';<br /><br /><b>import 'package:visitor_code/visitor.dart';</b><br /><br />main () {<br />  _setup();<br /><br />  NodesDoubleBenchmark.main();<br />  NodesDoubleBenchmark.main();<br />  NodesDoubleBenchmark.main();<br />}<br />// ...</pre>So I was relying on <code>visitor.dart</code> to export the relevant inventory. For double dispatch, this should have been the double-dispatching inventory library, but... it was the single dispatching code:<pre class=prettyprint>library visitor;<br /><br />import 'inventory_single_dispatch.dart';<br /><b>export 'inventory_single_dispatch.dart';</b><br />// ...<br /></pre>So of course the two benchmarks were identical—they were explicitly running the same damn code!<br /><br />Ugh.<br /><br />I am so ashamed. It turns out that <a href="http://pragprog.com/the-pragmatic-programmer/extracts/tips">select is not broken</a>. I had readily built up a ridiculous explanation in my head for why two different approaches resulted in the same results. It turns out that the results were the same because I used the same approach both times.<br /><br />I can take some measure of solace in the fact that I took the time to correct myself. I almost did not investigate the discrepancy in numbers tonight (I was seriously that certain that my rationalization was valid). Luckily I did investigate. And even though I once again proved that I am an idiot, hopefully I am a slightly more knowledgeable idiot.<br /><br />More importantly, I am far more convinced that I need to organize my implementations in the <code>lib/alt</code> scheme. Had I not attempted to shove everything into the top-level as I had, I never would have gotten myself into this situation.<br /><br />Now if you'll excuse me, I need to go flog myself.<br /><br /><br /><br /><span style="color: #ccc">Day #120</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/crazy-warm-dart-benchmarks.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/KACDL3tc_Xk" height="1" width="1"/>
