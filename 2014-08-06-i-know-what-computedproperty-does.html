---
title: 'I Know What ComputedProperty Does!'
layout: post
published: '2014-08-06T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/YrC1UVSJPrk/i-know-what-computedproperty-does.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - annotations
    - chain
    - dart
    - dartlang
    - polymer

---

<div class=top-chain-links></div><br />After two night's of experimentation, I swear to you that the <code>@ComputedProperty</code> annotation in <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a> serves no purpose. No purpose whatsoever!<br /><br />Well, OK, it <i>does</i> something, but as far as my experiments have determined, it does exactly what a much simpler and syntactically cleaner Dart getter would do. Consider a <code>@ComputedProperty</code> and a vanilla getter that produce identical results in the <code>&lt;x-pizza-toppings></code> Polymer element:<pre class=prettyprint>@CustomTag('x-pizza-toppings')<br />class XPizzaToppings extends PolymerElement {<br />  // ...<br />  List&lt;String> model = toObservable([]);<br /><br /><b>  @ComputedProperty("model.length")<br />  int get numToppings => readValue(#numToppings);<br /><br />  int get numToppings_old => model.length;</b><br />  // ...<br />}</pre>The values of both will report the number of toppings that are included on a half or whole of pizza in the parent <code>&lt;x-pizza></code> element. To prove that both the getter and the much more verbose <code>@ComputedValue</code> are IDENTICAL IN EVERY WAY, I include both in the <code>&lt;template></code>:<pre class=prettyprint>&lt;link rel="import" href="../../../packages/polymer/polymer.html"><br />&lt;polymer-element name="x-pizza-toppings"><br />&lt;template><br />&lt;p><br />&lt;!-- ... --><br /><b>      (Currently: {{ numToppings }}, {{ numToppings_old }})</b><br />&lt;/p><br />&lt;/template><br />&lt;script type="application/dart" src="x_pizza_toppings.dart">&lt;/script><br />&lt;/polymer-element><br /></pre>And, when I update the different sides of the pizza in the UI, these bindings are updated in exact unison:<br /><br /><a href="http://3.bp.blogspot.com/-Rab2WccvWsY/U-L3av436lI/AAAAAAAAdu8/FKworzXCyN8/s1600/01-getter_and_computed_value_updated_in_unison.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-Rab2WccvWsY/U-L3av436lI/AAAAAAAAdu8/FKworzXCyN8/s400/01-getter_and_computed_value_updated_in_unison.png" /></a><br /><br />But there must be a reason for <code>@ComputedValue</code>. There simply must be!<br /><br />Experimentation is clearly getting me nowhere, so I switch back to reading the actual code. And, thankfully, the code is beautiful. Well, documented, easy to follow for the most part. I could (and probably should) read through this all night long. But first, I must know. <br /><br />And I finally have my answer from the <code>_PropertyAccessor</code> internal class which services both the <code>@ComputedValue</code> and <code>@published</code> annotations. In there, I find that, when these are updated, they perform the following:<pre class=prettyprint><code>  /// Updates the underlyling value and fires the expected notifications.<br />  void updateValue(T newValue) {<br />    var oldValue = _value;<br />    _value = _target.notifyPropertyChange(_name, oldValue, newValue);<br />    _target.emitPropertyChangeRecord(_name, newValue, oldValue);<br />  }<br /></code></pre>There is even documentation expressing what I should have expected all along—that a changed record is emitted by the Polymer element. And, sure enough, such a record is emitted. I add a listener in the parent <code>&lt;x-pizza></code> element:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  XPizzaToppings get firstHalf => $['firstHalfToppings'];<br />  XPizzaToppings get secondHalf => $['secondHalfToppings'];<br />  XPizzaToppings get whole => $['wholeToppings'];<br />  // ...<br />  XPizza.created(): super.created() {<br /><b>    firstHalf.changes.listen((changes) {<br />      print(changes);<br />    });</b><br /><br />    /*** I previously tried this (I was so close) ***/<br />    // firstHalf.numToppings.changes.listen((changeRecord) {<br />    //   print("$changeRecord");<br />    // });<br />  }<br />  // ...<br />}</pre>Which reports that a change has occurred:<pre class=prettyprint>[#&lt;PropertyChangeRecord Symbol("numToppings") from: 0 to: 1>]<br />[#&lt;PropertyChangeRecord Symbol("numToppings") from: 1 to: 2>]<br />[#&lt;PropertyChangeRecord Symbol("numToppings") from: 2 to: 3>]</pre>I have my answer. And it is one that I really should have gotten to faster had I thought about it a bit more. Ah well, in the end I had some frustration but was rewarded with some pleasant code reading—and the answer to my question.<br /><br /><br /><span style="color: #ccc">Day #145</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/08/i-remain-somewhat-confused-about.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/YrC1UVSJPrk" height="1" width="1"/>
