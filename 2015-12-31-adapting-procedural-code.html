---
title: 'Adapting Procedural Code'
layout: post
published: '2015-12-31T21:48:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/mHbpjsNGep0/adapting-procedural-code.html'
author:
    name: Anonymous
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/00135361916531185929'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />So the basic adapter pattern in <a href="http://dartlang.org">Dart</a> is <a href="http://japhr.blogspot.com/2015/12/an-object-adapter-pattern-in-dart.html">pretty darn boring</a>. Case closed on research for the forthcoming <a href="http://dartlang.org">Dart</a> <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>? Far from it. I have the utmost confidence in my ability to make things way more complicated than they might at first seem (or need to be).<br /><br />Toward that end, tonight I try adapting procedural code to an a asynchronous interface. The code that currently powers the design patterns robot is quite procedural:<pre class=prettyprint>class Robot {<br />  // ...<br />  String get location => "$x, $y";<br />  void move(direction) {<br />    print("  I am moving $direction");<br />    switch (direction) {<br />      case Direction.NORTH:<br />        y++;<br />        break;<br />      case Direction.SOUTH:<br />        y--;<br />        break;<br />      case Direction.EAST:<br />        x++;<br />        break;<br />      case Direction.WEST:<br />        x--;<br />        break;<br />    }<br />  }<br />}</pre>I can easily move my robot forward a far as I like by sending multiple <code>move()</code> messages to the robot:<pre class=prettyprint><code>  var robot = new Robot();<br />  print("Start moving the robot.");<br />  robot<br />    ..move(Direction.NORTH)<br />    ..move(Direction.NORTH)<br />    ..move(Direction.NORTH)<br />    ..move(Direction.NORTH)<br />    ..move(Direction.NORTH);<br />  print("The robot is now at: ${robot.location}.");</code></pre>With that, the robot winds up at <code>0, 5</code> (fives paces in the positive Y-direction):<pre class=prettyprint>$ ./bin/play_robot.dart<br />Start moving the robot.<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />The robot is now at: 0, 5.</pre>Unfortunately, this will not work with the Universal Robot Remote Controlâ„¢. The forward button on the universal remote starts the robot moving forward and does not stop it until some other action occurs (e.g. the button is released, the stop button is pressed, the robot crashes). What I need to do is <i>adapt</i> my robot's one-step-at-a-time interface to the universal remote's continuous motion interface. That means the adapter pattern, yay!<br /><br />The universal remote might expect a robot interface that looks something like:<pre class=prettyprint>library universal_remote;<br /><br />import 'dart:async';<br /><br />import 'robot.dart';<br /><br />abstract class Ubot {<br />  Timer moveForward();<br />  Timer moveBackward();<br />  Timer moveLeft();<br />  Timer mvoeRight();<br />  void stop();<br />}</pre>The <code>Timer</code> return type for those move actions could likely be adapted to something more domain specific, but they will suffice for now. For example, the <code>moveForward()</code> action continuously moves the robot forward until the returned timer is canceled. So timer objects will work in this first pass at the pattern.<br /><br />I will move the robot adaptee forward once a second, so I grab a reference to a one second constant:<pre class=prettyprint>const oneSecond = const Duration(seconds: 1);</pre>With that out of the way, I am ready to adapt my robot to the universal remote robot interface.<br /><br />The adapter will need to accept an instance of the <code>Robot</code> being adapted:<pre class=prettyprint>class UbotRobot {<br />  Robot _robot;<br />  UbotRobot(this._robot);<br />}</pre>A <code>moveForward()</code> can then make use of that private instance variable reference to the robot to move it forward (or "north" in <code>Robot</code> parlance) once every second:<pre class=prettyprint>class UbotRobot {<br />  Robot _robot;<br />  UbotRobot(this._robot);<br /><br />  Timer moveForward() =><br />    new Timer.periodic(oneSecond, (_){ _robot.move(Direction.NORTH); });<br />}</pre>To implement the other directions, I would likely use a common private method along the lines of <code>_move()</code>:<pre class=prettyprint>class UbotRobot {<br />  Robot _robot;<br />  UbotRobot(this._robot);<br /><br />  Timer moveForward()  => _move(Direction.NORTH);<br />  Timer moveBackward() => _move(Direction.SOUTH);<br />  Timer moveLeft()     => _move(Direction.WEST);<br />  Timer mvoeRight()    => _move(Direction.EAST);<br />  Timer _move(dir) =><br />    new Timer.periodic(oneSecond, (_){ _robot.move(dir); });<br />}</pre>With that, I am ready to try things out in the client code. I grab an instance of the robot being adapted to supply it  to the universal remote robot adapter:<pre class=prettyprint><code>  var robot = new Robot();<br />  var universalRobot = new UbotRobot(robot);</code></pre>Next, I start moving forward, making sure to grab a reference to the control object (the returned <code>Timer</code>):<pre class=prettyprint><code>  print("Start moving the robot.");<br />  var btnCtrl = universalRobot.moveForward();</code></pre>To simulate waiting 10 second before releasing the button, I create a 10 second timer. When the 10 second timer has elapsed, the callback cancels the timer and prints the robot's new location:<pre class=prettyprint><code>  // Simulate the button being release 10 seconds later...<br />  new Timer(<br />    new Duration(seconds: 10),<br />    (){<br />      btnCtrl.cancel();<br />      print("The robot is now at: ${robot.location}.");<br />    }<br />  );</code></pre>And that does the trick, my procedural robot moves north once every second, winding up at <code>0, 10</code>:<pre class=prettyprint>$ /bin/play_robot.dart<br />Start moving the robot.<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />The robot is now at: 0, 10.</pre>So in the end, a simple asynchronous adapter for procedural code was still pretty darn easy. Let's see what else I can throw at Dart to make this a little more difficult. Tomorrow.<br /><br />Happy New Year everybody!<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/fc43bb0630d0c347d293">https://dartpad.dartlang.org/fc43bb0630d0c347d293</a>.</i><br /><br /><br /><span style="color: #ccc">Day #50</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/an-object-adapter-pattern-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/what-heck-is-pluggable-adapter.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/mHbpjsNGep0" height="1" width="1" alt=""/>
