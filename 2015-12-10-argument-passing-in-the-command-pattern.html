---
title: 'Argument Passing in the Command Pattern'
layout: post
published: '2015-12-10T23:35:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/lefsSNMkGfw/argument-passing-in-command-pattern.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />One of the things I appreciate in the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> example from the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> is that it uses different kinds of receivers. One of the things that bugs me is how the example passes arguments from the client to the command.<br /><br />The GoF example is a document editor menu. The create-new-document menu item points to a create-document command which is executed when the menu item is selected in the UI. To obtain the filename of the new document, the GoF example invokes an <code>askUser()</code> function which presumably pops up a dialog to await user input. I suppose that is not too horrible, but what if the command argument is already known?<br /><br />To explore that, I switch from my previous light switch command example to a new take on the <code>VelvetFogMachine</code>—a jukebox-like device intended for playing and organizing songs of the late, great Mel Tormé.  This <a href="http://dartlang.org">Dart</a> example uses a menu invoker, much like the invoker from the GoF example:<pre class=prettyprint><code>  // Invoker<br />  var menu = new Menu();</code></pre>It defines two receivers, the <code>VelvetFogMachine</code> and <code>Playlist</code> instances used to find the ultimate Mel mix:<pre class=prettyprint><code>  // Receivers<br />  var machine = new VelvetFogMachine();<br />  var playlist = new Playlist([<br />    '\'Round Midnight',<br />    'It Don\'t Mean A Thing (If It Ain\'t Got That Swing)',<br />    'New York, New York',<br />    'The Lady is a Tramp'<br />  ]);</code></pre>Some of the menu commands available on the user interface might be play-song, add-to-playlist, remove-from-playlist, which would look like:<pre class=prettyprint><code>  // Concrete command instances<br />  var menuPlay = new PlayCommand(machine),<br />    menuAddToPlaylist = new PlaylistAddCommand(playlist),<br />    menuRemoveFromPlaylist = new PlaylistRemoveCommand(playlist);</code></pre>Like most jukeboxes, the velvet fog machine can play a song by selecting it from a list, then pressing the menu item associated with <code>menuPlay</code>. But how to get that song to the command?<br /><br />My first instinct is to muck with <code>noSuchMethod</code> to obtain optional execution arguments via reflection. That seems likely to cause trouble. Instead, I start by defining am <code>args</code> property on the <code>Command</code> interface:<pre class=prettyprint>abstract class Command {<br />  List args;<br />  void call();<br />}</pre>Then, in the invoker, I assign this property when invoking with arguments:<pre class=prettyprint>class Menu {<br />  void call(Command c, [List args]) {<br />    if (args != null) c.args = args;<br />    c.call();<br />  }<br />}</pre>The concrete class can use this arguments-property to execute its command:<pre class=prettyprint>class PlayCommand implements Command {<br />  List args;<br />  VelvetFogMachine machine;<br />  PlayCommand(this.machine);<br />  void call() {<br />    machine.play(args.first);<br />  }<br />}</pre>That works, but feels less than ideal. The client code is simple enough:<pre class=prettyprint><code>  menu.call(menuPlay, ['It Had to Be You']);</code></pre>But the <code>args</code> property just feels awkward.<br /><br />Hunh. I don't know why I didn't try this first, but the <code>Command</code> interface can be defined to accept <i>optional</i> arguments when invoked:<pre class=prettyprint>abstract class Command {<br />  void call([List args]);<br />}</pre>I had worried that static typing would bite me when trying to define <code>call()</code> methods when some subclasses required parameters while others did not need them. Dart's optional arguments resolves the problem neatly. Command like "play" that require an argument can support them:<pre class=prettyprint>class PlaylistAddCommand implements Command {<br />  Playlist playlist;<br />  PlaylistAddCommand(this.playlist);<br />  void call([List args]) {<br />    print('==> [add] ${args.first}');<br />    playlist.add(args);<br />  }<br />}</pre>Commands that do not need an argument, like clearing a playlist, can support <code>call()</code> with no arguments:<pre class=prettyprint>class PlaylistClearCommand implements Command {<br />  Playlist playlist;<br />  PlaylistClearCommand(this.playlist);<br />  void call([_]) {<br />    print('==> [clear]');<br />    playlist.clear();<br />  }<br />}</pre>The Dart type analyzer balks if I specify a completely empty <code>call()</code> definition since it does not quite match the interface. But if I specify the argument with the underscore convention for ignoring arguments, I essentially declare a <code>call()</code> with no arguments. That's slightly hacky, but not so much that I am going to lose sleep over it.<br /><br />I am fairly happy with this argument passing approach. Calling these commands:<pre class=prettyprint><code>  menu.call(menuPlay, ['It Had to Be You']);<br /><br />  print('--');<br />  menu.call(menuPlay, [playlist]);<br /><br />  print('--');<br />  menu.call(menuAddToPlaylist, ['Blue Moon']);<br />  menu.call(menuPlay, [playlist]);<br /><br />  print('--');<br />  menu.call(menuRemoveFromPlaylist, ['The Lady is a Tramp']);<br />  menu.call(menuPlay, [playlist]);<br /><br />  print('--');<br />  menu.call(menuClearPlaylist);<br />  menu.call(menuPlay, [playlist]);</code></pre>Produces the expected results:<pre class=prettyprint>./bin/jukebox.dart                                       <br />Play It Had to Be You<br />--<br />Play 'Round Midnight<br />     It Don't Mean A Thing (If It Ain't Got That Swing)<br />     New York, New York<br />     The Lady is a Tramp<br />--<br />==> [add] Blue Moon<br />Play 'Round Midnight<br />     It Don't Mean A Thing (If It Ain't Got That Swing)<br />     New York, New York<br />     The Lady is a Tramp<br />     Blue Moon<br />--<br />==> [remove] The Lady is a Tramp<br />Play 'Round Midnight<br />     It Don't Mean A Thing (If It Ain't Got That Swing)<br />     New York, New York<br />     Blue Moon<br />--<br />==> [clear]<br />Play</pre>This seems a good stopping point for tonight. Up tomorrow, I will explore the implications of undo in the command pattern when working with multiple kinds of receivers.<br /><br /><i>Play with tonight's code on DartPad: <a href="https://dartpad.dartlang.org/76a20d32a064697bbc8c">https://dartpad.dartlang.org/76a20d32a064697bbc8c</a>.</i><br /><br /><br /><br /><span style="color: #ccc">Day #29</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/non-trivial-undo-in-command-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/multiple-command-undos.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/lefsSNMkGfw" height="1" width="1" alt=""/>
