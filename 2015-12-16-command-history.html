---
title: 'Command History'
layout: post
published: '2015-12-16T22:55:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/eg_pI4xbwBI/command-history.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />So where does history get stored in the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>? The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> only mentions in passing that the "application" holds the history. I wound up putting history in the command invoker as I was experimenting. That it is looking like a mistake.<br /><br />The problem is my <a href="http://dartlang.org">Dart</a> invoker does more history management than it does invoking:<pre class=prettyprint>// Invoker<br />class Button {<br />  static List _history = [];<br />  static List _undoHistory = [];<br /><br />  String name;<br />  Command command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />    _history.add(command);<br />  }<br /><br />  static void undo() {<br />    var h = _history.removeLast();<br />    print("Undoing $h");<br />    h.undo();<br />    _undoHistory.add(h);<br />  }<br /><br />  static void redo() {<br />    var h = _undoHistory.removeLast();<br />    print("Re-doing $h");<br />    h.call();<br />    _history.add(h);<br />  }<br />}</pre>Do you see the code that actually invokes commands? Probably not without looking really close because of all those static methods.<br /><br />It's never a good sign if you have a bunch of static classes and properties like that. My code is begging me to extract it out into a separate class, which I do:<pre class=prettyprint>class History {<br />  List _undoCommands = [];<br />  List _redoCommands = [];<br /><br />  void add(Command c) {<br />    _undoCommands.add(c);<br />  }<br /><br />  void undo() {<br />    var h = _undoCommands.removeLast();<br />    print("Undoing $h");<br />    h.undo();<br />    _redoCommands.add(h);<br />  }<br />  void redo() {<br />    var h = _redoCommands.removeLast();<br />    print("Re-doing $h");<br />    h.call();<br />    _undoCommands.add(h);<br />  }<br />}</pre>With that, my button invoker is much, much nicer:<pre class=prettyprint>class Button {<br />  String name;<br />  Command command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />  }<br />}</pre>Now I need to figure out how to get commands into history. Do I alter the <code>press()</code> method of <code>Button</code> to return the command so that client code can store history or do I make the invoker responsible for storing history. I opt for the latter, mostly because I do not want to clutter up my client code with a call to <code>history.add()</code> for each button press.<br /><br />I do opt to convert the <code>History</code> class into a singleton and its <code>add()</code> method into a static method (static methods do have their place):<pre class=prettyprint>class History {<br />  // ...<br />  static final History _h = new History._internal();<br />  factory History() => _h;<br />  History._internal();<br /><br />  static void add(Command c) {<br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>There is never a reason for more than one history object, so a singleton makes sense. Converting the <code>add()</code> method to a static method is a judgment call, but I wanted to be able to invoked <code>History.add()</code> when adding to history in the invoker:<pre class=prettyprint>class Button {<br />  // ...<br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />    History.add(command);<br />  }<br />}</pre>With that, I can get access to the history singleton in my client code and use it to undo and redo commands as much as I like:<pre class=prettyprint><code>  var history = new History();<br /><br />  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br /><br />  history.undo();<br />  history.undo();<br />  history.redo();<br /><br />  print("\nRobot is now at: ${robot.location}");</code></pre>That does the trick as the robot code that responds to these commands moves three paces to the north (in response to three button-up presses), undoes two of those steps, then re-does one of the undoes:<pre class=prettyprint>$ ./bin/play_robot.dart                          <br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />Undoing Instance of 'MoveNorthCommand'<br />  I am moving Direction.SOUTH<br />Undoing Instance of 'MoveNorthCommand'<br />  I am moving Direction.SOUTH<br />Re-doing Instance of 'MoveNorthCommand'<br />  I am moving Direction.NORTH<br /><br />Robot is now at: 0, 2<br /></pre>For a grand total of 2 steps forward.<br /><br />I am reasonably happy with the resulting code, but there is another benefit to making this change. I can now treat history as a command receiver in the command pattern:<pre class=prettyprint><code>  // Receivers<br />  var robot = new Robot();<br />  var camera = robot.camera;<br />  var history = new History();<br /><br />  // ...<br />  var moveNorth = new MoveNorthCommand(robot),<br />    // ...<br />    undo = new UndoCommand(history),<br />    redo = new RedoCommand(history);<br /><br />  // Invokers<br />  var btnUp = new Button("Up", moveNorth);<br />  // ...<br />  var btnUndo = new Button("Undo", undo);<br />  var btnRedo = new Button("Redo", redo);<br /><br />  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br /><br />  btnUndo.press();<br />  btnUndo.press();<br />  btnRedo.press();<br /><br />  print("\nRobot is now at: ${robot.location}");</code></pre>The undo/redo commands only need to store the history instance so that they can call the appropriate action in response to a button press:<pre class=prettyprint>class UndoCommand implements Command {<br />  History history;<br />  UndoCommand(this.history);<br />  void call() { history.undo(); }<br />}</pre>That history is itself a command now feels like a nice symmetry. In addition to the improved command implementation, I realize that I have an unfortunate habit of using static methods when writing exploratory code. I need to watch that or I am going to get myself intro trouble one of these days. But for today, I am safe.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/87111ba94d21ac059a42">https://dartpad.dartlang.org/87111ba94d21ac059a42</a>.</i><br /><br /><br /><span style="color: #ccc">Day #35</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/redo-command.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/eg_pI4xbwBI" height="1" width="1" alt=""/>
