---
title: 'Are Futures in Dart threads?'
layout: post
published: '2017-04-26T03:19:30+00:00'
feed: 'Stories by Matan Lurey on Medium'
link: 'https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a?source=rss-abdbfcd4679f------2'
author:
    name: 'Matan Lurey'
    email: null
    url: null
tags:
    - nodejs
    - threading
    - asynchronous
    - dartlang
    - javascript

---

<p>Well, <em>no</em>. Dart has a <a href="https://webdev.dartlang.org/articles/performance/event-loop">single thread, or event-loop</a>, of execution. However, commonly you’ll see a code using <em>Future</em> have a comment something to the effect of <em>“// Avoid race conditions: Check for …”</em>. What does that mean?</p><blockquote><strong>New to futures?</strong> Read <a href="https://www.dartlang.org/tutorials/language/futures">asynchronous programming: Futures</a> on the Dart site.</blockquote><p>While <em>Dart</em> has a single thread of execution, it can interact with other code (Dart or otherwise, such as server-side) that runs in a separate thread. What <em>Future&lt;T&gt;</em> as an API means is simply “<em>get a value, T, at a future point in time</em>”. That time? It could be at the end of the microtask loop, it could be after a second, after a file is read from disk, after an RPC completes. It could also be never (due to a timeout, for example).</p><blockquote>You can review <a href="https://github.com/matanlurey/dart-future-examples">all of the examples in this blog post on GitHub</a>.</blockquote><p>Let’s introduce a simple example:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/dec2aec5853ad753c7d4e65acbd4f46d/href">https://medium.com/media/dec2aec5853ad753c7d4e65acbd4f46d/href</a></iframe><p>We print the string “1”, “2”, “3”, and “4” — seemingly in order, but in reality it will print “1”, “4”, “2”, and “3”. That’s because “1” is printed <em>synchronously</em>, while “2” is printed at the end of the <em>microtask loop</em>, and “3” is printed a future <em>event loop.</em></p><p>You can also use the <em>Completer</em> API to adapt a non-<em>Future</em> API:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/d8fdaa59db55c8f8e4c2c59b5f2ca5b5/href">https://medium.com/media/d8fdaa59db55c8f8e4c2c59b5f2ca5b5/href</a></iframe><h3>But, what about <a href="https://api.dartlang.org/stable/1.23.0/dart-isolate/dart-isolate-library.html">Isolates</a>?</h3><p>Dart is able to spawn standalone processes, called <em>Isolates </em>(web workers in dart2js), which do not share memory when the main program, but are able to asynchronously, in another process (effectively a thread of sorts) is able to do computations without blocking the main thread.</p><p>In the below example we compute the fibonacci sequence twice — once synchronously in the same thread — and once asynchronously in another isolate.</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/b36bab643e642813268f4209f41bf0db/href">https://medium.com/media/b36bab643e642813268f4209f41bf0db/href</a></iframe><p>In this example, <em>Future</em> is still used — it just means “will execute in the future”, remember? In this case, we spawn another isolate, ask it to compute, and the future completes when we have a result. If, for example, your computer was under heavy load it could take a little while.</p><p>Seem confusing? The <em>isolate</em> API is fairly low-level. When using in your own code I’d recommend looking at <a href="https://pub.dartlang.org/packages/isolate">package:isolate</a> or the <a href="https://www.dartdocs.org/documentation/stream_channel/1.6.1/stream_channel/IsolateChannel-class.html"><em>IsolateChannel</em> class from package:stream_channel</a>.</p><p>How about another example, this time file I/O. We can <em>simulate</em> the difference between <a href="https://api.dartlang.org/stable/1.23.0/dart-io/File/readAsStringSync.html">File#readAsStringSync</a> and <a href="https://api.dartlang.org/stable/1.23.0/dart-io/File/readAsString.html">File#readAsString</a> ourselves using an Isolate:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/f94be39a9e7238f68937f0066dc94a3d/href">https://medium.com/media/f94be39a9e7238f68937f0066dc94a3d/href</a></iframe><p>In this case we read <em>“file.json”</em> three times — once synchronously, once asynchronously (i.e. in another thread managed by the Dart VM), and finally once more synchronously, but in another isolate.</p><p>Since Dart 1.22.0, we’ve introduced a limited union type, <a href="https://api.dartlang.org/stable/1.22.1/dart-async/FutureOr-class.html"><em>FutureOr&lt;T&gt;</em></a> — which represents either <em>Future&lt;T&gt;</em> or <em>T.</em> It’s valid in the type system to have either. As an example, take a look at caching the result of a future:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/e16cf70783e860c489fb5d515b7e5aa8/href">https://medium.com/media/e16cf70783e860c489fb5d515b7e5aa8/href</a></iframe><p>I hope you enjoyed this short blog post, and if you have any questions about using futures or the asynchronous API in Dart leave a comment here or on twitter. Thanks!</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=2cdc5bd8063a" width="1" height="1"><hr><p><a href="https://hackernoon.com/are-futures-in-dart-threads-2cdc5bd8063a">Are Futures in Dart threads?</a> was originally published in <a href="https://hackernoon.com">Hacker Noon</a> on Medium, where people are continuing the conversation by highlighting and responding to this story.</p>
