---
title: 'The Adapter and the Dependency Inversion Principle'
layout: post
published: '2016-01-08T22:40:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/2jbsPNLeqpw/the-adapter-and-dependency-inversion.html'
author:
    name: Anonymous
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/00135361916531185929'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'dependency inversion principle'
    - 'design patterns'

---

<div class=top-chain-links></div><br />The best code believes the Earth to be flat. Possibly balanced on the backs of 4 largish elephants riding a giant turtle through space.<br /><br />As far as a flat earther is concerned, travelling from Prudhoe Bay Alaska to Cape Horn is literally a straight shot from the center of our disc world to the edge. And for 99% of human thinking on travel that is just fine — certainly better than calculating the distance along a 120° arc over the surface of a sphere with a radius of 6400 km. Earth roundness is important to airlines, astronauts, and spy satellites, but most daily human existence works just fine on a flat earth. In other words, a flat earth is a useful abstraction.<br /><br />That abstraction would work equally as well on the Moon or other planets. We would think of it as a flat planet abstraction on Mars or Jupiter, but the principle would be the same. And regardless of the celestial body on which we currently reside, we would think that our current home <i>is a</i> flat planet. That is, we would not think that flat planet is a collection of things, some of which behave slightly more or slightly less flat. Each planet that we visit would be a flat planet in our minds.<br /><br />All of this is to say that flat earthers have the <a href="https://en.wikipedia.org/wiki/Dependency_inversion_principle">dependency inversion principle</a> down cold—well, as long as they don't <i>really</i> believe what they preach. The dependency inversion principle states:<ol><li>High-level modules should not depend on low-level modules. Both should depend on abstractions.</li><li>Abstractions should not depend on details. Details should depend on abstractions.</li></ol>For me, it helps to mentally replace "not depend" with "be willfully ignorant of." High level modules should be willfully ignorant of low-level modules. Instead of thinking about the curve of the planet as we travel, modules should flat-earth things. Similarly, the low-level details should fit the abstraction, but the abstraction should be willfully ignorant of the details of individual planets.<br /><br />All of this brings me back to the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a>. I have been playing with this pattern in <a href="http://dartlang.org">Dart</a> for the past week or so, and having an octarine time of it. Before moving on, it is worth noting that the adapter pattern is a way to support dependency inversion.<br /><br />My universal robot remote control example holds the high-level module stuff in the remote control. Given a robot, the remote control wants to be able to move said robot forward as much as it likes:<pre class=prettyprint><code>  universalRobot = new UniversalRemoteRobot(robot);<br />  universalRobot<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward();</code></pre>According to the dependency inversion principle, the remote should be willfully ignorant of the robot details. The universal remote control will have to control hundreds of different kinds of robots (lest they control us). As such, the remote control code has to willfully ignorant of the differences between Oscorp and Tyrell robots. A remote control that knows the tiny details of a hundred robots would require huge amounts of code.<br /><br />So instead, the remote thinks of every single different kind of robot as an abstraction. That abstraction is the target in the adapter pattern:<pre class=prettyprint>/*** Target ***/<br />abstract class Ubot {<br />  String get xyLocation;<br />  void moveForward();<br />  void moveBackward();<br />  void moveLeft();<br />  void moveRight();<br />}</pre>As far as the remote is concerned, all robots can move forward, backward, to the left and to the right. As long as all robots implemented this interface, we would be done as far as the dependency inversion principle was concerned: the high-level remote control treats robots as the abstraction defined in the abstract class, the remote control is willfully ignorant of the robot details, the abstract class is willfully ignorant of the robot details as well, and the individual robots would implement the abstraction.<br /><br />But that is not the end of the story in this case. The Tyrell Corporation refuses to implement the same robot interface as does Oscorp, so another class is required to <i>adapt</i> each individual robot to our <code>Ubot</code> interface:<pre class=prettyprint>/*** Adapters ***/<br />class RobotAdapterToUbot implements Ubot {<br />  Robot _robot;<br />  RobotAdapterToUbot(this._robot);<br /><br />  String get xyLocation => _robot.location;<br /><br />  void moveForward()  { _robot.move(Direction.NORTH); }<br />  void moveBackward() { _robot.move(Direction.SOUTH); }<br />  void moveLeft()     { _robot.move(Direction.WEST); }<br />  void moveRight()    { _robot.move(Direction.EAST); }<br />}</pre>This class is very much aware of the <code>Ubot</code> abstraction. As a low-level detail, it should be. At the same time, it does not flat-earth the <code>Robot</code> class. Its whole purpose is to adapt the low-level <code>Robot</code> to the abstraction. So if this adapter class cannot flat-earth <code>Robot</code>, doesn't it violate dependency inversion?<br /><br />Well no. This is not a violation because the adapter and the robot are both low-level objects. In fact, they are at the same level, with the adapter serving as a thin wrapper for the adaptee.<br /><br />I am glad to have noodled this through. I have yet to determine how to deal with concepts like the dependency inversion principle in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. Do I include a separate chapter? Do I mention them in passing while discussing other patterns? I cannot flat-earth that, lest the book be incomplete. Regardless, it was fun looking at the relationship between the adapter pattern and the dependency inversion principle. <br /><br />Or as some might put it, "Ook."<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/5a8d96b4825f9cdc6085">https://dartpad.dartlang.org/5a8d96b4825f9cdc6085</a>.</i><br /><br /><br /><span style="color: #ccc">Day #58</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/delegating-mirrors-might-make-me-cry.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/a-simple-proxy-pattern-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/2jbsPNLeqpw" height="1" width="1" alt=""/>
