---
title: 'Unboxing Packages: async Part 2'
layout: post
published: '2016-03-23T14:54:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p><a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html">Two weeks ago</a>, I introduced you to some of the marvels available for use in the <a href="https://pub.dartlang.org/packages/async"><code>async</code></a> package. But that package is so big—there are so many marvels—that I couldn’t fit them all in. In fact, I only ended up writing about APIs that deal with futures and the individual values they represent.</p> <p>This week I’ll focus on the other major asynchronous type: <code>Stream</code>. I often find it useful to think of asynchronous types as analogous to synchronous ones, and by that metaphor if futures are individual values then streams are <code>Iterable</code>s. But in addition to representing asynchronously-computed collections of data, streams can represent things like UI events or communication (for example over a <code>WebSocket</code>).</p> <p>Dart’s <code>Stream</code> class is very powerful. In addition to dispatching events, it allows the user to <a href="https://api.dartlang.org/stable/latest/dart-async/StreamSubscription/pause.html">pause</a> or <a href="https://api.dartlang.org/stable/latest/dart-async/StreamSubscription/cancel.html">cancel</a> their subscription to the stream. What’s more, the creator of the stream can be notified of pauses or cancellations (or the initial subscriptions) and take appropriate action—like closing an HTTP connection when its data stream is canceled. Building this logic into the core types makes it easy to do the right thing with streams without the author having to think about it at all.</p> <p>For example, <a href="https://api.dartlang.org/stable/latest/dart-async/Stream/first.html"><code>Stream.first</code></a> automatically cancels its subscription once the first event arrives. So if you call <a href="https://api.dartlang.org/stable/latest/dart-io/WebSocket-class.html"><code>WebSocket.first</code></a>, it’ll close the underlying connection once you have the event you need.</p> <p>The other side of this power, though, is that you need to take extra care when writing code that manipulates streams to ensure that you handle pausing and canceling correctly. If your <a href="https://api.dartlang.org/stable/latest/dart-async/StreamTransformer-class.html">stream transformer</a> doesn’t forward cancellations properly, you might end up with dangling WebSocket connections, which is bad news all around.</p> <p>That’s why <code>async</code>’s stream utilities are so useful. Not only do they help you manipulate your streams, they make sure all your listens, pauses, and cancellations are handled exactly right. I call this being <em>cancel-correct</em>. This gives you, the developer, freedom to hook up components as you need without worrying about any extra complexity.</p>   <h2 id="lazystream"><code>LazyStream</code></h2> <p>I mentioned briefly that stream creators can be notified when an initial stream subscription is created. You can pass an <code>onListen</code> argument to <a href="https://api.dartlang.org/stable/1.15.0/dart-async/StreamController/StreamController.html"><code>new StreamController()</code></a> to only start emitting events once a listener exists. And usually that’s enough—but sometimes you aren’t the one producing the original events, and you don’t want to have to manually forward them to the controller. That’s what <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/LazyStream-class.html"><code>LazyStream</code></a> is for.</p> <p>When you call <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/LazyStream/LazyStream.html"><code>new LazyStream()</code></a>, you pass in a callback that returns a <code>Stream</code> (or a <code>Future&lt;Stream&gt;</code>). This callback will only be invoked once the <code>LazyStream.listen</code> is called, and its events will automatically be piped to the listen handlers. Most of the time it won’t even create an intermediate <code>StreamController</code>, so it’s extra efficient, too.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Returns the contents of the getting [url].</span><span class="pln"><br /></span><span class="com">///</span><span class="pln"><br /></span><span class="com">/// Only starts the request when the returned stream is listened to.</span><span class="pln"><br /></span><span class="typ">Stream</span><span class="pun">&lt;</span><span class="typ">List</span><span class="str">&lt;int&gt;</span><span class="pun">&gt;</span><span class="pln"> httpStream</span><span class="pun">(</span><span class="typ">Uri</span><span class="pln"> url</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">LazyStream</span><span class="pun">&lt;</span><span class="typ">List</span><span class="str">&lt;int&gt;</span><span class="pun">&gt;(()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> client </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">HttpClient</span><span class="pun">();</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> request </span><span class="pun">=</span><span class="pln"> await client</span><span class="pun">.</span><span class="pln">getUrl</span><span class="pun">(</span><span class="typ">Uri</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">url</span><span class="pun">));</span><span class="pln"><br />    </span><span class="kwd">return</span><span class="pln"> await request</span><span class="pun">.</span><span class="pln">close</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <h2 id="streamcompleter"><code>StreamCompleter</code></h2> <p>If you’ve done much asynchronous programming in Dart, you’re doubtless familiar with the <a href="https://api.dartlang.org/stable/latest/dart-async/Completer-class.html"><code>Completer</code></a> class. It lets you return a future immediately but only fill in its result later on when whatever asynchronous work you’re doing is finished. Well, a <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamCompleter-class.html"><code>StreamCompleter</code></a> is pretty much the same thing for streams.</p> <p><a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamCompleter/stream.html"><code>StreamCompleter.stream</code></a> returns a stream immediately, just like <code>Completer.future</code>. But this stream doesn’t emit any events until you call <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamCompleter/setSourceStream.html"><code>setSourceStream()</code></a>, which—like <code>Completer.complete()</code>—provides the concrete value. All events from the source stream are forwarded to the output stream, and of course pauses and cancellations are passed back to the source.</p> <p>What if you fail to get the source stream? Call <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamCompleter/setError.html"><code>setError()</code></a> instead! Like <code>Completer.completeError</code>, this indicates that the stream completion was unsuccessful. In a more practical sense, it makes the output stream emit the error and then close immediately.</p> <p>The whole process of getting a stream’s value asynchronously sounds a lot like a <code>Future&lt;Stream&gt;</code>. There are even a few places, like <a href="https://api.dartlang.org/stable/latest/dart-io/WebSocket/connect.html"><code>WebSocket.connect()</code></a>, which return such futures in practice. That’s why the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamCompleter/fromFuture.html"><code>StreamCompleter.fromFuture()</code></a> static utility function exists. It just takes a <code>Future&lt;Stream&gt;</code> and returns a <code>Stream</code>:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="typ">Stream</span><span class="pln"> fromFuture</span><span class="pun">(</span><span class="typ">Future</span><span class="pun">&lt;</span><span class="typ">Stream</span><span class="pun">&gt;</span><span class="pln"> streamFuture</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> completer </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamCompleter</span><span class="pun">();</span><span class="pln"><br />  streamFuture</span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">completer</span><span class="pun">.</span><span class="pln">setSourceStream</span><span class="pun">,</span><span class="pln"><br />      onError</span><span class="pun">:</span><span class="pln"> completer</span><span class="pun">.</span><span class="pln">setError</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> completer</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>In some cases—especially when you want to use async/await—it’s way easier to just use <code>fromFuture()</code> than to manually deal with a <code>StreamCompleter</code> yourself.</p> <h2 id="streamgroup"><code>StreamGroup</code></h2> <p>I think of <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamGroup-class.html"><code>StreamGroup</code></a> kind of like a funnel: it takes a bunch of different input streams and merges them all into a single output stream. Like <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/FutureGroup-class.html"><code>FutureGroup</code></a>, which I wrote about <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html#futuregroup">last time</a>, it implements <code>Sink</code>. This means that you call <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamGroup/add.html"><code>add()</code></a> to add new streams to the group, and <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamGroup/close.html"><code>close()</code></a> once you’ve added all the streams that need adding.</p> <p>The events from the input streams are piped into the output stream, which is accessible by calling <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamGroup/stream.html"><code>stream</code></a>. This stream will only close once all the input streams close <em>and</em> <code>close()</code> is called, because otherwise more streams may still be added later on. And of course, it’s cancel-correct: it only listens to the source streams once the output stream has a listener, and if the output stream is paused or canceled then all the source streams are as well.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Phase</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> _transformers </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">Transformer</span><span class="pun">,</span><span class="pln"> </span><span class="typ">TranformerRunner</span><span class="pun">&gt;{};</span><span class="pln"><br /><br />  </span><span class="com">/// A broadcast stream of all log events from all transformers in this phase.</span><span class="pln"><br />  </span><span class="typ">Stream</span><span class="pun">&lt;</span><span class="typ">LogEvent</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> onLog </span><span class="pun">=&gt;</span><span class="pln"> _onLogGroup</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> _onLogGroup </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamGroup</span><span class="pun">&lt;</span><span class="typ">LogEvent</span><span class="pun">&gt;.</span><span class="pln">broadcast</span><span class="pun">();</span><span class="pln"><br /><br />  </span><span class="kwd">void</span><span class="pln"> addTransformer</span><span class="pun">(</span><span class="typ">Transformer</span><span class="pln"> transformer</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> runner </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">TransformerRunner</span><span class="pun">(</span><span class="pln">transformer</span><span class="pun">);</span><span class="pln"><br />    _transformers</span><span class="pun">[</span><span class="pln">transformer</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> runner</span><span class="pun">;</span><span class="pln"><br />    _onLogGroup</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">runner</span><span class="pun">.</span><span class="pln">onLog</span><span class="pun">);</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>If you don’t care about adding streams later on, you can also use the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamGroup/merge.html"><code>StreamGroup.merge()</code></a> static utility function. This just takes an <code>Iterable&lt;Stream&gt;</code> and merges all the streams immediately. It’s the same as adding them all to a <code>StreamGroup</code> and closing it, but it’s a lot cleaner than doing that manually. That’s why we call it a utility function!</p> <h2 id="streamsplitter"><code>StreamSplitter</code></h2> <p>If <code>StreamGroup</code> is a funnel, then <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSplitter-class.html"><code>StreamSplitter</code></a> is a sprinkler: it takes a single source stream and splits it into a bunch of identical copies. Each copy independently emits the same events as the source stream, with its own buffering and everything. There’s no way at all for actions on one copy to affect any others.</p> <p>A splitter is created by passing the source stream to <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSplitter/StreamSplitter.html"><code>new StreamSplitter()</code></a>, and copies are created by calling <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSplitter/split.html"><code>split()</code></a>. Once you don’t need any more copies, call <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSplitter/close.html"><code>close()</code></a> to let the splitter know.</p> <p>Closing the splitter lets it maintain cancel-correctness. Before it’s closed, it can never safely cancel or pause the source stream, since a new copy could be created that might need additional events. But once it’s closed, the source stream can be canceled as soon as all of the copies are canceled.</p> <p>Like <code>StreamGroup.merge()</code>, there’s a handy utility method for splitting streams: <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSplitter/splitFrom.html"><code>StreamSplitter.splitFrom()</code></a>. This takes a source stream and splits it into a set number of copies—two by default, but it can be any number you want. I use it pretty frequently when I’m debugging to see what a stream is emitting without affecting its normal usage.</p>   <h2 id="subscriptionstream"><code>SubscriptionStream</code></h2> <p>Some APIs are made for end-users to use directly in their applications, and some are made for implementing other APIs. The <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/SubscriptionStream-class.html"><code>SubscriptionStream</code></a> class falls squarely into the latter category. It’s used internally in the <code>async</code> package itself, and it’s good to know about in case you ever need to implement some asynchronous utilities yourself.</p> <p>When you call <a href="https://api.dartlang.org/stable/1.15.0/dart-async/Stream/listen.html"><code>Stream.listen()</code></a> to subscribe to a stream, you get a <a href="https://api.dartlang.org/stable/1.15.0/dart-async/StreamSubscription-class.html"><code>StreamSubscription</code></a> back. This is usually just used to pause and cancel events, but it can also be used to replace the event handlers by calling methods like <a href="https://api.dartlang.org/stable/1.15.0/dart-async/StreamSubscription/onData.html"><code>onData()</code></a><a href="#fn:1" id="fnref:1" title="See footnote" class="footnote">1</a>. <code>SubscriptionStream</code> takes advantage of this capability to convert a subscription into a brand new stream that can itself be listened to.</p> <p>When you pass a subscription into <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/SubscriptionStream/SubscriptionStream.html"><code>new SubscriptionStream()</code></a>, its old event handlers are removed and it’s paused. This means any additional events are buffered until the <code>SubscriptionStream.listen()</code> is called. Once it is, it sets the new handlers on the original subscription and just returns that. Most of the time it doesn’t even create any extra intermediate objects!</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Calls [onFirst] with the first event emitted by [source].</span><span class="pln"><br /></span><span class="com">///</span><span class="pln"><br /></span><span class="com">/// Returns a stream that emits all events in [source] after the first.</span><span class="pln"><br /></span><span class="typ">Stream</span><span class="pln"> firstAndRest</span><span class="pun">(</span><span class="typ">Stream</span><span class="pln"> source</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onFirst</span><span class="pun">(</span><span class="pln">value</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> completer </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamCompleter</span><span class="pun">();</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> subscription</span><span class="pun">;</span><span class="pln"><br />  subscription </span><span class="pun">=</span><span class="pln"> source</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">((</span><span class="kwd">event</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    onFirst</span><span class="pun">(</span><span class="kwd">event</span><span class="pun">);</span><span class="pln"><br />    completer</span><span class="pun">.</span><span class="pln">setSourceStream</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">SubscriptionStream</span><span class="pun">(</span><span class="pln">subscription</span><span class="pun">));</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> completer</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h2 id="await-last"><code>await last</code></h2> <p>This about covers the <code>async</code> package’s stream APIs, but there are other APIs still to come. The package has a lot of cool stuff! Join me again in two weeks when I cover everything else, sinks and queues and timers and all.</p><div class="footnotes"><hr><ol><li id="fn:1">This method should really be called <code>setOnData()</code>, or else should be a setter with a corresponding getter, but it’s hard to change APIs in the core libraries. <a href="#fnref:1" title="Return to article" class="reversefootnote">↩</a></li></ol></div>
