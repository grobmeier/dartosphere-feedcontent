---
title: 'The Polymer.dart ComputedProperty Annotation'
layout: post
published: '2014-08-04T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/5pBASP1Z__Y/the-polymerdart-computedproperty.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - annotations
    - chain
    - dart
    - dartlang
    - polymer

---

<div class=top-chain-links></div><br />The new annotations in <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a> are… interesting. <br /><br />As best I can tell, the purpose behind them is mostly to ensure that the values that they annotate are available regardless of when they are accessed. To better understand that, I need to explore timing accessors. But first, I would like to complete the new annotation tour with a look at <code>@ComputedProperty</code>.<br /><br />The old way of creating a setting property, for example the number of toppings on a particular side of the <code>&lt;x-pizza></code> element, might look something like:<pre class=prettyprint>@CustomTag('x-pizza-toppings')<br />class XPizzaToppings extends PolymerElement {<br />  // ...<br /><b>  int get numToppings => model.length;</b><br />  // ...<br />}</pre>That is a nice, straight-forward getter method. How could <code>@ComputedValue</code> possibly improve on that?<br /><br />To answer that question, I renamed the “old” way of setting a computed property as <code>numToppings_old</code> and re-implement <code>numToppings</code> with <code>@ComputedProperty</code>:<pre class=prettyprint>@CustomTag('x-pizza-toppings')<br />class XPizzaToppings extends PolymerElement {<br />  // ...<br /><b>  @ComputedProperty("model.length")<br />  int get numToppings => readValue(#numToppings);</b><br /><br />  int get numToppings_old => model.length;<br />  // ...<br />}</pre>I have to admit that there is some pretty cool meta programming going on in there. The <code>@ComputedProperty</code> annotation declares that the next getter is obtained via the Polymer expresssion of <code>model.length</code>. Then, the <code>readValue()</code> method works in conjunction with this annotation to compute the property value. It seems a little strange to repeat <code>numToppings</code> like that—once to declare the name of the computed property and once as a symbol argument to <code>readValue()</code>. My guess is that this is a limitation of annotations—that even though <code>@ComputedProperty</code> is able to associate its argument with the getter immediately below it, <code>readValue()</code> is not able to do the same.<br /><br />The end result is seemingly unnecessary indirection and the slight DRY violation. So is it worth it?<br /><br />To answer, I update the containing <code>&lt;x-pizza></code> element to print both the new and old ways of computing the property:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  XPizzaToppings get firstHalf => $['firstHalfToppings'];<br />  XPizzaToppings get secondHalf => $['secondHalfToppings'];<br />  XPizzaToppings get whole => $['wholeToppings'];<br /><br />  updatePizzaState([_]) {<br /><b>    print("First half: ${firstHalf.numToppings} (${firstHalf.numToppings_old})");<br />    print("Second half: ${secondHalf.numToppings} (${secondHalf.numToppings_old})");<br />    print("Whole: ${whole.numToppings} (${whole.numToppings_old})");</b><br />  }<br />  // ...<br />}<br /></pre>The result when loading <code>&lt;x-pizza></code>? Both values are identical:<pre class=prettyprint>First half: 0 (0)<br />Second half: 0 (0)<br />Whole: 0 (0) </pre>And, when I update the toppings… Both computed properties are identical for all toppings:<pre class=prettyprint>First half: 2 (2)<br />Second half: 1 (1)<br />Whole: 2 (2)<br /></pre>So I am a little at loss to explain why I might want to use the <code>@ComputedValue</code> instead of the more concise, simple getter format that I have been using all along.<br /><br />My understanding for the inspiration behind the new annotation is that, without them, timing issues can arise. I probably need to come up with a better way to produce such issues, but my first inclination is to try to access the properties when the parent <code>&lt;x-pizza></code> element is first created:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br /><b>  XPizza.created(): super.created() {<br />    print("[ctor] First half: ${firstHalf.numToppings} (${firstHalf.numToppings_old})");<br />    print("[ctor] Second half: ${secondHalf.numToppings} (${secondHalf.numToppings_old})");<br />    print("[ctor] Whole: ${whole.numToppings} (${whole.numToppings_old})");<br />  }</b><br />  // ...<br />}</pre>But even that produces valid results:<pre class=prettyprint>[ctor] First half: 0 (0)<br />[ctor] Second half: 0 (0)<br />[ctor] Whole: 0 (0)</pre>There must be a use-case in which these annotations come in handy, but this is clearly not one of them.<br /><br />I have a decent handle on how to use the new annotations in Polymer.dart at this point. Tomorrow I will dig through some unit tests to see if I can better understand <i>when</i> to use them. <br /><br /><br /><span style="color: #ccc">Day #143</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/08/the-publishedproperty-polymer-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/08/i-remain-somewhat-confused-about.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/5pBASP1Z__Y" height="1" width="1"/>
