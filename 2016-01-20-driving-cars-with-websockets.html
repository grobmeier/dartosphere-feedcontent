---
title: 'Driving Cars with Websockets'
layout: post
published: '2016-01-20T22:37:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/weP6spuSXpw/driving-cars-with-websockets.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'
    - websockets

---

<div class=top-chain-links></div><br /><a href="https://api.dartlang.org/1.13.2/dart-isolate/dart-isolate-library.html">Isolates</a> look unlikely to serve as a teachable implementation for the remote <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> in <a href="http://dartlang.org">Dart</a>. They are relatively simple, but still remain a tad too cumbersome. Last night's exploration of simple streams shows promise, begging the question of how another stream might workâ€”websockets.<br /><br />I borrow (OK, steal verbatim) the example websocket server from the <a href="https://dart-lang.github.io/server/server.html">Dart on the server example</a>:<pre class=prettyprint>#!/usr/bin/env dart<br /><br />import 'dart:async';<br />import 'dart:io';<br /><br />handleMsg(msg) {<br />  print('Message received: $msg');<br />}<br /><br />main() {<br />  runZoned(() async {<br />    var server = await HttpServer.bind('localhost', 4040);<br />    await for (var req in server) {<br />      if (req.uri.path == '/ws') {<br />        // Upgrade a HttpRequest to a WebSocket connection.<br />        var socket = await WebSocketTransformer.upgrade(req);<br />        socket.listen(handleMsg);<br />      };<br />    }<br />  },<br />  onError: (e) => print("An error occurred: $e"));<br />}</pre>I will add my proxy pattern code shortly. For now, I just want to ensure that it works. I save this as <code>bin/server.dart</code>, <code>chmod 755</code> and start it up with <code>./bin/server.dart</code>. Nothing crashes, so I assume that I am good to go.<br /><br />In my existing proxy pattern script, I add the appropriate websocket client code:<pre class=prettyprint>#!/usr/bin/env dart<br /><br />import 'dart:async';<br />import 'dart:io';<br /><br />main() async {<br />  var socket = await WebSocket.connect('ws://localhost:4040/ws');<br />  socket.add('Hello, World!');<br />  // ...<br />}</pre>That should connect to my running websocket server and add a message to the websocket stream to which the server is currently listening. When I run this client script, I see the following message from the server:<pre class=prettyprint>$ ./bin/server.dart<br />Message received: Hello, World!</pre>Nice! Web sockets were never all that hard in Dart, but they are getting close to trivial.<br /><br />So what is it going to take to convert my <code>ProxyCar</code> from streams (which were converted last night from isolates) to websockets? Blood sacrifice? The answer is surprisingly little.<br /><br />In my client code, I continue to open the websocket, pass that to a <code>ProxyCar</code>, then perform some remote car operations:<pre class=prettyprint>main() async {<br />  var socket = await WebSocket.connect('ws://localhost:4040/ws');<br /><br />  ProxyCar car = new ProxyCar(socket);<br /><br />  print("Attempting to drive remote car...");<br />  await car.drive();<br />  print("Car is ${car.state}");<br /><br />  print("--");<br /><br />  print("Attempting to stop remote car...");<br />  await car.stop();<br />  print("Car is ${await car.state}");<br />}</pre>The <code>ProxyCar</code> is responsible for listening to this websocket for state responses from the real car. I establish that listener in the constructor:<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  Stream _socket, _broadcast;<br />  String _state;<br /><br />  ProxyCar(this._socket) {<br />    _broadcast = _socket.asBroadcastStream();<br />    _broadcast.listen((message) {<br />      _state = message;<br />    });<br />  }<br />  // ...<br />}</pre>I get a broadcast version of the websocket so that I can listen to it in multiple locations. Here, I listen for state updates. When I send action messages to the real car, I also listen to the stream for confirmation that the message was received:<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  Stream _socket, _broadcast;<br />  String _state;<br />  // ...<br />  String get state => _state;<br />  Future drive() => _send('drive');<br />  Future stop()  => _send('stop');<br /><br />  Future _send(message) {<br />    _socket.add(message);<br />    return _broadcast.first;<br />  }<br />}</pre>I may reconsider that at some point, just for ease of discussion. For now, I leave it as-is.<br /><br />The server is using the same library. Instead of the <code>ProxyCar</code> instance, it works with the real subject in this pattern: an <code>AsynCar</code> instance:<pre class=prettyprint><code>      // ...<br />      if (req.uri.path == '/ws') {<br />        // Upgrade a HttpRequest to a WebSocket connection.<br />        var socket = await WebSocketTransformer.upgrade(req);<br />        new AsyncCar(socket);<br />      };<br />      // ...</code></pre>Like the <code>ProxyCar</code>, the <code>AsyncCar</code> implements the <code>AsyncAuto</code> interface:<pre class=prettyprint>// Subject<br />abstract class AsyncAuto implements Automobile {<br />  String get state;<br />  Future drive();<br />  Future stop();<br />}</pre>If anything, the <code>AsyncCar</code> real subject is even simpler than the proxy:<pre class=prettyprint>class AsyncCar implements AsyncAuto {<br />  Stream _socket;<br />  Car _car;<br /><br />  AsyncCar(this._socket) {<br />    _car = new Car();<br /><br />    _socket.listen((message) {<br />      print("[AsyncCar] received: $message");<br />      if (message == 'drive') _car.drive();<br />      if (message == 'stop')  _car.stop();<br />      _socket.add(state);<br />    });<br />  }<br /><br />  String get state => _car.state;<br />  Future drive() => new Future((){ _car.drive(); });<br />  Future stop()  => new Future((){ _car.stop(); });<br />}</pre>It adapts a synchronous <code>Car</code>, which it manipulates in response to messages that it receives from the socket. If the websocket message is <code>'drive'</code>, then the <code>car</code> instance is sent the drive message. If the websocket see <code>'stop'</code>, <code>stop()</code> is invoked on <code>car</code>.<br /><br />And that actually works. Running the client code results in:<pre class=prettyprint>$ ./bin/drive.dart<br />Attempting to drive remote car...<br />Car is driving<br />--<br />Attempting to stop remote car...<br />Car is idle</pre>Checking the server output, I see:<pre class=prettyprint>$ ./bin/server.dart<br />[AsyncCar] received: drive<br />[AsyncCar] received: stop</pre>So there you have it. I can drive a car over websockets with Dart. And it was pretty darn easy!<br /><br /><br /><span style="color: #ccc">Day #70</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/faking-dart-isolates-for-proxy-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/weP6spuSXpw" height="1" width="1" alt=""/>
