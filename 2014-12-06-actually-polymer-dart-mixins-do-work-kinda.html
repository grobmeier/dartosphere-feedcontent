---
title: 'Actually, Polymer Dart Mixins Do Work (Kinda)'
layout: post
published: '2014-12-06T23:59:00-05:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/ru2ghP_YfNk/i-may-have-given-up-prematurely-on-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - mixins
    - polymer

---

<div class=top-chain-links></div><br />I may have given up prematurely on <a href="http://dartlang.org">Dart</a> mixins with <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a> code. I still do not believe that it will work well enough that I would use mixins often, but maybe in certain specialized cases. If nothing else, I am curious to find the minimum viable <a href="http://www.polymer-project.org/">Polymer</a> mixin that can work.<br /><br />As suggested in the comments from last night's post, I start by commenting out the <code>@PublishedProperty</code> Polymer annotations from my mixin class:<pre class=prettyprint>library a_form_input;<br /><br />abstract class AFormInputMixin {<br />  // @PublishedProperty(reflect: true)<br />  String name;<br /><br />  // @PublishedProperty(reflect: true)<br />  String value;<br /><br />  // More code to go here...<br />}<br /></pre>The goal of this mixin is to enable arbitrary Polymer elements to work in native HTML forms, hence the need for <code>name</code> and <code>value</code> properties and attributes. <br /><br />I still need both <code>name</code> and <code>value</code> to be published by my concrete Polymer that mixes this in, but as I found last night, I cannot use this annotation in my mixin class. Instead, I have to declare the instance variables in the mixin (so that it can reference them), but mark them to be published in the concrete class, in this case my <code>&lt;x-pizza></code> element:<pre class=prettyprint>import 'package:polymer/polymer.dart';<br /><br />import 'package:a-form-input/a_form_input_mixin.dart';<br />// import 'package:a-form-input/a_form_input.dart';<br /><br />@CustomTag('x-pizza')<br />class XPizza extends PolymerElement with AFormInputMixin {<br />// class XPizza extends AFormInput {<br /><br />  @PublishedProperty(reflect: true)<br />  String name;<br /><br />  @PublishedProperty(reflect: true)<br />  String value;<br />  // More code here...<br />}</pre>And that actually works. At least, the code both compiles and runs in the browser, which is more than I was able to accomplish last night.<br /><br />I still do not have the desired functionality in my <code>&lt;a-form-input></code> mixin, however. Specifically, I want the mixin to be responsible for injecting a hidden <code>&lt;input></code> element into the owner document and keep this hidden <code>&lt;input></code> in sync with the internal state of <code>&lt;x-pizza></code>:<pre class=prettyprint>library a_form_input;<br /><br />import 'dart:html' show HiddenInputElement;<br /><br />abstract class AFormInputMixin {<br />  // @PublishedProperty(reflect: true)<br />  String name;<br /><br />  // @PublishedProperty(reflect: true)<br />  String value;<br /><br />  Element lightInput;<br /><br /><b>  void attached() {<br />    lightInput = new HiddenInputElement();<br />    if (name != null) lightInput.name = name;<br />    parent.append(lightInput);<br /><br />    changes.listen((list){<br />      list.forEach((change) {<br />        if (change.name == #name) lightInput.name = change.newValue;<br />        if (change.name == #value) lightInput.value = change.newValue;<br />      });<br />    });<br />  }</b><br />}</pre>Annotating properties in the concrete class when they were declared in the mixin is pretty ugly, but as I found last night, there is no other option available to me.<br /><br />I am using the <code>attached()</code> Polymer lifecycle method above. When the Polymer element is attached to the DOM, this method is invoked. I have almost no hope that it will work however, because this is a mixin, not a superclass. The problem is that I would normally invoke this from the concrete class using inheritance via <code>super.attached()</code>:<pre class=prettyprint>import 'package:polymer/polymer.dart';<br /><br />import 'package:a-form-input/a_form_input_mixin.dart';<br /><br />@CustomTag('x-pizza')<br />class XPizza extends PolymerElement with AFormInputMixin {<br />  @PublishedProperty(reflect: true)<br />  String name;<br /><br />  @PublishedProperty(reflect: true)<br />  String value;<br />  // ...<br /><b>  void attached() {<br />    super.attached();<br />    // attachForm();<br />    _updateGraphic();<br />  }</b><br />  // ...<br />}</pre>I had expected that the concrete class would have to invoke a method from the mixin, such as <code>attachForm()</code>, but simply calling <code>super.attached()</code>… actually seems to work. The hidden <code>&lt;input></code> field is added to the containing document <i>and</i> the change listener even works:<br /><br /><a href="http://3.bp.blogspot.com/-LWGADPx4hek/VIPKNkgBkKI/AAAAAAAAh4E/MH8FU7Br3no/s1600/01-worky_mixin.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-LWGADPx4hek/VIPKNkgBkKI/AAAAAAAAh4E/MH8FU7Br3no/s400/01-worky_mixin.png" /></a><br /><br />When I update the <code>&lt;x-pizza></code> element, both the <code>&lt;x-pizza></code> attributes and the the hidden <code>&lt;input></code> attributes are updated. This even works if I use the <code>attributeChanged()</code> form of the listener in the <code>&lt;a-form-input></code> mixin:<pre class=prettyprint>abstract class AFormInputMixin {<br />  // @PublishedProperty(reflect: true)<br />  String name;<br /><br />  // @PublishedProperty(reflect: true)<br />  String value;<br /><br />  Element lightInput;<br /><br />  void attached() {<br />    lightInput = new HiddenInputElement();<br />    if (name != null) lightInput.name = name;<br />    parent.append(lightInput);<br />  }<br /><br /><b>  void attributeChanged(String name, String oldValue, String newValue) {<br />    print('$name: $oldValue → $newValue');<br />    if (name == 'name') lightInput.name = newValue;<br />    if (name == 'value') lightInput.value = newValue;<br />  }</b><br />}</pre>So really, Polymer mixins are nowhere near as horrible as I had feared. Unfortunately, annotations do not work. This is a significant drawback as the mixin class is neither as expressive nor does it get some of the assurance that would otherwise come from static analysis. It also makes for extra work for the developer trying to use this mixin. Even so, it is not so onerous that I would dismiss it outright—especially in cases that did not require a published property in the mixin.<br /><br /><br /><br /><span style="color: #ccc">Day #16</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/12/polymer-dart-mixins-are-not-real-thing.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/12/minimum-viable-polymer-mixin-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="//feeds.feedburner.com/~r/JaphrByChrisStrom/~4/ru2ghP_YfNk" height="1" width="1" alt=""/>
