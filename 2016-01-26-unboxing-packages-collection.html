---
title: 'Unboxing Packages: collection'
layout: post
published: '2016-01-26T14:10:00-08:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/01/unboxing-packages-collection.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<div class="separator" style="clear: both; text-align: center;"><a href="http://3.bp.blogspot.com/-w83NPdhel3Q/VqgHykaYJjI/AAAAAAAB_9U/t-AirDzDu5A/s1600/unboxing_packages_image.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="http://3.bp.blogspot.com/-w83NPdhel3Q/VqgHykaYJjI/AAAAAAAB_9U/t-AirDzDu5A/s1600/unboxing_packages_image.png" /></a></div> <p>I often find myself working with a class of Dart packages I like to think of as <em>core library expansion packs</em>. They aren’t the splashiest, they don’t produce cool demos, but they’re extremely useful. These expansion packages, which are always named after a <code>dart:</code> library, build upon that library’s design and functionality to provide utility classes and fill in missing features.</p> <p>Actual core libraries—the things you get when you write <code>import "dart:..."</code>—are very useful because they’re always there, but they’re also really painful to change. Exactly because they’re always there, they have much stronger stability guarantees than the rest of the ecosystem. It’s dangerous to even add a new class because it might conflict with a user’s class name and break existing code. And forget about adding an instance method. What if someone was implementing that class as an interface?</p> <p>For those reasons, the core libraries are kept as slim as possible. So what happens when we want to add a new collection type, or a class for manipulating streams? That’s exactly what expansion packs are for. Because they’re versioned packages, they can safely be added to and modified without breaking the world. But we can still keep them to the high standard of API design and stability to which we hold the core libraries.</p> <p>The best way to understand the general idea is to look at a particular example. Let’s dive into the <a href="https://pub.dartlang.org/packages/collection"><code>collection</code> package</a>, the oldest core expansion and one of the oldest Dart packages period. This package has a bunch of classes and mixins to help implement the various (rather hefty) collection interfaces, as well as advanced equality support, and a few specialized functions and collection types.</p>   <h2 id="wrappers">Wrappers</h2> <p>A wonderful feature of Dart’s type system is how easy it is to expose something that users see as a normal <code>List</code> or <code>Map</code>, but that has customized behavior or representation internally. The wrappers provided by the <code>collection</code> package are a key component of making this work. They make it as easy as <code>extends</code> to write a class that modifies the behavior of a collection.</p> <p>The simplest examples are the delegating classes: <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DelegatingIterable-class.html"><code>DelegatingIterable</code></a>, <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DelegatingList-class.html"><code>DelegatingList</code></a>, <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DelegatingMap-class.html"><code>DelegatingMap</code></a>, <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DelegatingSet-class.html"><code>DelegatingSet</code></a>, and <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DelegatingQueue-class.html"><code>DelegatingQueue</code></a>. These classes wrap an object of the corresponding type and, by default, forward all methods to that object. But you can extend them to override specific methods:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// A delegating list that improves the `toString()` to only include modified</span><span class="pln"><br /></span><span class="com">/// flags.</span><span class="pln"><br /></span><span class="kwd">class</span><span class="pln"> </span><span class="typ">FlagList</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">DelegatingList</span><span class="pun">&lt;</span><span class="typ">VMFlag</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">FlagList</span><span class="pun">(</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">VMFlag</span><span class="pun">&gt;</span><span class="pln"> flags</span><span class="pun">)</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">flags</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="typ">String</span><span class="pln"> toString</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">return</span><span class="pln"> </span><span class="str">"["</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">this</span><span class="pun">.</span><span class="kwd">where</span><span class="pun">((</span><span class="pln">flag</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> flag</span><span class="pun">.</span><span class="pln">modified</span><span class="pun">).</span><span class="pln">join</span><span class="pun">(</span><span class="str">", "</span><span class="pun">)</span><span class="pln"> </span><span class="pun">+</span><span class="pln"> </span><span class="str">", ...]"</span><span class="pun">;</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>The unmodifiable wrappers also come up a lot in practice. <a href="https://api.dartlang.org/latest/dart-collection/UnmodifiableListView-class.html"><code>UnmodifiableListView</code></a> and <a href="https://api.dartlang.org/latest/dart-collection/UnmodifiableMapView-class.html"><code>UnmodifiableMapView</code></a> were so popular that they were actually brought into <code>dart:collection</code> itself, but <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/UnmodifiableSetView-class.html"><code>UnmodifiableSetView</code></a> is only in the package. These classes are like the delegating wrappers, but make all methods that would modify the collection instead throw <code>UnsupportedError</code>s. They’re great for writing classes that expose collections that shouldn’t be modified externally:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Engine</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">LiveTest</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> liveTests </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">UnmodifiableListView</span><span class="pun">&lt;</span><span class="typ">LiveTest</span><span class="pun">&gt;(</span><span class="pln">_liveTests</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> _liveTests </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="typ">LiveTest</span><span class="pun">&gt;[];</span><span class="pln"><br /><br />  </span><span class="com">// The class internally modifies _liveTests, but external users can't.</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>There are also unmodifiable mixins that complement the views: <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/NonGrowableListMixin-class.html"><code>UnmodifiableListMixin</code></a>, <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/UnmodifiableMapMixin-class.html"><code>UnmodifiableMapMixin</code></a>, and <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/UnmodifiableSetMixin-class.html"><code>UnmodifiableSetMixin</code></a>. You can mix these in to your own, non-view collections to easily make an unmodifiable version.</p> <h2 id="equality">Equality</h2> <p>Most of the time, Dart’s <code>==</code> is perfectly good for telling if two objects are the same. But sometimes, you need more, and the <code>collection</code> package has your back. It defines an <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/Equality-class.html"><code>Equality&lt;T&gt;</code></a> interface that defines two main operations: whether two objects of type <code>T</code> are equal, and what the hash code for an object of type <code>T</code> is.</p> <p>The most useful type of equality after <code>==</code> is <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection.equality/DeepCollectionEquality-class.html"><code>DeepCollectionEquality</code></a>. This compares supported collections (iterables and maps) based on their contents, whereas <code>==</code> only returns true if they’re the exact same object. There’s even a <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DeepCollectionEquality/DeepCollectionEquality.unordered.html"><code>new DeepCollectionEquality.unordered()</code></a> constructor if you don’t care about ordering.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">void</span><span class="pln"> assertEqual</span><span class="pun">(</span><span class="pln">actual</span><span class="pun">,</span><span class="pln"> expected</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">const</span><span class="pln"> </span><span class="typ">DeepCollectionEquality</span><span class="pun">().</span><span class="pln">equals</span><span class="pun">(</span><span class="pln">actual</span><span class="pun">,</span><span class="pln"> expected</span><span class="pun">))</span><span class="pln"> </span><span class="kwd">return</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">throw</span><span class="pln"> </span><span class="str">"Expected $actual to equal $expected."</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>There’s also <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DefaultEquality-class.html"><code>DefaultEquality</code></a>, which is the same as <code>==</code>, and <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/IdentityEquality-class.html"><code>IdentityEquality</code></a>, which <em>always</em> checks if two objects are the same. These aren’t very useful on their own, but they’re important for constructing custom equalities. Which, by the way, is a thing you can do! The equality classes are constructed to allow you to build new equalities out of old ones.</p> <p>For example, <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/DeepCollectionEquality/DeepCollectionEquality.html"><code>new DeepCollectionEquality()</code></a> optionally takes an <code>Equality</code> parameter that it uses to compare non-collection objects. <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/MapEquality-class.html"><code>MapEquality</code></a> takes two different <code>Equality</code> paramters, one for keys and one for values. And <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/MultiEquality-class.html"><code>MultiEquality</code></a> takes a whole list that it tries in order.</p>   <h2 id="specialized-collections">Specialized Collections</h2> <p>My favorite part of the <code>collection</code> package is its original collection classes. Partly this is because I wrote a bunch of them and I have a mother’s pride, but it’s also because a good collection does what you need and does it well, and <em>that’s just cool</em>.</p>   <h3 id="canonicalizedmap"><code>CanonicalizedMap</code></h3> <p>Most of these classes are implementations of existing interfaces, but with useful specialized behavior. The <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/CanonicalizedMap-class.html"><code>CanonicalizedMap</code></a> class, for example, is a map that converts keys to a canonical form. You can use it to do things like make a case-insensitive map for, say, HTTP headers.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">class</span><span class="pln"> </span><span class="typ">CaseInsensitiveMap</span><span class="pun">&lt;</span><span class="pln">V</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">CanonicalizedMap</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pun">,</span><span class="pln"> V</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">CaseInsensitiveMap</span><span class="pun">()</span><span class="pln"><br />      </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">(</span><span class="pln"><br />          </span><span class="com">// This callback determines the canonical form of the user's key.</span><span class="pln"><br />          </span><span class="pun">(</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> key</span><span class="pun">.</span><span class="pln">toLowerCase</span><span class="pun">(),</span><span class="pln"><br /><br />          </span><span class="com">// Null keys aren't allowed. You can't call null.toLowerCase()!</span><span class="pln"><br />          isValidKey</span><span class="pun">:</span><span class="pln"> </span><span class="pun">(</span><span class="pln">key</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> key </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> headers </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">CaseInsensitiveMap</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;();</span><span class="pln"><br /><br />  </span><span class="com">// This canonicalizes the key to "content-type", then stores the value.</span><span class="pln"><br />  headers</span><span class="pun">[</span><span class="str">"CONTENT-TYPE"</span><span class="pun">]</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> </span><span class="str">"application/dart"</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="com">// This reads back the same value, since the canonical key is the same.</span><span class="pln"><br />  </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">headers</span><span class="pun">[</span><span class="str">"Content-Type"</span><span class="pun">]);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>When carefully thinking about API boundaries, which everyone should do all the time forever, it occasionally becomes clear that the collection a class uses internally doesn’t provide the best interface for users of that class. You can always copy the data into a new form when the user tries to read it, but in some circumstances that’s not as efficient as it could be.</p>   <h3 id="mapkeyset-and-mapvalueset"><code>MapKeySet</code> and <code>MapValueSet</code></h3> <p>One of those circumstances is when you’ve got a map internally, but you want to expose it as a set. Sets and maps both ensure that all elements or keys are unique, after all. That’s what the <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/MapKeySet-class.html"><code>MapKeySet</code></a> and <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/MapValueSet-class.html"><code>MapValueSet</code></a> classes are for. They each wrap a map and expose its keys and values (respectively) as a set, without actually copying those contents. This means that if the underlying map is updated, that update is automatically reflected in the wrapper as well.</p> <p><code>MapKeySet</code> is the simpler of the two: it’s literally just a set of all the keys in the map. It’s unmodifiable, because there’s no way to add a key to the map without a corresponding value, but it’s great for exposing an internal map’s keys.</p> <p><code>MapValueSet</code> exposes the <em>values</em> of a map as a set instead of the keys. You can’t efficiently figure out whether a value is in a map without some help, so this takes an extra callback that takes a (potential) value and returns the key that corresponds to it. And of course, that only works if it’s possible to compute the key for a value at all. If you have such a function, though, you get an efficient value set. And it can even be modified!</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">class</span><span class="pln"> </span><span class="typ">DoofyDatabase</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="com">// Internally represent the database as a map so it can be indexed by ID.</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> _map </span><span class="pun">=</span><span class="pln"> </span><span class="pun">&lt;</span><span class="kwd">int</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Doof</span><span class="pun">&gt;{};</span><span class="pln"><br /><br />  </span><span class="com">// Externally expose the database values as a set.</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">Set</span><span class="pun">&lt;</span><span class="typ">Doof</span><span class="pun">&gt;</span><span class="pln"> allDoofs</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="typ">DoofyDatabase</span><span class="pun">()</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> doofs </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">MapValueSet</span><span class="pun">(</span><span class="pln">_map</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">doof</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> doof</span><span class="pun">.</span><span class="pln">id</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="typ">Doof</span><span class="pln"> doofById</span><span class="pun">(</span><span class="kwd">int</span><span class="pln"> id</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> _map</span><span class="pun">[</span><span class="pln">id</span><span class="pun">];</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h3 id="priorityqueue"><code>PriorityQueue</code></h3> <p>A priority queue is one of those classic data structures you learn about in school, and <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/PriorityQueue-class.html"><code>PriorityQueue</code></a> is the Dart implementation. Well, actually, <a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection.priority_queue/HeapPriorityQueue-class.html"><code>HeapPriorityQueue</code></a> is the implementation. <code>PriorityQueue</code> should probably have a factory constructor—let me <a href="https://github.com/dart-lang/collection/issues/17">file an issue about that</a> real quick. If one of you lovely readers wanted to send in a pull request to fix that, I’d personally review and merge it.</p> <p>A priority queue is a collection that’s efficiently kept constantly ordered even as objects are added and removed. The exact ordering depends on the <a href="https://api.dartlang.org/latest/dart-core/Comparator.html"><code>Comparator</code></a> you pass to the <code>HeapPriorityQueue</code> constructor, but by default it just assumes the contents are <a href="https://api.dartlang.org/latest/dart-core/Comparable-class.html"><code>Comparable</code></a> and calls <code>a.compareTo(b)</code>. <code>PriorityQueue</code> implement any of the more common collection interfaces, but you’ll recognize most of the methods from <code>Set</code> and <code>Queue</code>.</p>   <h3 id="queuelist"><code>QueueList</code></h3> <p><a href="https://www.dartdocs.org/documentation/collection/latest/dart.pkg.collection/QueueList-class.html"><code>QueueList</code></a> has all the powers of both <a href="https://api.dartlang.org/latest/dart-collection/Queue-class.html"><code>Queue</code></a> and <code>List</code>! The normal queue interface doesn’t have an <code>[]</code> operation because some implementations can’t support it efficiently. But other implementations actually use a list as the underlying data structure, which makes <code>[]</code> very efficient. <code>QueueList</code> takes advantage of this fact to implement both interfaces at once.</p> <p>The result is a data structure that’s efficient at everything it does. Unlike a list, elements can be added and removed from the beginning in O(1) time. Unlike a queue, elements can be accessed from the middle in O(1) time. It’s a beautiful thing.</p>   <h2 id="collecting-the-goods">Collecting the Goods</h2> <p>You can find the source code for <code>collection</code> <a href="https://github.com/dart-lang/collection">on GitHub</a>, where you should feel free to send pull requests and add your own awesome collection classes. And next time your API needs to expose a set that can’t be modified or needs to remove an element from the beginning of a collection <em>and</em> access elements in the middle, you can download it with <code>pub</code>.</p> <p>Join me in two weeks when I talk about how to make your parse errors look amazing.</p>
