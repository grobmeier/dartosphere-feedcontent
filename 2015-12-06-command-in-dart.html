---
title: 'Command in Dart'
layout: post
published: '2015-12-06T22:36:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/evT2AInokZI/command-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - design-patterns

---

<div class=top-chain-links></div><br />Whilst messing about with the <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a>, I often found myself tripping over the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>. The patterns are similar enough that I confuse them, but dissimilar enough that I ought know better than to get them mixed up. So, at the risk of overloading on behavioral patterns, tonight I start on the command pattern in <a href="http://dartlang.org">Dart</a> for the forthcoming <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>.<br /><br />Something about the traditional light switch example for command patterns leaves me cold. That said, it is traditional for a reason—it uses physical object from the real world nicely in the example. So I start with that. <br /><br />The idea behind the command pattern is the ability to represent a command as an object. That object can then be queued, replayed, or undone at a later time. The "command" in the pattern includes both a thing being acted on and an action being performed on that thing. In the traditional light switch example, the "thing" is a light and the action is turning the light on and off.<br /><br />The <code>Light</code> class is a simple Dart class with a single method to turn the bulb on or off. In command pattern speak, the <code>Light</code> is the receiver of the command:<pre class=prettyprint>// Receiver<br />class Light {<br />  void turn(String state) {<br />    print("Light ${state}");<br />  }<br />}</pre>The command itself has one requirement—that any command being run against the receiver executes some change. Thus the base class for commands requires that implementations define an <code>execute()</code> method:<pre class=prettyprint>// Abstract command<br />abstract class Command {<br />  void execute();<br />}</pre>With that, I can define concrete commands for the <code>Light</code> receiver:<pre class=prettyprint>// Concrete Command<br />class OnCommand implements Command {<br />  Light light;<br />  OnCommand(this.light);<br />  void execute() { light.turn('ON'); }<br />}<br /><br />// Concrete Command<br />class OffCommand implements Command {<br />  Light light;<br />  OffCommand(this.light);<br />  void execute() { light.turn('OFF'); }<br />}</pre>Both commands require the <code>Light</code> receiver and both effect change on that receiver in their respective <code>execute()</code> methods.<br /><br />With the core of the pattern out of the way, I am ready to focus on the "invoker." In the light switch example, the switch is the invoker, which is where this real-world example breaks down for me. I cannot think of a smart switch that might need to remember previous changes in state or a complicated switch that needs to queue commands. I am overthinking it, I know, so before I travel too far down that avenue, I simply define the <code>Switch</code> as:<pre class=prettyprint>// Invoker<br />class Switch {<br />  List&lt;Command> _history = [];<br /><br />  void storeAndExecute(Command c) {<br />    c.execute();<br />    _history.add(c);<br />  }<br />}</pre>The main purpose of the invoker is to execute the command. Here, it also stores the command for later undo. <br /><br />That is the bulk of the pattern. The client code that uses the pattern needs an instance of the invoker and the receiver:<pre class=prettyprint><code>  var s = new Switch(),<br />    lamp = new Light();<br /></code></pre>The client also needs the commands that can be executed:<pre class=prettyprint><code>  var switchUp = new OnCommand(lamp),<br />    switchDown = new OffCommand(lamp);</code></pre>With that, the invoker can turn the light on at any time:<pre class=prettyprint><code>        s.storeAndExecute(switchUp);</code></pre>And it can turn it off at any time:<pre class=prettyprint><code>        s.storeAndExecute(switchDown);</code></pre>In this example, the power of the pattern is limited to the storage of the command. If the invoker defines an <code>undo()</code> as:<pre class=prettyprint>class Switch {<br />  List&lt;Command> _history = [];<br />  // ...<br />  void undo() {<br />    _history.<br />      reversed.<br />      forEach((c) { c.execute(); });<br />  }<br />}</pre>Then previously executed switch states can be replayed in reverse order. There is more to the command pattern than undo. I will continue to explore that tomorrow.<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/4530f9917cccbf8a2cbd">https://dartpad.dartlang.org/4530f9917cccbf8a2cbd</a>.</i><br /><br /><br /><span style="color: #ccc">Day #25</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/the-caretaker-mel-and-one-velvet-fog.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/evT2AInokZI" height="1" width="1" alt=""/>
