---
title: 'What the Heck is a Pluggable Adapter?'
layout: post
published: '2016-01-01T23:29:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Rdj9YwNjxLY/what-heck-is-pluggable-adapter.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Confession: I never understood a thing about pluggable adapters in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>. I have read that section on more than one occasion and not understood a damn word. So it seems like good grist for a blog post.<br /><br />Part of my confusion is that I am not 100% clear on what is meant by the term. When first introduced in the book, a pluggable adapter describes "classes with built-in interface adaption." I am unclear on what "built-in" means and what gets it (the adapter or adaptee). Later, they describe a reusable widget that needs to work with similar objects even if they have different interfaces. I am going to focus on that second idea for now. Maybe I can figure out what they mean in the first definition for a follow-up post.<br /><br />I am still working with my <code>Robot</code> <a href="http://dartlang.org">Dart</a> class that moves in different directions via a single <code>move()</code> method:<pre class=prettyprint>enum Direction { NORTH, SOUTH, EAST, WEST }<br /><br />class Robot {<br />  int x=0, y=0;<br />  String get location => "$x, $y";<br /><br />  void move(direction) {<br />    print("  I am moving $direction");<br />    switch (direction) {<br />      case Direction.NORTH:<br />        y++;<br />        break;<br />      case Direction.SOUTH:<br />        y--;<br />        break;<br />      case Direction.EAST:<br />        x++;<br />        break;<br />      case Direction.WEST:<br />        x--;<br />        break;<br />    }<br />  }<br />}</pre>A competing robot manufacturer might have a different robot movement API that looks like:<pre class=prettyprint>class Bot {<br />  int x=0, y=0;<br />  void goForward()  { y++; }<br />  void goBackward() { y--; }<br />  void goLeft()     { x--; }<br />  void goRight()    { x++; }<br />}</pre>So how do I go about defining an interface that can work with either of these? I think that if I can answer that, I will have a pluggable adapter.<br /><br />The universal remote control that I am building requires a target interface that looks like:<pre class=prettyprint>abstract class Ubot {<br />  void moveForward();<br />  void moveBackward();<br />  void moveLeft();<br />  void moveRight();<br />}</pre>When I previously only needed to support the <code>Robot</code> class, I could do so with a plain-old adapter like:<pre class=prettyprint>class UbotRobot implements Ubot {<br />  Robot _robot;<br />  UbotRobot(this._robot);<br /><br />  void moveForward()  => _robot.move(Direction.NORTH);<br />  void moveBackward() => _robot.move(Direction.SOUTH);<br />  void moveLeft()     => _robot.move(Direction.WEST);<br />  void moveRight()    => _robot.move(Direction.EAST);<br />}</pre>One way that I can convert that to support the <code>Bot</code> class as well is to add a conditional to each move-related method:<pre class=prettyprint>class UbotRobot {<br />  var _robot;<br />  UbotRobot(this._robot);<br /><br />  bool get isRobot => _robot is Robot;<br />  bool get isBot   => _robot is Bot;<br /><br />  void moveForward() {<br />    if (isRobot) _robot.move(Direction.NORTH);<br />    if (isBot) _robot.goForward();<br />  }<br />  // ...<br />}</pre>That actually does the trick. In the client code, I can now use a <code>Robot</code> interchangeably with <code>Bot</code> when instantiating the universal <code>UBot</code> instance:<pre class=prettyprint><code>  var robot = new Bot(); // new Robot() also works<br />  var universalRobot = new UbotRobot(robot);</code></pre>Regardless of which robot is used, the movement commands work, thanks to the adapter:<pre class="prettyprint"><code>  print("Start moving the robot.");<br />  universalRobot<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward();<br />  print("The robot is now at: ${universalRobot.location}.");</code></pre>With the loquacious <code>Robot</code>, this results in:<pre class=prettyprint>$ ./bin/play_robot.dart                                                    <br />Start moving the robot.<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />The robot is now at: 0, 5.</pre>While the taciturn <code>Bot</code> produces:<pre class=prettyprint>$ ./bin/play_robot.dart                                                    <br />Start moving the robot.<br />The robot is now at: 0, 5.</pre>Both kinds of robots are controlled by the same universal remote class. <br /><br />It would be a pain to maintain an adapter like this. When the next robot is supported, I would have to make changes to each method. Worse, each method would eventually grow to contain one line for every supported interface. Better is to create a registry that contains enough information to invoke the appropriate commands on the adaptees. I think this must be what the Gang of Four were talking about with the three different versions of pluggable adapters. <br /><br />I am unsure that I understand each of the types that they discuss. I do understand... mirrors! So I import Dart mirrors and declare a registry with sufficient information to issue move commands to each type:<pre class=prettyprint>import 'dart:mirrors';<br /><br />class UbotRobot implements Ubot {<br />  var _robot;<br />  UbotRobot(this._robot);<br /><br />  static Map&lt;Type, Map> _registry = {<br />    Robot: {<br />      'forward':  [#move, [Direction.NORTH]],<br />      'backward': [#move, [Direction.SOUTH]],<br />      'left':     [#move, [Direction.WEST]],<br />      'right':    [#move, [Direction.EAST]]<br />    },<br />    Bot: {<br />      'forward':  [#goForward, []],<br />      'backward': [#goBackward, []],<br />      'left':     [#goLeft, []],<br />      'right':    [#goRight, []]<br />    }<br />  };<br />  // ...<br />}</pre>With that, I can reflect on the robot when invoking the appropriate movement method (with arguments):<pre class=prettyprint>class UbotRobot implements Ubot {<br />  // ...<br />  void moveForward() {<br />    var _ = _registry[_robot.runtimeType]['forward'];<br />    reflect(_robot).invoke(_[0], _[1]);<br />  }<br />  // ...<br />}</pre>Happily, that works as desired. Don't believe me? Try the code on DartPad: <a href="https://dartpad.dartlang.org/09b8a2b1f6da874c7c68">https://dartpad.dartlang.org/09b8a2b1f6da874c7c68</a>!<br /><br />I think I have a idea of what pluggable adapters are now. I may explore the concept a little further tomorrow. Hopefully I can better understand those implementation discussions from the book now!<br /><br /><br /><span style="color: #ccc">Day #51</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/adapting-procedural-code.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Rdj9YwNjxLY" height="1" width="1" alt=""/>
