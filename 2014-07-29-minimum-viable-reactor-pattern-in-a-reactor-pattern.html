---
title: 'Minimum Viable Reactor Pattern (in a Reactor Pattern)'
layout: post
published: '2014-07-29T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/zrPtlmaClYM/minimum-viable-reactor-pattern-in.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'reactor pattern'

---

<div class=top-chain-links></div><br />After last night, I believe that I finally have good handle on what the <a href="http://en.wikipedia.org/wiki/Reactor_pattern">Reactor Pattern</a> is. I also have a decent <a href="https://github.com/eee-c/design-patterns-in-dart/tree/master/reactor">implementation</a> to illustrate the pattern in <a href="http://dartlang.org">Dart</a> (at <a href="https://github.com/eee-c/design-patterns-in-dart/tree/039b2b0b3bce16f3e04b97c738ba33889fd8290e/reactor">039b2b0b3b</a> in the git repo). But it is a bit obtuse.<br /><br />I patterned the code after the original implementation from <a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf">the paper</a> that introduced the Reactor Pattern. As the paper noted, the pattern does not apply directly to a single threaded environment like Dart. It does not help that Dart itself is based on the Reactor Pattern. Even so, I think that I have Dart code that mimics the spirit, if not the exact implementation, of the implementation from the paper. But how much, exactly of that spirit is really necessary?<br /><br />After some thought, I think I can get rid of two things: a “re-imagining” of <code>select()</code> and the use of Dart isolates. Neither removal is a slam dunk—both serve multiple purposes in the sample code. But both also introduce additional concepts into an already concept-laden design pattern. If I have learned anything in my writings, it is that pretty much everything can and should be sacrificed at the later of minimizing the number of concepts. So let's slaughter a couple of sacrificial concepts and see if I am rewarded...<br /><br />First up is removing the Dart isolate code, which can been see on the very first line of the main entry point:<pre class=prettyprint>main() {<br /><b>  // Spawn the message sending isolate and set its receive port as the source of<br />  // the fake select() messages<br />  Isolate.spawn(messageSender, connection());</b><br /><br />  // Create (and register in constructor) event handler<br />  new LoggingAcceptor();<br /><br />  // Reactor “loop” (handleEvent is recursive)<br />  new InitiationDispatcher().handleEvents();<br /><br />  // NOTREACHED<br />  return 0;<br />}</pre>Part of the benefit of using an isolate here is that communication takes place over “ports” which sound very much like the networking ports from the original C++ example. The comparison is not exactly one-to-one, however, and the send vs. receive ports can be confusing:<pre class=prettyprint>void messageSender(SendPort server) {<br />  var logClient = new ReceivePort();<br />  server.send({'type': 'log_connect', 'value': logClient.sendPort});<br />  logClient.<br />    first.<br />    then((SendPort s1) {<br />      // Send messages to the connected “application“ port<br />    });<br />}</pre>The isolate was introduced to solve a problem that they <a href="http://japhr.blogspot.com/2014/07/isolated-reactors-in-dart.html">did not actually solve</a>. I kept them for the “ports,” but perhaps streams would suffice? It is impossible to escape streams in Dart, so using them here would hardly count as a new concept.<br /><br />The problem is that, in order to mimic the network nature of the Reactor Pattern sample, I need different connections for different services. I had not realized it, but the isolates fit this fairly well. I can convert to streams, but the change does not seem to improve the readability of the example that much:<pre class=prettyprint>void messageSender(StreamController server) {<br />  var logClient = new StreamController();<br />  server.add({'type': 'log_connect', 'value': logClient});<br />  logClient.<br />    stream.<br />    first.<br />    then((StreamController s1) {<br />      s1.add({'type': 'log', 'value': 'howdy'});<br />      s1.add({'type': 'log', 'value': 'chris'});<br />      server.add({'type': 'log'});<br />      // ...<br />    });<br />}<br /></pre>Even with isolates, the send and receive ports are ultimately streams themselves, so maybe this pure stream approach is the best option. Still, actually using the companion nature of send and receive ports lends itself to networking discussion. I will have to think about this. <br /><br />OK, so with the isolates removed, next up is the <code>select()</code> re-imagining. This is a tough thing to remove because it as the heart of the Reactor Pattern. The real <code>select()</code> call is responsible for demultiplexing systems calls likes TCP/IP server connections, network messages, and system I/O. Ultimately these system messages go into a queue that can be processed via <code>select()</code> calls inside of the reactor loop. In both the article and my sample code, this takes the form of the <code>handleEvents()</code> method of the dispatcher:<pre class=prettyprint>class InitiationDispatcher implements Dispatcher {<br />  // ...<br />  handleEvents() {<br /><b>    var event = select().fetch();</b><br />    if (event == null) { /* Jump to next loop to select again... */ }<br />    events[event.type].forEach((h)=> h.handleEvent(event));<br />  }<br />}</pre>My <code>select()</code> is not even a real function—it just returns an object whose <code>fetch()</code> method behaves like the real <code>select()</code>. I ought to remove it just for that bit of confusion, but… this fake <code>select()</code> does have the advantage of being a very explicit <code>Queue</code> of events:<pre class=prettyprint>class Select {<br />  StreamController&lt;Map> connection;<br /><br />  static final Select _select = new Select._internal();<br />  factory Select()=> _select;<br />  Select._internal() {<br />    connection = new StreamController();<br /><br />    connection.<br />      stream.<br />      listen((m) {<br />        add(new MessageEvent(m['type'], m['value']));<br />      });<br />  }<br /><br /><b>  Queue&lt;MessageEvent> queue = new Queue();<br /><br />  void add(MessageEvent e) { queue.addLast(e); }<br />  MessageEvent fetch() {<br />    if (queue.isEmpty) return null;<br />    return queue.removeFirst();<br />  }</b><br />}</pre>That said, streams themselves are decent demultiplexers.<br /><br /><br /><br /><span style="color: #ccc">Day #137</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/deep-isolated-reactors-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/zrPtlmaClYM" height="1" width="1"/>
