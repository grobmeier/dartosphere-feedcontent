---
title: 'Redo Command'
layout: post
published: '2015-12-15T22:43:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/2auGm0el8bw/redo-command.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I have undo. So what about redo?<br /><br />Over the past several days, I have explored undo in the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> in <a href="http://dartlang.org">Dart</a>, which leaves me a little curious about redoing / re-executing commands. I expect that they are fairly simple, but my expectations are rarely met in these matters. While I am at, I am still evaluating last night's robot command example as being worthy of using in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>—I worry that the robot example uses commands that are a bit too literal and is too simplistic.<br /><br /><i>Editable DartPad of last night's robot command example: <a href="https://dartpad.dartlang.org/3b2ac3f421db89c2b56a">https://dartpad.dartlang.org/3b2ac3f421db89c2b56a</a>.</i><br /><br />My first instinct with both undo and redo in this new example is to make them command buttons just like the other buttons on the "UI." This would allow me to <code>press()</code> these buttons just like the other buttons on the UI:<pre class=prettyprint><code>  btnUp.press();<br />  btnUp.press();<br /><br />  btnUndo.press();<br />  btnRedo.press();</code></pre>After considering this for a while, I think better of it. The undo and redo buttons look like the regular command buttons, but they do not behave that way. Specifically, regular command buttons store commands in history for… undoing:<pre class=prettyprint>class Button {<br />  static List _history = [];<br /><br />  String name;<br />  Command command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />    _history.add(command);<br />  }<br /><br />  static void undo() {<br />    var h = _history.removeLast();<br />    print("Undoing $h");<br />    h.undo();<br />  }<br />}</pre>But I cannot invoke that same <code>press()</code> button lest the undo command get added to the undo history (the second of two undos would then attempt to undo the first, which is not right). I could create a fake button class specifically for these kinds of actions, except these fake buttons would wind up calling fake commmands:<pre class=prettyprint><code>    var undo = new UndoCommand(),<br />      redo = new RedoCommand();</code></pre>These are not real commands in the command-pattern-sense because they do not associate a receiver with an action. The receiver of these action is the <code>Button</code> class. An undo command would just know this without having to be told:<pre class=prettyprint>class UndoCommand implements Command {<br />  void call() { Button.undo(); }<br />}</pre>Admittedly, this is likely my code telling me that I should move history out of the <code>Button</code> class (what if a slider is added to the UI?). I will look into that another day. For now, I bypass the undo and redo buttons and just call those actions directly:<pre class=prettyprint><code>  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br /><br />  Button.undo();<br />  Button.undo();<br />  Button.redo();</code></pre>With that out of the way, what of redoing?<br /><br />The simplicity of commands for my robot makes undoing and redoing simple. The move-north command, for instance moves north when doing (or re-doing) and moves south when undoing:<pre class=prettyprint>class MoveNorthCommand implements Command {<br />  Robot robot;<br />  MoveNorthCommand(this.robot);<br />  void call() { robot.move(Direction.NORTH); }<br />  void undo() { robot.move(Direction.SOUTH); }<br />}<br /></pre>That is a fine implementation. I only worry about this in book format because it is so simple that it lacks the ability to illustrate the power of the pattern. Again, something to worry about another day.<br /><br />After implementing similar <code>undo()</code> and <code>redo()</code> methods in the remaining command classes, I can teach the <code>Button</code> class how to use them. Undo is easy enough, but if I am to retain the option of re-doing and undone command, I need a place to store undone commands. Which means that I need a list of done commands and undone commands:<pre class=prettyprint>class Button {<br />  static List _history = [];<br />  static List _undoHistory = [];<br />  // ...<br />}</pre>That aside, the first-pass implementation of <code>undo()</code> and <code>redo()</code> are simple enough:<pre class=prettyprint>class Button {<br />  static List _history = [];<br />  static List _undoHistory = [];<br />  // ...<br /><br />  static void undo() {<br />    var h = _history.removeLast();<br />    print("Undoing $h");<br />    h.undo();<br />    _undoHistory.add(h);<br />  }<br /><br />  static void redo() {<br />    var h = _undoHistory.removeLast();<br />    print("Re-doing $h");<br />    h.call();<br />    _history.add(h);<br />  }<br />}</pre>That gets me what I want. If I move the robot 6 paces up/north, then undo two of those steps, then redo one of the undos:<pre class=prettyprint><code>  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br />  btnUp.press();<br /><br />  Button.undo();<br />  Button.undo();<br />  Button.redo();<br /><br />  print("\nRobot is now at: ${robot.location}");</code></pre>Then I wind up 6 - 2 + 1 = 5 paces to the north:<pre class=prettyprint>$ ./bin/play_robot.dart<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Up<br />  I am moving Direction.NORTH<br />Undoing Instance of 'MoveNorthCommand'<br />  I am moving Direction.SOUTH<br />Undoing Instance of 'MoveNorthCommand'<br />  I am moving Direction.SOUTH<br />Re-doing Instance of 'MoveNorthCommand'<br />  I am moving Direction.NORTH<br /><br />Robot is now at: 0, 5</pre>While that works, I definitely need to rethink where the history is stored. The <code>Button</code> class now has more history-related code than it does button-related code—a definite no-no. That coupled with my inability to support meta-buttons like undo/redo mean that tomorrow I explore retaining history in the application instead of the <code>Button</code> class. And maybe a happy random dance.<br /><br /><i>Play with the DartPad of the robot code so far: <a href="https://dartpad.dartlang.org/8fa8a3b4e0765e657e8a">https://dartpad.dartlang.org/8fa8a3b4e0765e657e8a</a>.</i><br /><br /><br /><span style="color: #ccc">Day #34</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/robotic-commands.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/command-history.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/2auGm0el8bw" height="1" width="1" alt=""/>
