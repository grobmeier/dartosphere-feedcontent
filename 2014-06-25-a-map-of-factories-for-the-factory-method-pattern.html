---
title: 'A Map of Factories for the Factory Method Pattern'
layout: post
published: '2014-06-25T23:58:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Ebb4Zrq3meY/a-map-of-factories-for-factory-method.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Sometimes there is no substitute for doing something stupid—just to see why it is stupid. It is one thing to read that a thing is stupid, but that tactile feeling of failure leaves an imprint that sticks with a person like a quality case of food poisoning. The body may expel the immediate repercussions of food poisoning, but it will be a long time before you try that particular Mediterranean bistro again.<br /><br />Toward that end I have been doing dumb things with mirrors, named constructors and default implementation approaches to the Factory Method pattern in <a href="http://dartlang.org">Dart</a>. Actually not all of those are dumb—it depends on the context in which they are used. And that's going to be a big part of my job in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>—figuring out which approaches are decent in the right circumstances and which are the coding equivalent of food poisoning.<br /><br />Also, I need to come up with really good food poisoning descriptions so that I can fully imprint on the hearty reader which approaches truly are stupid (and why). But that's a skill I can develop later. For now, I try another approach to the Factory Method pattern. This one promises to be rather good...<br /><br />I continue to work with the <a href="https://github.com/eee-c/hipster-mvc">Hipster MVC</a> framework. It is a toy MVC framework for the web (built primarily to support <a href="http://dart4hipsters.com/">Dart for Hipsters</a>). Toy or not, frameworks are fertile ground for raising robust Factory Method patterns. In this case, it has an abstract product, <code>HipsterModel</code> (the “M” in this framework's MVC). It also has an abstract creator, <code>HipsterCollection</code>. The current implementation of the Factory Method in this creator class is the <code>modelMaker()</code>:<pre class=prettyprint>abstract class HipsterCollection extends IterableBase {<br />  HipsterModel modelMaker(Map attrs);<br />  // ...<br />}</pre>This abstract method is declared so that subclasses will define a method that accepts a <code>Map</code> of attributes and returns a concrete product of type <code>HipsterModel</code>. The concrete creator implementation for a comic book collection (like the one in the <a href="https://github.com/eee-c/dart-comics">Dart Comics</a> application) might look something like:<pre class=prettyprint>class Comics extends HipsterCollection {<br />  <b>modelMaker(attrs) => new ComicBook(attrs);</b><br />  String url = '/comics';<br />}<br /></pre>This is a classic implementation of the Factory Method pattern, done in Dart. It is particularly effective in this framework example. The intent is to maintain a relationship between the creator class (<code>HipsterCollection</code>) and the product class (<code>HipsterModel</code>). Since the framework has no business knowing the concrete class types (<code>ComicBook</code>), using Factory Method defers the concrete instantiation to the concrete creator class.<br /><br />This approach works pretty darn well for a framework, but there are other approaches to the pattern. An interesting one was suggested by Vadim Tsushko in the <a href="http://japhr.blogspot.com/2014/06/dart-mirrors-for-better-factor-method.html#comments">comments of a previous post</a>. In Vadim's approach, a subclass of the creator is not responsible for creating concrete products. Instead, that responsibility goes into a <code>Map</code>:<pre class=prettyprint>typedef HipsterModel modelMaker(Map attrs);<br />Map&lt;Type, modelMaker> factory = new Map();<br /></pre>The <code>factory</code> map above is keyed by a Type and returns functions of the <code>modelMaker</code> type. In this approach, <code>modelMaker</code> is <code>typedef</code>'d as a function that accepts a map of attributes and returns an object of type <code>HipsterModel</code>. In other words, <code>modelMaker</code> functions have the exact same signature that my current <code>modelMaker()</code> method has.<br /><br />To explore this approach in Hipster MVC, I declare the <code>typedef</code> in the collection class and add the <code>factory</code> as a static class variable on the same:<pre class=prettyprint>typedef HipsterModel modelMaker(Map attrs);<br /><br />class HipsterCollection extends IterableBase {<br />  // ...<br /><b>  static Map&lt;Type, modelMaker> factory = new Map();<br /><br />  HipsterModel modelMaker(Map attrs) => factory[this.runtimeType](attrs);</b><br />  // ...<br />}</pre>The <code>modelMaker()</code> method is no longer abstract. Its definition returns the result of invoking the factory for the current runtime type.<br /><br />The factory for the <code>Comics</code> collection can be added as:<pre class=prettyprint>HipsterCollection.factory[Comics] = (attrs) => new Models.ComicBook(attrs);</pre>Once that is registered, an instance of <code>Comics</code> that needs a model (e.g. if it GETs a record via a REST backend) can get one by invoking <code>modelMaker</code> with the attributes. This will lookup the correct factory based on the object's <code>runtimeType</code>, which is <code>Comics</code>. The anonymous function associated with this type will be invoked with the supplied attributes and the result returned.<br /><br />I rather like that. The implementation is succinct. The resulting code might be a little hard to read, but the associated <code>typedef</code> and <code>Map</code> types clear things up nicely. The result is a subclass of the creator that does no creating itself:<pre class=prettyprint>class Comics extends HipsterCollection {<br />  String url = '/comics';<br /><b>  // NO LONGER NEEDED :)<br />  // modelMaker(attrs) => new ComicBook(attrs);</b><br />}<br /></pre>The only downside is also a potential benefit, depending on the context. In the case of my framework, I had to assign the <code>HipsterCollection.factory</code> in the <code>main()</code> entry point:<pre class=prettyprint>main() {<br />  HipsterCollection.factory[Comics] = (attrs) => new Models.ComicBook(attrs);<br />  // ...<br />}</pre>In certain circumstances this could be a benefit—keeping all of the factory registration in on place. In the case of my framework, this is probably not a good practice. Since I have to subclass the creator class anyway, I might as well put the creator method in that subclass. Even so, I like the factory map approach enough that I will likely include it in the book.<br /><br /><br /><span style="color: #ccc">Day #103</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/06/default-implementation-in-dart-factory.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/06/compile-time-constant-factory-method.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Ebb4Zrq3meY" height="1" width="1"/>
