---
title: 'Sharing Implementors is Easy in the Bridge Pattern'
layout: post
published: '2016-01-28T23:28:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/mF_cZxnKCA4/sharing-implementors-is-easy-in-bridge.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Reference counting is something of a lost art. I, for one, hope it stays that way. If there was a way to mess up counting, I was more than up to the task of finding it. That's only a slight exaggeration. <br /><br />So I very much appreciate garbage collected languages like <a href="http://dartlang.org">Dart</a>. Of course, garbage collection can only do so much—I promise you that it is still possible to build web applications that consume insane amounts of memory. In that vein, tonight I investigate sharing implementors in the <a href="https://en.wikipedia.org/wiki/Bridge_pattern">bridge pattern</a>.<br /><br />The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> describes <a href="http://c2.com/cgi/wiki?HandleBodyPattern">Handle Body</a> idiom for tackling this in C++. But that's for my old nemesis reference counting. In Dart, I have to think factory constructor singletons would be an easy way to tackle this. For example, consider the wildly memory intensive <code>DrawingApi1</code> class:<pre class=prettyprint>class DrawingApi1 implements DrawingApi {<br />  void drawCircle(double x, double y, double radius) {<br />    print(<br />      "[DrawingApi1] "<br />      "circle at ($x, $y) with "<br />      "radius ${radius.toStringAsFixed(3)}"<br />    );<br />  }<br />}</pre>Clearly, I do not want that class to instantiate new objects each time a <code>Circle</code> refined abstraction is created:<pre class=prettyprint><code>  List&lt;Shape> shapes = [<br />    new Circle(1.0, 2.0, 3.0, new DrawingApi1()),<br />    new Circle(0.0, 6.0, 1.0, new DrawingApi1()),<br />    new Circle(2.0, 2.0, 1.5, new DrawingApi1()),<br />    new Circle(5.0, 7.0, 11.0, new DrawingApi2()),<br />    new Circle(1.0, 2.0, 3.0, new DrawingApi1()),<br />    new Circle(5.0, -7.0, 1.0, new DrawingApi2()),<br />    new Circle(-1.0, -2.0, 5.0, new DrawingApi1())<br />  ];</code></pre>Even if <code>DrawingApi2</code> is significantly more lightweight than <code>DrawingApi1</code>, enough of the latter will drag the browser / system to a halt. But a simple singleton factory constructor solves that neatly:<pre class=prettyprint>class DrawingApi1 implements DrawingApi {<br />  static final DrawingApi1 _drawingApi = new DrawingApi1._internal();<br />  factory DrawingApi1()=> _drawingApi;<br />  DrawingApi1._internal();<br /><br />  void drawCircle(double x, double y, double radius) { /* ... */ }<br />}</pre>The class variable <code>_drawingApi</code> is constructed once from a private constructor. The regular <code>DrawingApi1()</code> is a factory constructor that only returns that one <code>_drawingApi</code> reference. And the internal constructor is a simple, no-argument private constructor.<br /><br />The only case that does not cover is when the number of references to a <code>DrawingApi1</code> instance goes to zero. The start-at-zero case is handled automatically for me by Dart. The private <code>_drawingApi</code> class variable is not assigned until the constructor is invoked for the first time—that is just thanks to Dart's lazy instantiation. So no memory will be used unless and until the first <code>DrawingApi1</code> shape is drawn.<br /><br />If I really needed to reclaim memory, I might try a handle-body kind of thing. But I'd probably get it wrong. So instead I use mirrors (because mirrors are always easier than reference counting).  If I switch to constructing shapes with the class name instead of an instance, the individual shapes might look like:<pre class=prettyprint><code>  List&lt;Shape> shapes = [<br />    new Circle(1.0, 2.0, 3.0, DrawingApi1),<br />    new Circle(0.0, 6.0, 1.0, DrawingApi1),<br />    new Circle(2.0, 2.0, 1.5, DrawingApi1),<br />    new Circle(5.0, 7.0, 11.0, DrawingApi2),<br />    new Circle(1.0, 2.0, 3.0, DrawingApi1),<br />    new Circle(5.0, -7.0, 1.0, DrawingApi2),<br />    new Circle(-1.0, -2.0, 5.0, DrawingApi1)<br />  ];</code></pre>The <code>Circle</code> constructor still redirects the last parameter, which is now a <code>Type</code>, to the abstraction superclass:<pre class=prettyprint>class Circle extends Shape {<br />  double _x, _y, _radius;<br />  Circle(this._x, this._y, this._radius, Type drawingApi) :<br />    super(drawingApi);<br />  // ...<br />}</pre>Finally, the constructor in the <code>Shape</code> abstraction can <code>putIfAbsent()</code> on the cache:<pre class=prettyprint>import 'dart:mirrors' show reflectClass;<br />abstract class Shape {<br />  DrawingApi _drawingApi;<br />  static Map<Type, DrawingApi> _drawingApiCache = {};<br /><br />  Shape(Type drawingApi) {<br />    _drawingApi = _drawingApiCache.putIfAbsent(<br />      drawingApi,<br />      ()=> reflectClass(drawingApi).newInstance(new Symbol(''), []).reflectee<br />    );<br />  }<br />  // ...<br />}</pre>If I want to clear that cache after all <code>Shape</code> instances have been removed, I can use a simple <code>clear()</code>:<pre class=prettyprint>abstract class Shape {<br />  // ...<br />  void reset() { _drawingApiCache.clear(); }<br />  // ...<br />}</pre>The rest remains unchanged from previous nights. The bridge between abstraction (shape) and implementor (a drawing API) is used in the <code>draw()</code> method in the refined abstraction:<pre class=prettyprint>class Circle extends Shape {<br />  // ...<br />  void draw() {<br />    _drawingApi.drawCircle(_x, _y, _radius);<br />  }<br />  // ...<br />}</pre>I draw two conclusions from this. First, I enjoy mirrors far more than is healthy. A handle-body class would have involved counting, but might have solved the last reference removal just as well (and possibly clearer). Second, singletons seem to solve the reference count for nearly all use-cases. <br /><br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/befac6b199a2cebf1d76">https://dartpad.dartlang.org/befac6b199a2cebf1d76</a>.</i><br /><br /><span style="color: #ccc">Day #78</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/bridge-mixins.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/handle-body-reference-counting-in.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/mF_cZxnKCA4" height="1" width="1" alt=""/>
