---
title: 'Dart 1.22: Faster tools, assert messages, covariant overrides'
layout: post
published: '2017-02-14T09:57:00-08:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2017/02/dart-122-faster-tools-assert-messages.html'
author:
    name: 'Filip Hráček'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/11956836702424010051'
tags:
    - async
    - language
    - performance
    - release
    - sdk

---

Dart&nbsp;1.22 is now available. It introduces a sync/async union type, assert messages, covariant parameter overrides, and much more. Tool startup is now much faster. <a href="https://www.dartlang.org/install">Get it now!</a><br /><br /><h3>Faster tool startup</h3>We have switched to using application snapshots for running our SDK tools like dart2js, analyzer, and pub. This improves startup performance. See the <a href="https://www.youtube.com/watch?v=lqE4u8s8Iik&amp;feature=youtu.be&amp;list=PLOU2XLYxmsILKY-A1kq4eHMcku3GMAyp2">AOT compiling talk</a>&nbsp;at Dart Dev Summit 2016&nbsp;for more information. Information about how to use application snapshots can be found in the <a href="https://github.com/dart-lang/sdk/wiki/Snapshots">SDK wiki</a>.<br /><br />Here are the improved performance numbers we see with the switch.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://4.bp.blogspot.com/-qJTKzt4JbLQ/WJtvPeF9s_I/AAAAAAAAOlM/Fl9HRG2Rec8z6EvKzOSo83KzWo2tYTlggCLcB/s1600/chart%2B%25284%2529.png" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://4.bp.blogspot.com/-qJTKzt4JbLQ/WJtvPeF9s_I/AAAAAAAAOlM/Fl9HRG2Rec8z6EvKzOSo83KzWo2tYTlggCLcB/s640/chart%2B%25284%2529.png" width="640" height="396" /></a></div><br /><h3>Assert messages</h3>The <a href="https://en.wikipedia.org/wiki/Fail-fast">fail-fast</a>&nbsp;principle is crucial for building high-quality software, and <a href="https://www.dartlang.org/guides/language/language-tour#assert">assert</a>&nbsp;is the simplest way to fail fast. But until now, it wasn’t possible to attach messages to asserts, so if you wanted to make your error useful, you were forced to throw a full exception. Like this:<br /><br /><pre><code>num measureDistance(List<place> waypoints) {<br />  if (waypoints.any((point) => point.isInaccessible)) {<br />    throw new ArgumentError('At least one waypoint is inaccessible.');<br />  }<br />  // ...<br />}</code></pre><br />With messages in asserts, your code is not only shorter:<br /><br /><pre><code>num measureDistance(List<place> waypoints) {<br />  assert(waypoints.any((point) => point.isInaccessible),<br />         'At least one waypoint is inaccessible.');<br />  // ...<br />}</code></pre><br />But, more importantly, asserts are completely skipped in production, so your production code will be faster (it won’t have to iterate over waypoints at the start of every <code>measureDistance()</code> call).<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://3.bp.blogspot.com/-mwI1X7R3wHQ/WJt4OzzmztI/AAAAAAAAOlg/iVv833Gp3Jo5MEEyZDTOnSLpxC6lWwOaACLcB/s1600/realease-1.22.gif" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" src="https://3.bp.blogspot.com/-mwI1X7R3wHQ/WJt4OzzmztI/AAAAAAAAOlg/iVv833Gp3Jo5MEEyZDTOnSLpxC6lWwOaACLcB/s1600/realease-1.22.gif" /></a></div><h3>Covariant parameter override</h3>In object-oriented class hierarchies, especially in user interface frameworks, it&#39;s fairly common to run into code like this:<br /><br /><pre><code>class Widget {<br />  void addChild(Widget widget) {...}<br />}<br /><br />class RadioButton extends Widget {<br />  void select() {...}<br />}<br /><br />class RadioGroup extends Widget {<br />  void addChild(RadioButton button) {<br />    button.select();<br />    super.addChild(button);<br />  }<br />}</code></pre><br />Here, a <code>RadioGroup</code> is a kind of widget. It <em>refines</em>&nbsp;the base <code>Widget</code> interface by stating that its children must be <code>RadioButton</code>s and cannot be any arbitrary widget. Note that the parameter type in <code>RadioGroup.addChild()</code> is <code>RadioButton</code>, which is a subclass of <code>Widget</code>.<br /><br />This might seem innocuous at first, but it&#39;s actually statically unsound. Consider:<br /><br /><pre><code>Widget widget = new RadioGroup(); // Upcast to Widget.<br />widget.addChild(new Widget());    // Add the wrong kind of child.</code></pre><br />Tightening a parameter type, that is, using a proper subtype of the existing one in an overriding definition, breaks the <a href="https://en.wikipedia.org/wiki/Liskov_substitution_principle">Liskov substitution principle</a>. A <code>RadioGroup</code> doesn&#39;t support everything that its superclass Widget does. <code>Widget</code> claims you can add <em>any</em> kind of widget to it as a child, but <code>RadioGroup</code> requires it to be a <code>RadioButton</code>.<br /><br />Breaking substitutability is a little dubious, but in practice it works out fine. Developers can be careful and ensure that they only add the right kinds of children to their <code>RadioGroup</code>s. However, because this isn&#39;t <em>statically</em>&nbsp;safe, many languages disallow it, including Dart strong mode. (Classic Dart permits it.)<br /><br />Instead, users must currently manually tighten the type in the body of the method:<br /><br /><pre><code>class RadioGroup extends Widget {<br />  void addChild(Widget widget) {<br />    var button = widget as RadioButton;<br />    button.select();<br />    super.addChild(button);<br />  }<br />}</code></pre><br />The declaration is now statically safe, since it takes the same type as the superclass method. The call to select() is safe because it&#39;s guarded by an explicit as cast. That cast is checked and will fail at runtime if the passed widget isn&#39;t actually a RadioButton.<br /><br />In most languages, this pattern is what you have to do. It has (at least) two problems. First, it&#39;s verbose. Many users intuitively expect to be able to define subclasses that refine the contracts of their superclasses, even though it&#39;s not strictly safe to do so. When they instead have to apply the above pattern, they are surprised, and find the resulting code ugly.<br /><br />The other problem is that this pattern leads to a worse static typing user experience. Because the cast is now hidden inside the body of the method, a user of RadioGroup can no longer see the tightened type requirement at the API level.<br /><br />Both problems are solved by covariant parameter overrides.&nbsp;To enable them on a method parameter, you mark it with the contextual keyword covariant:<br /><br /><pre><code>class Widget {<br />  void addChild(covariant Widget widget) {...}<br />}</code></pre><br />Doing so says &quot;A subclass may override this parameter with a tighter desired type&quot;. A subclass can then override it like so:<br /><br /><pre><code>class RadioGroup extends Widget {<br />  void addChild(RadioButton button) {<br />    // ...<br />  }<br />}</code></pre><br />No special marker is needed in the overriding definition. The presence of covariant in the superclass is enough. The parameter type in the base class method becomes the original type of the overridden parameter. The parameter type in the derived method is the desired type.<br /><br />This approach fits well when a developer provides a library or framework where some parameter types were designed for getting tightened. For instance, the Widget hierarchy was designed like that.<br /><br />In cases where the supertype authors did not foresee this need, it is still possible to tighten a parameter type by putting the covariant modifier on the overriding parameter declaration.<br /><br />The covariant modifier can also be used on mutable fields. Doing so corresponds to marking the parameter in the implicitly generated setter for that field as covariant:<br /><br /><pre><code>class Widget {<br />  covariant Widget child;<br />}</code></pre><br />This is syntactic sugar for:<br /><br /><pre><code>class Widget {<br />  Widget _child;<br />  Widget get child => _child;<br />  set child(covariant Widget value) { _child = value; }<br />}</code></pre><br />Learn more about this feature in the <a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#1220">changelog</a>&nbsp;or in the <a href="https://github.com/dart-lang/sdk/blob/master/docs/language/informal/covariant-overrides.md">informal spec</a>.<br /><br /><h3>The Null type is now a subtype of every other type</h3>In other words, the Null type has been moved to the bottom of the type hierarchy. The null <em>literal</em>&nbsp;was always treated as a bottom type. Now the named class Null is too:<br /><br /><pre><code>final empty = <null>[];<br /><br />String concatenate(List<string> parts) => parts.join();<br />int sum(List<int> numbers) => numbers.fold(0, (sum, n) => sum + n);<br /><br />concatenate(empty); // OK.<br />sum(empty); // OK.</code></pre><br /><h3>FutureOr&lt;T&gt;</h3>A lot of asynchronous code in Dart allows the use of a T or a Future&lt;T&gt;. For example, the callback to Future.then is declared to take a T but it doesn&#39;t specify the return type, since it could be an S or a Future&lt;S&gt;:<br /><br /><pre><code>Future&lt;S&gt; then&lt;S&gt;(onValue(T value), { Function onError });</code></pre><br />We are adding FutureOr&lt;T&gt; to support this use case. FutureOr&lt;T&gt; represents the union of Future&lt;T&gt; and T. So the signature of then now looks like this.<br /><br /><pre><code>Future&lt;S&gt; then&lt;S&gt;(FutureOr&lt;S&gt; onValue(T value), { Function onError });</code></pre><br />This tightens types in places where dynamic was used before (like with `then` above), and allows strong-mode tools to do better type inference. In non-strong-mode, FutureOr just means dynamic. In other places, where types were already tight but the implementation had to force asynchronous code, it will allow to loosen that requirement.<br /><br /><h3>Generalized tear-offs are going away</h3><a href="https://github.com/gbracha/generalizedTearOffs/blob/master/proposal.md">Generalized tear-offs</a>&nbsp;are no longer supported, and will cause errors. We updated the language spec and added warnings in 1.21, and are now taking the last step to fully de-support them. They were previously only supported in the VM, and there are almost no known uses of them in the wild.<br /><br /><h3>Use of Function as a class is now deprecated</h3>You can still use Function as a type name, but don’t use it as a class (don’t extend it, implement it, etc.). For example:<br /><br /><pre><code>// This is deprecated.<br />class MyFunction extends Function {<br />  // …<br />}</code></pre><br />But this is still okay<br /><br /><pre><code>// This is okay.<br />void myAwesomeMethod(Function callback) {<br />  // …<br />}</code></pre><br />Read the <a href="https://github.com/dart-lang/sdk/blob/master/CHANGELOG.md#1220">changelog</a>&nbsp;for more information and additional changes.<br /><br />This release took one additional week to finish (our regular schedule is a release each 6 weeks) but we think it was worth the wait.
