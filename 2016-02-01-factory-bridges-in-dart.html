---
title: 'Factory Bridges in Dart'
layout: post
published: '2016-02-01T21:40:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/q-ACViQOnb0/factory-bridges-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory constructors'
    - 'web sockets'

---

<div class=top-chain-links></div><br />I've constructed a bridge in a client. I've constructed a bridge in a constructor. So tonight, I construct a bridge in a factory. <br /><br />I must investigate the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory</a> and <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">abstract factory</a> in <a href="http://dartlang.org">Dart</a>. Mostly because I am unsure how much value the standard structure of the pattern is needed in a language with <a href="https://www.dartlang.org/docs/dart-up-and-running/ch02.html#factory-constructors">factory constructors</a> baked right in. Since they are baked in, that's what I opt for tonight.<br /><br />The abstraction in my bridge pattern example continues to be a <code>Messenger</code>:<pre class=prettyprint>abstract class Messenger {<br />  Communication comm;<br />  Messenger(this.comm);<br />  void updateStatus();<br />}</pre>The purpose of classes implementing this interface is to simply facilitate status updates. There are a number of communication methods bridged from this abstraction: HTTP, websockets, etc. In last night's pass at the bridge pattern, the specific implementation was chosen in the abstraction's constructor (i.e. <code>Messenger</code>) and subsequently changed when certain thresholds were reached. <br /><br />Tonight, I move the responsibility of choosing the implementation out of the abstraction and into a factory constructor. Because it make sense and is so darn easy, I declare a factory constructor in the <code>Communication</code> implementation:<pre class=prettyprint>import 'dart:math' show Random;<br /><br />// Implementor<br />abstract class Communication {<br />  factory Communication() => new Random().nextBool() ?<br />    new WebSocketCommunication() : new HttpCommunication();<br />  void send(String message);<br />}<br /></pre>I continue to find it strange that an abstract class can declare a constructorâ€”even if it is a factory constructor. Each time, I must remind myself that it works for just this kind of case: choosing a subclass implementation. In this case, I randomly choose between the <code>WebSocketCommunication</code> and <code>HttpCommunication</code> concrete implementations.<br /><br />No changes are required to either of the concrete implementations. They both continue to establish their connections to the server and define the appropriate code to send messages. The <code>Messenger</code> abstraction and the subclass refined for use in web clients, <code>WebMessenger</code> do need to change slightly. <br /><br />The subclass no longer needs to concern itself with the <code>Communication</code> implementation. The <code>Messenger</code> can do that. Instead, the subclass can worry only about web page related things, like the text input element from which it will obtain messages to send back to the server:<pre class=prettyprint>class WebMessenger extends Messenger {<br />  InputElement _messageElement;<br />  WebMessenger(this._messageElement);<br />  // ...<br />}</pre>The <code>Messenger</code> abstraction needs to do a little more work now, but not much. In addition to declaring the <code>Communication</code> instance variable, it now assigns it in the constructor:<pre class=prettyprint>abstract class Messenger {<br />  Communication comm;<br />  Messenger() : comm = new Communication();<br /><br />  void updateStatus();<br />}</pre>On a sidenote, I remain skeptical of initializer lists in constructors like that. I am trying to use them to see if they grow on me, but I think it just makes things noisy (especially if a constructor body is added to the mix).<br /><br />That pretty much does it. Through several page reloads, I find that the client does indeed randomly switch between implementations:<pre class=prettyprint>$ ./bin/server.dart<br />[WebSocket] message=asdf<br />[WebSocket] message=asdf<br />[WebSocket] message=asdf<br />[HTTP] message=asdf<br />[WebSocket] message=asdf<br />[HTTP] message=asdf<br /></pre>That was fairly straight-forward and low on the surprise scale. I note before concluding that none of this precludes me from setting the <code>Communciation</code> implementation in the client code. For example:<pre class=prettyprint>main() {<br />  var message = new WebMessenger(query('#message'))<br />    ..comm = new HttpCommunication();<br />  // ...<br />}</pre>I also note that making more purposeful choices than the current random implementation selection is straight-forward. I can simply choose based on VM info, browser info, or any other bit of information on which one might opt between HTTP and websocket communication. Any or all of those choices would be right at home in the factory constructor. Or perhaps someday in an abstract factory constructor.<br /><br /><p><i>Code for the bridge client and the backend server are <a href="https://github.com/eee-c/design-patterns-in-dart/tree/1c4d3d113077373ed1eca4ef352b9d15709dea19/bridge">on the Design Patterns in Dart public repository</a>.</i></p><br /><br /><br /><span style="color: #ccc">Day #82</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/when-to-choose-your-own-implementation.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/in-which-i-quarrel-with-bridge-names.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/q-ACViQOnb0" height="1" width="1" alt=""/>
