---
title: 'Isolated Reactors in Dart'
layout: post
published: '2014-07-27T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/dhVK_GRVz9o/isolated-reactors-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - isolates
    - 'reactor pattern'

---

<div class=top-chain-links></div><br />I am having a devil of a time implementing the <a href="http://en.wikipedia.org/wiki/Reactor_pattern">Reactor Pattern</a> in <a href="http://dartlang.org">Dart</a>. <br /><br />Truth be told, I do not have to implement it in Dart since Dart is itself built on the Reactor Pattern. Even so, I would like to try my level best to get a reasonable facsimile of it going. The effort itself so far has been illuminating. I had not previously <i>really</i> understood it—that is I could not teach it to someone else. But I would like to get it running for a more pragmatic reason: it would provide insight on how (and if) to include concurrency patterns in the forthcoming <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. And, for better or worse, I opted for the Reactor Pattern as my test case.<br /><br />The problem is not the implementation of the reactor loop:<pre class=prettyprint>main() {<br />  _startRandomMessageSender();<br /><br />  // Create (and register in constructor) event handler<br />  new WordAcceptor();<br /><br /><b>  // Reactor loop...<br />  for(;;) {<br />    new InitiationDispatcher().handleEvents();<br />  }</b><br />}</pre>The problem is not even event handlers like the <code>WordAcceptor</code> above, which follows along with the <a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf">original Reactor Pattern paper</a> by creating new object that then listen for the actual words being sent into the reactor loop.<br /><br />The problem is getting the messages into the reactor loop. Messages sent before the loop are properly queued and properly processed by the loop. But, once the loop is running, nothing else in the Dart program will run. The loop is so tight that asynchronous code is never given a chance to be executed by Dart's own reactor loop. This, it would seem, is one of the hazards of attempting to build a Reactor Pattern on top of another Reactor Pattern.<br /><br />But I think the problem might be better phrased as that of a single threaded execution environment, which Dart is. Or, more precisely, Dart's isolates are single threaded. But nothing is preventing me from spawning a second isolate. So that is just what I do. Spawn the message sending function in its own isolate so that it can send messages regardless of what the main isolate is doing:<pre class=prettyprint>// ...<br /><b>import 'dart:isolate';</b><br />main() {<br />  var res = new ReceivePort();<br />  select().from = res;<br />  Isolate.<br /><b>    spawn(messageSender, res.sendPort).</b><br />    then((_){<br />      // Create (and register in constructor) event handler<br />      new WordAcceptor();<br /><br />      // Reactor loop...<br />      for(;;) {<br />        new InitiationDispatcher().handleEvents();<br />      }<br />    });<br />}</pre>And… this has no effect whatsoever.<br /><br />Well, it has some effect. The message sending code is now reached and can even be delayed. But the problem remains back in the main code isolate. The reactor loop is so tight that it prevents any other activity from reaching the top of Dart's <a href="https://www.dartlang.org/articles/event-loop/">internal reactor loop</a>. <br /><br />Oh, and in case anyone thinks like me, no, <code>scheduleMicrotask()</code> is not the answer. Unless the question was, ”how do I exhaust VM memory really, really fast?” Again, the main thread of execution never stops evaluating the <code>for</code> loop long enough to ask what the next microtask or regular event task might be.<br /><br />So, I think I have to abandon trying to implement this exactly as done in the paper. The <code>for</code> loop prevents any events from outside the loop from being executed, which means that any asynchronous code (like the Future-based isolates) will never been seen.<br /><br />So I convert the <code>handleEvents()</code> call that used to be inside the loop to a recursive function call. I call <code>handleEvents()</code> once:<pre class=prettyprint>main() {<br />  var res = new ReceivePort();<br />  Isolate.<br />    spawn(messageSender, res.sendPort).<br />    then((_){<br />      // Create (and register in constructor) event handler<br />      new WordAcceptor();<br /><br /><b>      // Reactor “loop”...<br />      new InitiationDispatcher().handleEvents();</b><br />    });<br />}</pre>Then change <code>handleEvents()</code> to a recursive call (adding a Timer delay for good measure):<pre class=prettyprint>class InitiationDispatcher {<br />  // ...<br />  handleEvents([int timeout=0]) {<br />    var event = select().fetch();<br /><b>    if (event == null) {<br />      Timer.run((){this.handleEvents();});<br />      return;<br />    }</b><br />    events[event.type].forEach((h)=> h.handleEvent(event));<br />  }<br />}<br /></pre>And that does the trick. I can now send any messages in from the message sending isolate that I like. I probably do not even need the isolate any more.<br /><br />I <i>think</i> this still honors the spirit of the Reactor Pattern, but I am not 100% positive. I am also not entirely sure what all of this would buy me. The code is hard to follow as-is—hardly sufficiently illustrative to belong in a book. But it feel as though it add a lot of ceremony on top of something that Dart just gives us out of the box. Perhaps that is the point. If nothing else, this has given me additional information on which to ruminate.<br /><br /><br /><span style="color: #ccc">Day #135</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/simulating-select-for-dart-reactor.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/deep-isolated-reactors-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/dhVK_GRVz9o" height="1" width="1"/>
