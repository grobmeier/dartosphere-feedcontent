---
title: 'Bridge Mixins'
layout: post
published: '2016-01-27T21:50:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/H6M10X7adO0/bridge-mixins.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - mixins

---

<div class=top-chain-links></div><br />Today I take a look at the <a href="">bridge pattern</a> with <a href="http://dartlang.org">Dart</a> mixins. The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> includes a brief discussion on multiple inheritance and the bridge pattern. This has me curious about mixins, which can serve a similar purpose to multiple inheritance.<br /><br />I continue to work with the shape drawing example from Wikipedia. In it, a <code>Shape</code> is the the abstraction in need of bridging to an implementation—drawing in this case. The abstract <code>Shape</code> class requires a drawing API object be supplied when constructing a concrete implementation, along with two methods that must be defined by that same subclass:<pre class=prettyprint>abstract class Shape {<br />  DrawingApi _drawingApi;<br /><br />  Shape(this._drawingApi);<br /><br />  void draw();                         // low-level<br />  void resizeByPercentage(double pct); // high-level<br />}</pre>In a "refined abstraction," the low-level <code>draw()</code> is the method that needs the bridge to the implementor. For a <code>Circle</code>, the <code>draw()</code> method might invoke a <code>drawCircle()</code> method on a concrete drawing API object:<pre class=prettyprint>// Refined Abstraction<br />class Circle extends Shape {<br />  double _x, _y, _radius;<br />  Circle(this._x, this._y, this._radius, DrawingApi api) :<br />    super(api);<br /><br />  // low-level i.e. Implementation specific<br />  void draw() {<br />    _drawingApi.drawCircle(_x, _y, _radius);<br />  }<br />  // ...<br />}</pre>The client then create a concrete <code>DrawingApi</code> object (like <code>DrawingApi1</code>) to supply to <code>Circle</code>'s constructor:<pre class=prettyprint><code>    new Circle(1.0, 2.0, 3.0, new DrawingApi1())<br />      ..draw();</code></pre>That works great and is a nice example of a bridge pattern. But it is a hassle to have to construct a concrete <code>DrawingApi</code> class every time I construct a <code>Circle</code>. What's to prevent me from using <code>DrawingApi1</code> (or <code>DrawingApi2</code>) as a mixin? The answer is nothing!<br /><br />Since the abstraction no longer needs to track the implementor, it can be simplified to an interface requiring two methods:<pre class=prettyprint>abstract class Shape {<br />  void draw();                         <br />  void resizeByPercentage(double pct);<br />}</pre>Then I mixin <code>DrawingApi1</code> to <code>Circle</code> by extending <code>Shape</code> with <code>DrawingApi1</code>:<pre class=prettyprint>class Circle extends Shape with DrawingApi1 {<br />  double _x, _y, _radius;<br />  Circle(this._x, this._y, this._radius);<br />  void draw() { /* ... */  }<br />  void resizeByPercentage(double pct) { /* ... */ }<br />}</pre>With access to the methods of <code>DrawingApi1</code>, I can now call <code>drawCircle()</code> directly from <code>draw()</code>:<pre class=prettyprint>class Circle extends Shape with DrawingApi1 {<br />  // ...<br />  void draw() {<br />    drawCircle(_x, _y, _radius);<br />  }<br />  // ...<br />}</pre>That in turn simplifies my client code since it longer needs to worry about creating the drawing API object:<pre class=prettyprint><code>    new Circle(1.0, 2.0, 3.0)<br />      ..draw();</code></pre>When this code is, just as in the prior implementation, it produces the following output:<pre class=prettyprint>$ ./bin/draw.dart           <br />[DrawingApi1] circle at (1.0, 2.0) with radius 3.000</pre>So it is possible to use mixins to implement the bridge pattern in Dart… except not quite. <br /><br />This will work for the degenerate case explored last night in which there is only one concrete drawing implementor. Both the implementor and abstraction can vary independently, which is ultimately the goal of the pattern.<br /><br />What does not work is the same thing that the Gang of Four mentions as a shortcoming of the multiple inheritance approach in C++. The binding between the abstraction and implementor are now permanent. If I needed to vary the implementation at runtime, I am out of luck. Even mirrors will not help—at least not until the <code>mixin</code> property of <code>ClassMirror</code> is read-write.<br /><br />In the end, mixins in the bridge pattern are a fun experiment. They may even be a useful approach to use in degenerate, single implementor implementations. For a full featured bridge pattern, mixins will not serve as a legitimate solution.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/b0050955ee95746956da">https://dartpad.dartlang.org/b0050955ee95746956da</a>.</i><br /><br /><br /><span style="color: #ccc">Day #77</span>  <br /><br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/degenerate-bridges.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/sharing-implementors-is-easy-in-bridge.html=">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/H6M10X7adO0" height="1" width="1" alt=""/>
