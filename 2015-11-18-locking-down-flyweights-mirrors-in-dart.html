---
title: 'Locking Down Flyweights Mirrors in Dart'
layout: post
published: '2015-11-18T22:46:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/BLDXrlhlZgk/locking-down-flyweights-mirrors-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - flyweight
    - mirrors

---

<div class=top-chain-links></div><br />At the risk of over-examining a topic beyond all reason, I continue tonight to explore <a href="http://dartlang.org">Dart</a> mirrors as a means of obtaining concrete <a href="">Flyweight</a> objects. Hey, if you can't over-examine a topic when blogging every day, when can you?<br /><br />I very much like yesterday's mirror approach. In my coffee shop example, the <code>CoffeeFlavor</code> reference class is responsible for identifying concrete flyweights. The calling code behaves just like it would if it were getting a generic <code>CoffeeFlavor</code> instance:<pre class=prettyprint><code>  void order(name, sizeName, {who, fooFoo}) {<br />    var flavor = new CoffeeFlavor(name);<br />    int size = sizes[sizeName];<br />    _orders.add(new Order(flavor, size, who, fooFoo));<br />  }</code></pre>But the <code>factory</code> constructor in <code>CoffeeFlavor</code> is looking up concrete classes (e.g. <code>Cappuccino</code>, <code>Latte</code>, etc). in its internal cache:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  factory CoffeeFlavor(name) =><br />    _cache.putIfAbsent(name, () =><br />        classMirrors[new Symbol(name)].<br />           newInstance(new Symbol(''), []).<br />           reflectee<br />    );<br />  // ...<br />}<br /></pre>If present, the previously created concrete instance — the flyweight — is returned. If it is not already present, then the concrete class is looked up in the current library and used to create the flyweight.  This approach has the dual benefit of keeping the client code clean (it thinks it is creating an instance of <code>CoffeeFlavor</code>) and keeping the concrete classes simple. <br /><br />The concrete classes need only define intrinsic properties of particular coffee flavors:<pre class=prettyprint>class Cappuccino implements CoffeeFlavor {<br />  String get name => 'Cappuccino';<br />  double get profitPerOunce => 0.35;<br />}</pre>No metadata required (I may explore that tomorrow, though). No tomfoolery needed just to support the factory. It's all clean.<br /><br />I think I can make this even better by restricting the map of <code>classMirrors</code> to just classes that implement <code>CoffeeFlavor</code>. Just because I am using mirrors doesn't give me license to be obscene. This is statically typed Dart, not some loosey-goosey dynamically typed language.<br /><br />That turns out to be a little harder than expected. First off, I need to grab the list of all declarations from the local mirror:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  static Map _allDeclarations = currentMirrorSystem().<br />      findLibrary(#coffee_shop).<br />      declarations;<br />  // ...<br />}</pre>There is no <code>pairs</code> accessor for Dart maps, so I have to iterate over all of the keys in the <code>_allDeclarations</code> map. From there, I filter only class mirror declarations, and only classes that implement the <code>CoffeeFlavor</code> interface. Lastly, I reassemble the map via a <code>fold()</code>:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  static Map _allDeclarations = currentMirrorSystem().<br />      findLibrary(#coffee_shop).<br />      declarations;<br /><br />  static Map classMirrors = _allDeclarations.<br />    keys.<br />    where((k) => _allDeclarations[k] is ClassMirror).<br />    where((k) =><br />      _allDeclarations[k].superinterfaces.contains(reflectClass(CoffeeFlavor))<br />    ).<br />    fold({}, (memo, k) => memo..[k]= _allDeclarations[k]);<br />  // ...<br />}</pre>That's a little verbose. It does the trick, but I am unsure if it is worth all of the noise.<br /><br />Now that I think about it, it would be nice if this could work across libraries. My <code>coffee_shop</code> library can define a bunch of coffee flavor classes, but it would be helpful to support coffee flavor classes in the main code file as well:<pre class=prettyprint>class Mochachino implements CoffeeFlavor {<br />  String get name => "Mochachino";<br />  double get profitPerOunce => 0.3;<br />}<br /><br />main() {<br />  var shop = new CoffeeShop()<br />    ..order('Cappuccino', 'large', who: 'Fred', fooFoo: 'Extra Shot')<br />    ..order('Espresso',   'small', who: 'Bob')<br />    ..order('Frappe',     'large', who: 'Alice')<br />    ..order('Frappe',     'large', who: 'Elsa', fooFoo: '2 Percent Foam')<br />    ..order('Coffee',     'small')<br />    ..order('Coffee',     'medium', who: 'Chris')<br />    ..order('Mochachino', 'large', who: 'Joy');<br />  // ...<br />}</pre>To make that work, I need to rework the <code>_allDeclarations</code> assignment. Instead of looking in the current, <code>coffee_shop</code> library, I have to look across all libraries:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  static Map _allDeclarations = currentMirrorSystem().<br />      libraries.<br />      values.<br />      fold({}, (memo, library) => memo..addAll(library.declarations));<br />  // ...<br />}</pre>Again, I have to work around the lack of a <code>pairs</code> iterable on <code>Map</code>. That aside, this works nicely. My customers can order plenty of Mochachinos at the local coffee shop even if corporate does not support them yet. <br /><br />There is definitely some power in all these Dart mirrors. That power may not always be necessary, but it is nice to know that it is there if I need it.<br /><br />(Play with this code on DartPad: <a href="https://dartpad.dartlang.org/d103fcc8e1cbf371fa04">https://dartpad.dartlang.org/d103fcc8e1cbf371fa04</a>)<br /><br /><br /><span style="color: #ccc">Day #7</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/11/concrete-flyweight-objects-with-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/11/creating-and-reading-dart-annotations.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/BLDXrlhlZgk" height="1" width="1" alt=""/>
