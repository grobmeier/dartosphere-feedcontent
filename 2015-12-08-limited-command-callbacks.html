---
title: 'Limited Command Callbacks'
layout: post
published: '2015-12-08T23:27:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Oo7Vixr4Sjk/limited-command-callbacks.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I remain fascinated by command callbacks after last night's exploration. I can count the number of times that I have used an object-oriented <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> on one hand. But I have the feeling that I have used callback commands numerous times.<br /><br />The <a href="http://dartlang.org">Dart</a> command callbacks from last night look like:<pre class=prettyprint><code>  // Concrete command instances<br />  var switchUp = (){ lamp.turn('ON'); },<br />    switchDown = (){ lamp.turn('OFF'); };</code></pre>The receiver and action are embedded right in the callback.<br /><br />The object-oriented command on the other hand looks like:<pre class=prettyprint><code>  // Concrete command instances<br />  var switchUp = new OnCommand(lamp),<br />    switchDown = new OffCommand(lamp);</code></pre>In the OO version, the receiver is supplied by the client as it is in the callback version, but the linking of the two occurs in the command class:<pre class=prettyprint>// Concrete Command<br />class OnCommand implements Command {<br />  Light light;<br />  OnCommand(this.light);<br />  void call() { light.turn('ON'); }<br />}</pre>The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> mentions callbacks as a potential implementation for the command pattern in the Applicability section of the pattern description. I had never thought of that as a command, but it works as a drop-in replacement for the OO version. <br /><br />Also in the Applicability section is that commands ought to work in queues. So let's see how the callback version fairs in a queue. I map a list of strings into a queue as:<pre class=prettyprint><code>  // Command queue<br />  var queue = commands.map((command){<br />    if (command == 'on') return switchUp;<br />    if (command == 'off') return switchDown;<br />    print("Can only switch on or off");<br />  }).toList();</code></pre>I can asynchronously run the commands with <code>Timer.periodic()</code>:<pre class=prettyprint><code>  var index = 0;<br />  new Timer.periodic(new Duration(seconds: 2), (timer){<br />    s.storeAndExecute(queue[index++]);<br />  });</code></pre>That works both with the OO version and the callback version. So there is at least one bullet point under the Applicability section that works with callbacks.<br /><br />What about the next one, which is undo? Well, with my original implementation, it actually works both with both OO and callback versions:<pre class=prettyprint><code>  var index = 0;<br />  new Timer.periodic(new Duration(seconds: 2), (timer){<br />    s.storeAndExecute(queue[index++]);<br />    if (index >= queue.length) {<br />      timer.cancel();<br />      s.undo();<br />    }<br />  });</code></pre>The problem is that I am not really undoing anything, just playing the commands back in reverse (both <code>storeAndExecute()</code> and <code>undo()</code> invoke the same <code>call()</code> method):<pre class=prettyprint>// Invoker<br />class Switch {<br />  List<function> _history = [];<br /><br />  // void storeAndExecute(Command c) {<br />  void storeAndExecute(Function c) {<br />    c.call();<br />    _history.add(c);<br />  }<br /><br />  void undo() {<br />    print('--');<br />    _history.<br />      reversed.<br />      forEach((c) { c.call(); });<br />  }<br />}</pre>That is why this works for both the callback version in addition to the OO version. But if I want this done right, the concrete command objects need to specify how they undo their execution:<pre class=prettyprint>// Concrete Command<br />class OnCommand implements Command {<br />  Light light;<br />  OnCommand(this.light);<br />  void call() { light.turn('ON'); }<br />  void undo() { light.turn('OFF'); }<br />}</pre>With that, I can rewrite the invoker undo as:<pre class=prettyprint>class Switch {<br />  // ...<br />  void undo() {<br />    _history.<br />      reversed.<br />      forEach((c) { c.undo(); });<br />  }<br />}</pre>When I run the OO version, undoing the entire light switch script actually reverses each step from the original:<pre class=prettyprint>$ ./bin/press_switch.dart on on off on<br />Light ON<br />Light ON<br />Light OFF<br />Light ON<br />--<br />Light OFF<br />Light ON<br />Light OFF<br />Light OFF</pre>I suppose that the callback version could return an undo callback, but that is venturing into callback spaghetti territory. I think it safe to say that the callback command will not work for undo. <br /><br />In fact, I do not believe that the other two bullet points from the GoF description will work with callbacks either. There is no way to load/store callbacks. Building higher lever systems on top of callbacks is called insane—or Node.js (I kid!). So I think I have a better idea of the limitations of command callbacks. I do think I could use a better example to illustrate the point—on/off state switching it a tad simplistic. I will plan on starting that tomorrow.<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/6576696232e0b6c0109d">https://dartpad.dartlang.org/6576696232e0b6c0109d</a>.</i><br /><br /><br /><span style="color: #ccc">Day #27</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/callback-as-command.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/non-trivial-undo-in-command-pattern.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Oo7Vixr4Sjk" height="1" width="1" alt=""/>
