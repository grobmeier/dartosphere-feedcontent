---
title: 'Full-Duplex Streams'
layout: post
published: '2016-01-21T23:31:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/kBsc3YolCB8/full-duplex-streams.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'
    - websockets

---

<div class=top-chain-links></div><br />I ask you, what kind of world do we live in where websockets are the easy answer?<br /><br />Sure, my problems are my own and completely contrived, but still, websockets have proven to be the ideal medium to describe the remote <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a>. What makes them so nice is that I only have to supply a single socket to the proxy instance in order to enable it to control a real subject:<pre class=prettyprint>main() async {<br />  var socket = await WebSocket.connect('ws://localhost:4040/ws');<br />  ProxyCar car = new ProxyCar(socket);<br />  // ...<br />}</pre>The reason that this works is that websockets are, under the covers, a full-duplex communication channel. That is, a single websocket supports messages going from the client to the server <i>and</i> from the server to the client. <br /><br />Just as importantly, websockets send bi-directional messages rather than broadcast messages. Streams in <a href="http://dartlang.org">Dart</a> are either one-way or broadcast. I had previously attempted the remote proxy pattern with streams, but that required two streams, one for inbound and one for outbound:<pre class=prettyprint>main() async {<br />  var mainOut = new StreamController(),<br />      mainIn = new StreamController();<br />  ProxyCar car = new ProxyCar(mainOut, mainIn);<br />  // ...<br />}</pre>It works and, if you think about the need for sending messages from the client to the server and vice versa, that approach makes sense. But if I am trying to describe this in a book like <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>, I don't want readers to have to think about this—just the core concept being discussed. <br /><br />And don't even get me started on communication via <a href="https://api.dartlang.org/1.13.2/dart-isolate/dart-isolate-library.html">isolate</a> workers. They are twice as conceptually complex due to the need to create communication channels over existing one-way channels.<br /><br />And so, yes, I have created a world for myself in which websockets are the neat and clean answer. Armageddon must soon surely follow.<br /><br />But seriously, I am not diametrically opposed to websockets for this case. They do make a certain amount of sense as a vehicle for remotely controlling cars or other objects. I had hoped to find another kind of stream in the standard Dart library that was full-duplex, but that would appear not possible.<br /><br />Websockets in Dart <a href="https://api.dartlang.org/1.13.2/dart-io/WebSocket-class.html">are streams</a> and they implement the <code>Stream</code> interface (for listening to messages) and the <code>StreamSink</code> interface (for sending messages). I had hoped that <a href="https://api.dartlang.org/1.13.2/dart-async/StreamSink-class.html">StreamSink</a> might be implemented by another class that happened to be full-duplex. But it is only implemented by the <code>StreamController</code> that previously forced me into the undesirable two-stream-instances implementation.<br /><br />But what if I try it with just a single stream instead?<pre class=prettyprint>main() async {<br />  var socket = new StreamController.broadcast();<br />  ProxyCar car = new ProxyCar(socket);<br />  // ...<br />}</pre>The <code>socket</code> needs to be a broadcast stream so that both the proxy and real subject can listen to the same stream. Of course that is going to cause problems since <code>ProxyCar</code> will see messages from the real car <i>and</i> itself. So I need a way for <code>ProxyCar</code> to ignore its own messages.<br /><br />I could use an enum here or some other lookup, but it turns out that I already have a convention in place. The <code>ProxyCar</code> class only sends commands to the real car. I am sending those as symbols instead of strings (because mirrors!):<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  // ...<br />  Future drive() => _send(#drive);<br />  Future stop()  => _send(#stop);<br /><br />  Future _send(message) {<br />    _socket.add(message);<br />    // ...<br />  }<br />}</pre>So when <code>ProxyCar</code> listens for messages on the broadcast "socket," I can filter out any symbol messages with <code>where()</code>:<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  StreamController _socket;<br />  String _state = "???";<br /><br />  ProxyCar(this._socket) {<br />    _socket.stream.where((m)=> m is! Symbol).listen((message) {<br />      print("[ProxyCar] $message");<br />      _state = message;<br />    });<br />  }<br />  // ...<br />}</pre>Conversely, the real car, <code>AsyncCar</code>, only sends strings, so it can filter those out:<pre class=prettyprint>class AsyncCar implements AsyncAuto {<br />  StreamController _socket;<br />  Car _car;<br /><br />  AsyncCar(this._socket) {<br />    _car = new Car();<br /><br />    _socket.stream.where((m)=> m is! String).listen((message) {<br />      print("[AsyncCar] $message");<br />      if (message == #drive) _car.drive();<br />      if (message == #stop)  _car.stop();<br />      _socket.add(state);<br />    });<br />  }<br />  // ...<br />}</pre>That works, and is nicer than creating two explicit instances. There is no need for mention of full-duplex communication should I include this in the book—I can merely mention that these classes need to ignore their own messages. The best part of this solution is that it works on DartPad:<br /><br /><a href="https://dartpad.dartlang.org/aef966876bda192076c0">https://dartpad.dartlang.org/aef966876bda192076c0</a><br /><br />Still, crazy as it seems, this is not as nice as websockets which require no explanation other than "they send messages back and forth between client and server." So, unless I really need DartPad or another requirement presents itself, it looks like I love me some websockets.<br /><br /><br /><span style="color: #ccc">Day #71</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/driving-cars-with-websockets.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/program-to-distant-interfaces.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/kBsc3YolCB8" height="1" width="1" alt=""/>
