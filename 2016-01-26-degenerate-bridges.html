---
title: 'Degenerate Bridges'
layout: post
published: '2016-01-26T23:11:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/w_EoP_3xpig/degenerate-bridges.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I enjoyed last night's example implementation of the <a href="https://en.wikipedia.org/wiki/Bridge_pattern">bridge pattern</a>, though it feels unfamiliar. The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> mentions a degenerative case—that sounds right up my alley!<br /><br />In last night's example, the "refined abstraction" in the pattern was a <code>Circle</code> (<code>Shape</code> being the abstraction). In addition to supporting position and size arguments, the constructor also accepted an instance of an implementation. The example uses drawing circles on the screen as the implementation being supported:<pre class=prettyprint>class Circle extends Shape {<br />  double _x, _y, _radius;<br />  Circle(this._x, this._y, this._radius, DrawingApi api) :<br />    super(api);<br />  // ...<br />}</pre>The <code>draw()</code> method of <code>Circle</code> then delegates responsibility to the drawing API (it <i>bridge</i> the abstraction and implementation):<pre class=prettyprint>class Circle extends Shape {<br />  // ...<br />  void draw() {<br />    _drawingApi.drawCircle(_x, _y, _radius);<br />  }<br />  // ...<br />}</pre>The degenerate case does not support multiple implementations. Last night's approach accepted a <code>DrawingApi</code> instance so that multiple types of <code>DrawingApi</code> objects could be used (e.g. one for the console, one for the browser, <i>etc.</i>). But if there is only one concrete implementor, then the abstraction itself can create that implementor:<pre class=prettyprint>abstract class Shape {<br />  DrawingApi1 _drawingApi = new DrawingApi1();<br /><br />  void draw();                         <br />}</pre>In this case, the <code>Circle</code> refined abstraction does not have to worry about creating or handling the <code>DrawingApi</code>, it can just do circle things:<pre class=prettyprint>class Circle extends Shape {<br />  double _x, _y, _radius;<br />  Circle(this._x, this._y, this._radius);<br /><br />  void draw() {<br />    _drawingApi.drawCircle(_x, _y, _radius);<br />  }<br />}</pre>The <code>draw()</code> method still works through the <code>DrawingApi1</code> implementor, the only difference here is that the <code>_drawingApi</code> instance is created in the <code>Shape</code> abstraction class.<br /><br />Since there is only one implementor, there is no need for an interface. The abstraction depends directly on the concrete <code>DrawingApi1</code> implementor, which remains unchanged from yesterday's print-to-stdout barebones example:<pre class=prettyprint>class DrawingApi1 {<br />  void drawCircle(double x, double y, double radius) {<br />    print(<br />      "[DrawingApi] "<br />      "circle at ($x, $y) with "<br />      "radius ${radius.toStringAsFixed(3)}"<br />    );<br />  }<br />}</pre>Client code can then create and draw a circle with something like:<pre class=prettyprint><code>    new Circle(1.0, 2.0, 3.0)<br />      ..draw();</code></pre>That results in the desired, bridged output:<pre class=prettyprint>$ ./bin/draw.dart           <br />[DrawingApi] circle at (1.0, 2.0) with radius 3.075</pre>The question is why would I want to do something like this instead of putting drawing code directly inside <code>Circle</code>'s <code>draw()</code> method?<br /><br />The Gang of Four suggest that a change in the drawing implementation should not force client code to recompile. Dart compilation does not work that way—any change anywhere necessitates that everything get recompiled. I would think the intent behind the Gang of Four's assertion was the <a href="https://en.wikipedia.org/wiki/Single_responsibility_principle">single responsibility principle</a> and that the point is still valid in Dart. Per the SRP, a class should only have one reason to change. If the drawing code existed directly inside the <code>draw()</code> method, then <code>Circle</code> would change whenever new features are added to describe a circle <i>and</i> whenever the manner in which drawing occurs changes.<br /><br />I still do not recall ever having used even this simple case. That will mean a challenge coming up with a more real-world example for either this or the regular case. Still, it does seem worth noodling through.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/0ca4f1ac6ee8caad731e">https://dartpad.dartlang.org/0ca4f1ac6ee8caad731e</a>.</i><br /><br /><span style="color: #ccc">Day #76</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/the-bridge-pattern-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/bridge-mixins.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/w_EoP_3xpig" height="1" width="1" alt=""/>
