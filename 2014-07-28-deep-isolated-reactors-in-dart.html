---
title: 'Deep, Isolated Reactors in Dart'
layout: post
published: '2014-07-28T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/dDfQ-QzBDOE/deep-isolated-reactors-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'reactor pattern'

---

<div class=top-chain-links></div><br />I <i>think</i> that I have decent sample code the <a href="http://en.wikipedia.org/wiki/Reactor_pattern">Reactor Pattern</a> in <a href="http://dartlang.org">Dart</a>. Furthermore, I <i>think</i> I have a decent explanation for why I cannot get closer to the C++ implementation in the <a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf">original paper</a>. I think, I think, I think… What I know is that I usually get into trouble when I think.<br /><br />To have a better idea that I have replicated the spirit, if not the exact details, of the pattern described in the original paper, I would like to establish two communication channels between my isolate message sending code and the reactor loop from yesterday:<pre class=prettyprint>main() {<br />  // Spawn the message sending isolate and set its receive port as the source of<br />  // the fake select() messages<br />  var res = new ReceivePort();<br />  Select.source = res;<br />  Isolate.spawn(messageSender, res.sendPort);<br /><br />  // Create (and register in constructor) event handler<br />  new WordAcceptor();<br /><br />  // Reactor “loop” (handleEvent is recursive)<br />  new InitiationDispatcher().handleEvents();<br />}</pre>Aside from the shenanigans with the select(), this looks very much like the main loop presented in the paper. The “word acceptor” waits for the reactor to inform it of new word sending connections, at which point it creates an instance of a “word handler” which simply prints words to STDOUT.<br /><br />The problem with my current implementation is that I have the acceptor doing everything. Instead, it should follow the paper more closely—at least if I hope to better appreciate the implications. So I start with a much simpler <code>WordAcceptor</code> class:<pre class=prettyprint>class WordAcceptor implements EventHandler {<br />  WordAcceptor() {<br />    new InitiationDispatcher().registerHandler(this, 'word_connect');<br />  }<br /><br />  void handleEvent(connection) {<br />    if (connection.type != 'word_connect') return;<br />    new WordPrinter(connection.value);<br />  }<br />}</pre>As in the source paper, this registers itself with a singleton instance of the initiation dispatcher. It is looking to accept incoming connections (connections in this setup come from a separate isolate of code) with a type of <code>word_connect</code>. That is, it is accepting “word” client connections.<br /><br />The initiation dispatcher invokes the acceptor's <code>handleEvent()</code> method whenever such an event occurs. I will supply a value of a “receive port.” The port in this case is a connection back into the calling isolate—a way to communicate back with the isolate.  That value is supplied to the <code>WordPrinter</code> which, until now, has not been pulling its weight.<br /><br />The <code>WordPrinter</code> will mimic the functionality of the <code>Logging_Handler</code> from the paper. I will not have the low-level C interfaces into network devices, but it can use the isolate ports as a substitute:<pre class=prettyprint>class WordPrinter implements EventHandler {<br />  SendPort sendPort;<br />  ReceivePort receivePort;<br /><br />  StreamSubscription handle;<br /><br />  final timeout = const Duration(milliseconds: 2);<br /><br />  WordPrinter(this.sendPort) {<br />    new InitiationDispatcher()<br />      ..registerHandler(this, 'word')<br />      ..registerHandler(this, 'word_close');<br />    // ...<br />  }<br />  // ...<br />}</pre>Like the <code>WordAcceptor</code>, the <code>WordPrinter</code> needs to register itself with the reactor's dispatcher. In this case, it will handle <code>word</code> connections (to signal when words are available to be read) and <code>word_close</code> connections (to signal that there are no more words).<br /><br />The <code>sendPort</code> is the mechanism by which this printer can communicate back to the isolate sending words to be printed. The <code>WordPrinter</code> only needs to send a means for the isolate to send words directly back to the <code>WordPrinter</code>. This is very much in the spirit of the <code>Logging_Handler</code> establishing a server connection for clients once the <code>Logging_Acceptor</code> receives a connection request. The <code>WordPrinter</code> establishes a local port via which a client (the message sending isolate) can send data.<br /><br />To accomplish this, the <code>WordPrinter</code> needs its own receive port. So I add that in the constructor:<pre class=prettyprint>class WordPrinter implements EventHandler {<br />  // ...<br />  WordPrinter(this.sendPort) {<br />    new InitiationDispatcher()<br />      ..registerHandler(this, 'word')<br />      ..registerHandler(this, 'word_close');<br /><br /><b>    receivePort = new ReceivePort();<br />    sendPort.send(receivePort.sendPort);</b><br /><br />    handle = receivePort.<br />      asBroadcastStream().<br />      timeout(timeout, onTimeout: (_){ handle.pause(); }).<br />      listen(write)<br />      ..pause();<br />  }<br />  // ...<br />}<br /></pre>The timeout and the pause are how I hope to better mimic the Reactor Pattern's usage of <code>select()</code> in C++. When data is ready to be read in the C++ version, the Reactor signals the concrete event handler to read as much data is available for non-blocking read. It then yields control back to the reactor so that it can wait for more data—either from the same connection or from somewhere else. This is the very heart of the pattern, so it seems useful to <i>try</i> to simulate it here. <br /><br />So I pause the listener on the stream as soon as it is established so that control can go back to the reactor loop, which will wait until it sees a <code>word</code> event. When it does, this dispatcher invokes <code>handleEvent()</code>, which resumes the subscription handle, which reads all data available on the stream, sending it to <code>write()</code>::<pre class=prettyprint>class WordPrinter implements EventHandler {<br />  // ...<br />  void handleEvent(event) {<br /><b>    if (event.type == 'word') {<br />      read();<br />    }</b><br />    // ...<br />  }<br /><br />  void read() {<br />    handle.resume();<br />  }<br /><br />  void write(word) {<br />    print('[WordPrinter.read] $word');<br />  }<br />}<br /></pre>With that, I think I have a decent replication of the spirit of the <code>Logging_Handler</code> class from the paper, but now in Dart.<br /><br />To call this code, I use the isolate's sendPort to send the <code>word_connect</code> message. The <code>WordAcceptor</code> then creates a <code>WordPrinter</code> which replies back with a send port of its own:<pre class=prettyprint>main() {<br />  // Spawn the message sending isolate and set its receive port as the source of<br />  // the fake select() messages<br />  var res = new ReceivePort();<br />  Select.source = res;<br />  Isolate.spawn(messageSender, res.sendPort);<br /><br />  // Create (and register in constructor) event handler<br />  new WordAcceptor();<br /><br />  // Reactor “loop” (handleEvent is recursive)<br />  new InitiationDispatcher().handleEvents();<br /><br />  // NOTREACHED<br />  return 0;<br />}<br /><br /><b>void messageSender(SendPort port) {<br />  var wordSender = new ReceivePort();<br />  port.send({'type': 'word_connect', 'value': wordSender.sendPort});<br />  wordSender.<br />    first.<br />    then((SendPort s1) {<br />      s1.send({'type': 'word', 'value': 'howdy'});<br />      s1.send({'type': 'word', 'value': 'chris'});<br />      port.send({'type': 'word'});<br />    });</b><br />}</pre>Once the <code>WorkPrinter</code>'s send port comes back, I can send as many words as I like. To actually tell the reactor that non-blocking data is ready, I send a connection of type <code>word</code>.<br /><br />And that actually works. The reactor sees the messages, triggers the <code>handle_event()</code> methods in its registered event handlers, which eventually results in the right connections and ultimately words being printed. It even works if I delay sending some of the words (and then send a follow-up <code>word</code> connection):<pre class=prettyprint>$ ./bin/reactor.dart<br />[handleEvents] word_connect<br />[handleEvents] word<br />[WordPrinter.read] {type: word, value: howdy}<br />[WordPrinter.read] {type: word, value: chris}<br />[handleEvents] word<br />[WordPrinter.read] {type: word, value: delayed}<br />[WordPrinter.read] {type: word, value: howdy}<br />[WordPrinter.read] {type: word, value: chris}<br />[handleEvents] word_close</pre>To be sure, this is a loooong way to go to print out words, but it does a decent job of capturing the intent of the Reactor Pattern in Dart. Of course, Dart itself is a Reactor Pattern, so absolutely none of this is needed. But it was still fun to implement.<br /><br /><br /><br /><span style="color: #ccc">Day #136</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/isolated-reactors-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/dDfQ-QzBDOE" height="1" width="1"/>
