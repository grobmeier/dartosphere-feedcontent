---
title: 'What''s in an Invoker Name?'
layout: post
published: '2015-12-12T23:07:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/JvlSQv2De7g/whats-in-invoker-name.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I may be conflating concepts as I explore the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. Of course, I may perfectly OK in my current thinking, but tripping over terms in my mind lends doubt. So tonight I take a closer look at the invoker in the command pattern.<br /><br />The invoker is the primary motivator in the pattern, so it behooves me to get it right. I like the menu item example in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>. It makes sense that actions need to be associated with menu items—that commands need to be associated with invokers. It then follows that the application (client) needs to instantiate these commands and associate them with menu items. The remainder of the pattern is the receiver and action of the action (e.g. the application receiver and the open action). <br /><br />But I think the menu in my Velvet Fog Machine (it plays Mel Tormé, of course) is not quite right:<pre class=prettyprint>class Menu {<br />  List _history = [];<br /><br />  void call(Command c, [List args]) {<br />     c.call();<br />    _history.add(c);<br />  }<br /><br />  void undo() {<br />    var h = _history.removeLast();<br />    h.undo();<br />  }<br />}</pre>Thanks to last night's efforts, that works just fine, but perhaps I should have stuck with the GoF's menu item instead of calling it a menu. Maybe it doesn't make a difference to the pattern. If nothing else, I have the feeling it would be a stronger example if it stuck to the menu item, so let's see.<br /><br />If I were first approaching this problem, I would start not with the commands, but with the menu items on the velvet fog machine's user interface. There would be menu items for playing a single song and for manipulating playlists. When the code is initialized, it would have to associate these menu items with commands. Or, in <a href="http://dartlang.org">Dart</a>:<pre class=prettyprint><code>  // Invokers<br />  var menuPlay = <br />    new MenuItem("Play", play);<br /><br />  var menuPlaylistAdd = <br />    new MenuItem("Add to Playlist", addFromPlaylist);<br /><br />  var menuPlaylistRemove = <br />    new MenuItem("Remove From Playlist", playlistRemove);<br /><br />  var menuPlaylistClear = <br />    new MenuItem("Clear From Playlist", playlistClear);</code></pre>The commands do not change here, just the change from menu to menu-item. The resulting <code>MenuItem</code> class would then need to look something like:<pre class=prettyprint>class MenuItem {<br />  static List _history = [];<br /><br />  String name;<br />  Command command;<br />  MenuItem(name, command);<br /><br />  void call([List args]) {<br />    command.call();<br />    _history.add(command);<br />  }<br /><br />  static void undo() {<br />    var h = _history.removeLast();<br />    h.undo();<br />  }<br />}</pre>I am unsure about the history storage with this switch—that is likely a topic for another night. What I am sure is that the client code that follows now feels stronger to me. <br /><br />If I were using the Velvet Fog Machine to play <i>It Had to Be You</i>, I would press the code for the song along with the Play button (note to self, maybe button here instead of menu item). I would expect that to be already associated with a command. With the previous <code>Menu</code> approach, I wound up calling the <code>Menu</code> instance with the command and the song:<pre class=prettyprint><code>  menu.call(play, ['It Had to Be You']);<br />  menu.call(play, ['Cheek to Cheek']);</code></pre><i>Maybe</i> that is still an acceptable implementation of the command pattern, but it seems awkward at the very least.<br /><br />With the new <code>MenuItem</code> approach, a press of the Play button now results in calls like:<pre class=prettyprint><code>  menuPlay.call(['It Had to Be You']);<br />  menuPlay.call(['Cheek to Cheek']);<br /></code></pre>That makes me much happier.  The difference between <code>menu.call(play, ...)</code> and <code>menuPlay.call(...)</code> may seem small, but it is much closer to the original description the GoF. Additionally, this new approach associates the command from the outset:<pre class=prettyprint><code>  var menuPlay =<br />    new MenuItem("Play", play);</code></pre>Previously the application had to remember this association each time it needed to run the command. <br /><br />I have a clearer picture now of the pattern. I also see the invoker-as-prime-mover as an important concept in the pattern. As an added bonus, I think I see a bug in undos that I was trying to find last night. So it looks like I will be back in undo land tomorrow.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/efac76d03df17f6e3920">https://dartpad.dartlang.org/efac76d03df17f6e3920</a>.</i><br /><br /><br /><span style="color: #ccc">Day #31</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/multiple-command-undos.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/JvlSQv2De7g" height="1" width="1" alt=""/>
