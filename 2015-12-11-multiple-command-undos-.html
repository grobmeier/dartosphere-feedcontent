---
title: 'Multiple Command Undos '
layout: post
published: '2015-12-11T23:23:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/xKMXHnLqOFA/multiple-command-undos.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Do multiple receivers complicate life in the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>? My suspicion is that they do, but let's see.<br /><br />I am still working with last night's <code>VelvetFogMachine</code> and <code>Playlist</code> receiver classes in <a href="http://dartlang.org">Dart</a>. Menu items from  <code>VelvetFogMachine</code>'s user inteface initiate commands that use these two receivers in order to aid in the assembly of the ultimate collection of Mel Tormé songs. Because everyone loves Mel.<br /><br />From last night, the menu items supply arguments to the commands:<pre class=prettyprint>// ...<br />  menu.call(play, ['It Had to Be You']);<br />  // ...<br />  menu.call(addToPlaylist, ['Blue Moon']);<br />  // ...</pre>My initial inclination here is that the history mechanism, currently residing in the <code>Menu</code> class, is going to need to remember these arguments:<pre class=prettyprint>class Menu {<br />  List _history = [];<br /><br />  void call(Command c, [List args]) {<br />    if (args != null)<br />      c.call(args);<br />    else<br />      c.call();<br /><br />    _history.add([c, args]);<br />  }<br />  // ...<br />}</pre>But that is premature feature creep. For now, I stick with just adding the command to the undo history list:<pre class=prettyprint><code>    _history.add(c);</code></pre>An undo can pop the last command off the list and invoke its <code>undo()</code>:<pre class=prettyprint>class Menu {<br />  // ...<br />  void undo() {<br />    var h = _history.removeLast();<br />    print("Undoing $h");<br />    h.undo();<br />  }<br />  // ...<br />}</pre>I will start by undoing the playing of the current song:<pre class=prettyprint><code>  menu.call(play, ['It Had to Be You']);<br />  menu.call(play, ['Cheek to Cheek']);<br />  menu.undo();</code></pre>In this scenario, the velvet fog machine should stop playing <i>Cheek to Cheek</i> (something no self-respecting Mel fan would ever do) and revert to playing the previous song, <i>It Had to Be You</i>. I had thought the history would have to remember the song arguments, but I can now that I was wrong.<br /><br />When the <code>PlayCommand</code> is run, it can be responsible for knowing the previous song, which it can get from the <code>VelvetFogMachine</code>:<pre class=prettyprint>class PlayCommand implements Command {<br />  VelvetFogMachine machine;<br />  String _prevSong;<br /><br />  PlayCommand(this.machine);<br /><br />  void call([List args]) {<br />    _prevSong = machine.currentSong;<br />    machine.play(args.first);<br />  }<br />  // ...<br />}</pre>The <code>undo()</code> method can then tell the velvet fog machine to play that previous song:<pre class=prettyprint>class PlayCommand implements Command {<br />  // ...<br />  void undo() {<br />    machine.play(_prevSong);<br />  }<br />}</pre>That does the trick. When I run the following commands:<pre class=prettyprint><code>  menu.call(play, ['It Had to Be You']);<br />  menu.call(play, ['Cheek to Cheek']);<br />  menu.undo();</code></pre>The resulting output is:<pre class=prettyprint>Play It Had to Be You<br />Play Cheek to Cheek<br />Undoing Instance of 'PlayCommand'<br />Play It Had to Be You</pre>Despite that success, I am still unconvinced that the history can do without the command arguments. Let's see what happens when I try to remove and item from the playlist:<pre class=prettyprint><code>  var playlist = new Playlist([<br />    '\'Round Midnight',<br />    'It Don\'t Mean A Thing (If It Ain\'t Got That Swing)',<br />    'New York, New York',<br />    'The Lady is a Tramp'<br />  ]);<br />  menu.call(removeFromPlaylist, ['New York, New York']);<br />  menu.undo();<br />  menu.call(play, [playlist]);</code></pre>This turns out to be tricky, but not for any reason associated with the amount of information stored in history. Rather, the problem is one of reference vs. value variable assignment.<br /><br />The problem arises when storing the previous playlist when the remove command is invoked:<pre class=prettyprint>class PlaylistRemoveCommand implements Command {<br />  Playlist playlist, _prev;<br /><br />  PlaylistRemoveCommand(this.playlist);<br /><br />  void call([List args]) {<br />    _prev = playlist;<br />    print('==> [remove] $args');<br />    playlist.remove(args.first);<br />  }<br />}</pre>Since Dart passes arguments by reference, both <code>_prev</code> and <code>playlist</code> refer to the same object. So if the undo command tries to undo:<pre class=prettyprint>class PlaylistRemoveCommand implements Command {<br />  // ...<br />  void undo() {<br />    playlist.songs = _prev.songs;<br />  }<br />}<br /></pre>I am out of luck—<code>_prev.songs</code> is missing <i>New York, New York</i>.<br /><br />To work around this, I have to add a <code>clone()</code> method to the <code>Playlist</code> that copies the values in the playlist:<pre class=prettyprint>class Playlist {<br />  List&lt;String> songs = [];<br />  // ...<br />  Playlist clone() => new Playlist(songs.map((s)=> s).toList());<br />}<br /></pre>Updating the command's <code>call()</code> method to clone the playlist before storing it as a representation of the previous state should do the trick:<pre class=prettyprint>class PlaylistRemoveCommand implements Command {<br />  Playlist playlist, _prev;<br /><br />  PlaylistRemoveCommand(this.playlist);<br /><br />  void call([List args]) {<br />    _prev = playlist.clone();<br />    print('==> [remove] $args');<br />    playlist.remove(args.first);<br />  }<br /><br />  void undo() {<br />    playlist.songs = _prev.songs;<br />  }<br />}</pre>Now, undoing the remove:<pre class=prettyprint><code>  menu.call(removeFromPlaylist, ['New York, New York']);<br />  menu.undo();</code></pre>Results in:<pre class=prettyprint>==> [remove] [New York, New York]<br />Undoing Instance of 'PlaylistRemoveCommand'<br />Play 'Round Midnight<br />     It Don't Mean A Thing (If It Ain't Got That Swing)<br />     New York, New York<br />     The Lady is a Tramp</pre>So, at least for the examples that I have so far, the command objects are able to get enough information from their receivers when assembling undo information. The need for cloning receivers was not unexpected—the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> specifically mentions this as being needed. So the answer to my original question seems to be that multiple receiver type really has no effect on the complexity of command pattern code. <br /><br />I stop here for the night. Up tomorrow: I think that I have some naming issues with my menu items. I will take a closer look. Until then...<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/79cd403814429ab2a2cf">https://dartpad.dartlang.org/79cd403814429ab2a2cf</a>.</i><br /><br /><br /><span style="color: #ccc">Day #30</span>  <br /><br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/argument-passing-in-command-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/whats-in-invoker-name.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/xKMXHnLqOFA" height="1" width="1" alt=""/>
