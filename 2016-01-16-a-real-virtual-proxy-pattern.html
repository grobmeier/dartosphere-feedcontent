---
title: 'A Real Virtual Proxy Pattern'
layout: post
published: '2016-01-16T22:48:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/9ZCoLAOP32k/a-real-virtual-proxy-pattern.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />Up today, I would like to make my virtual <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> in <a href="http://dartlang.org">Dart</a> a little more tangible. Concrete if you will.<br /><br />Yesterday's example copied shamelessly from the image loading example on the Wikipedia page. Today, I modify it so that, instead of placeholder <code>print()</code> statements, I load actual images on to a page. The context of the image loading proxy pattern is an image gallery. Now, image galleries are the simplest things in the world. Until they aren't.<br /><br />Consider a personal image collection of 10,000 photos. When the page first loads, it makes sense to load the most recent 100 or so images for display. This is a nice balance between immediate feedback and swamping bandwidth and browser resources. Problems occur if the user immediately scrolls back a few years. The gallery should stop loading those initial images and get to work on the first 100 from a few years back. But if the user missed the date by a month or two, then those images should stop loading and the next batch should start. It turns out to be an interesting challenge, and one that the proxy pattern can help address.<br /><br />For this exercise, I look at individual images in the gallery. When the image first comes into view, it should display a blank image. After a brief pause (to allow other resources to stop and to ensure the user didn't start scrolling again), the image should load a low resolution version of itself. Lastly, it should load a high resolution version of the photo.<br /><br />Since there are going to be delays and waiting for loading, I changes the <code>Image</code> interface to return a future when displaying the image:<pre class=prettyprint>abstract class Image {<br />  Future displayImage();<br />}</pre>The <code>RealImage</code>, which will be the real subject in the pattern, remains relatively unchanged from last night. It is constructed with a filename and then loads that image. Instead of last night's placeholder <code>print()</code> statement, tonight I construct an HTML image element:<pre class=prettyprint>class RealImage implements Image {<br />  String _filename;<br /> ImageElement img;<br />  <br />  RealImage(this._filename) {<br />    _loadImage();<br />  }<br /><br />  void _loadImage() {<br />    print("Loading    $_filename");<br />    img = new ImageElement(src: _filename, width: 800, height: 446);<br />    img.style.border = '1px dashed grey';<br />    document.body.append(img);<br />  }<br />  // ...<br />}</pre>As for <code>diplayImage()</code>, I still leave this a little rough for ease of illustration. It allows for the <code>_filename</code> to have been changed, updating the <code>ImageElement</code>'s <code>src</code> attribute as a means of displaying the image:<pre class=prettyprint>lass RealImage implements Image {<br />  // ...<br />  Future displayImage() {<br />    print("Displaying $_filename");<br />    img.src = _filename;<br />    return new Future.value();   <br />  }<br />}</pre>Were I doing this for real, I would get the <code>Future</code> from a <code>Completer</code> that completes when the image loads. But this will do for now.<br /><br />Now for the <code>ProxyImage</code> class. I would like to construct this with three filenames / URLs: the tiny version of the image, the low resolution version of the image, and the high resolution of the image. To load the UML diagrams of the proxy pattern from the Wikipedia page, for instance, the <code>ProxyImage</code> creation might look like:<pre class=prettyprint><code>  Image image = new ProxyImage(<br />    'https://upload.wikimedia.org/wikipedia/commons/5/52/Spacer.gif',<br />    'https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/320px-Proxy_pattern_diagram.svg.png',<br />    'https://upload.wikimedia.org/wikipedia/commons/thumb/7/75/Proxy_pattern_diagram.svg/1280px-Proxy_pattern_diagram.svg.png'<br />  );</code></pre>To support that, I define three instance variables and require them in the constructor:<pre class=prettyprint>class ProxyImage implements Image {<br />  RealImage _image;<br />  String _tiny, _lo, _hi;<br /><br />  ProxyImage(this._tiny, this._lo, this._hi);<br />  // ...<br />}</pre>To put a little delay in between loading the different resolutions, I define a simple <code>_pause()</code> helper method:<pre class=prettyprint>class ProxyImage implements Image {<br />  // ...<br />  Future _pause(int s) {<br />    var c = new Completer();<br />    new Timer(new Duration(seconds: s), c.complete);<br />    return c.future;<br />  }<br />}</pre>Given a number, this method returns a future that completes in that number of seconds. With that, I can declare the <code>displayImage()</code> method:<pre class=prettyprint>class ProxyImage implements Image {<br />  // ...<br />  Future displayImage() async {<br />    if (_image != null) return _image.displayImage();<br /><br />    // Start with 1-byte blank image<br />    _image = new RealImage(_tiny)..displayImage();<br />    await _pause(1);<br />    <br />    // Load the low-res version<br />    _image<br />      .._filename = _lo<br />      ..displayImage();<br />    await _pause(5);<br />    <br />    // Then the hi-res version<br />    _image<br />      .._filename = _hi<br />      ..displayImage();<br />    return new Future.value();<br />  }<br />  // ...<br />}</pre>Since this is the proxy pattern, this proxy class forwards the proxy method <code>displayImage()</code> to the real subject. In this example, it does so three times for the tiny, low resolution, and high-resolution versions of the image.<br /><br />I again use the <a href="https://www.dartlang.org/articles/await-async/">async / await</a> syntax to clean up my <code>Future</code> code here. And clean up it does. After loading the first, tiny image, I await a pause of one second. Then, after loading the second, low resolution image, I await a pause of five seconds. Once that pause is done, the high resolution version of the real image is loaded. Again, I might return a future that completes when the image is loaded, but keep it simple by returning a <code>Future</code> that completes immediately.<br /><br />And that does the trick. The full, working version of the code is available on DartPad: <a href="https://dartpad.dartlang.org/851fe3543e94ec4bb5c0">https://dartpad.dartlang.org/851fe3543e94ec4bb5c0</a>.<br /><br />When the code is first run, a blank image is displayed. A second later, the low resolution version of the proxy pattern UML diagram displays. Then, 5 seconds after that, the full version displays. If this were part of an image gallery, the <code>ProxyImage</code> instances could be staggered to load at slightly different times from each other. The timers that pause the next higher resolution version of the image could be canceled if the user scrolls the image out of the viewport. All in all, the proxy pattern seems a neat solution for many of the concerns introduced by image galleries. <br /><br /><br /><span style="color: #ccc">Day #66</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/virtual-proxy-pattern-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/9ZCoLAOP32k" height="1" width="1" alt=""/>
