---
title: 'Writing ridiculously reusable Dart code'
layout: post
published: '2017-04-28T18:20:54+00:00'
feed: 'Stories by Matan Lurey on Medium'
link: 'https://medium.com/@matanlurey/writing-ridiculously-reusable-dart-code-1cdcf5f7b163?source=rss-abdbfcd4679f------2'
author:
    name: 'Matan Lurey'
    email: null
    url: null
tags:
    - reactive-programming
    - programming
    - javascript
    - dartlang
    - dependency-injection

---

<p>One of the most common questions I get for Dart, even within Google, is <em>“how do I make my code more reusable?”</em>. We work on large projects like <a href="http://news.dartlang.org/2016/03/the-new-adwords-ui-uses-dart-we-asked.html">AdWords</a>, <a href="http://news.dartlang.org/2016/10/google-adsense-angular-dart.html">AdSense</a>, and <a href="https://www.youtube.com/watch?v=IMNUiC2O9M8">Google’s internal CRM, Greentea</a> — which are all written in Dart.</p><figure><img alt="" src="https://cdn-images-1.medium.com/max/1024/1*O3L7lZtj1sY81D5cjp0JVg.jpeg" /><figcaption>Reusable bags are sort of like reusable code, right?</figcaption></figure><p>I was working with an engineer who was iterating on a new API for the AngularDart router, where we are modeling route changes as <a href="https://medium.com/dartlang/an-intro-to-immutability-with-dart-d4de871865c7">immutable state changes</a>:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/422c44fe6ae663c0e0ca58031825185b/href">https://medium.com/media/422c44fe6ae663c0e0ca58031825185b/href</a></iframe><p>A question was asked while developing this, though:</p><blockquote>A [large] customer says that the default behavior of stripping the query parameters as you navigate from a route to another route was not desired — they’d like to keep all query parameters.</blockquote><p>As you can see if you try the demo on <a href="https://dartpad.dartlang.org/ef8caa5da6c1144977023852914fcbd2">DartPad</a>, we print the following:</p><blockquote>Route {/ {referredId: 1234}} <br>Route {/contact {}}</blockquote><p>Let’s imagine how we’d implement that — a simple way would be to create a new <em>Route</em> object and copy the previous <em>Route</em>’s <em>query</em> field — or we can even <em>merge</em> it using the <a href="https://api.dartlang.org/stable/1.23.0/dart-core/Map/addAll.html">Map#addAll API</a>:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/cbe77a262a0600d67dc7aed88b1367ab/href">https://medium.com/media/cbe77a262a0600d67dc7aed88b1367ab/href</a></iframe><p>Now, if we look at our console, we’ll see:</p><blockquote>Route {/ {referredId: 1234}} <br>Route {/contact {referredId: 1234}}</blockquote><p>Now we’ve run into a software engineering conundrum — will <em>all</em> of our users need this functionality? If we provide <em>too little</em> flexibility, teams will fork our code or choose another product. On the other hand, providing <em>too much</em> flexibility and we’ll have built a monolith of code for a simple task.</p><p>A naive but not incorrect approach would be to add a flag:</p><blockquote>class Router {<br> final bool persistQueryParameters;</blockquote><blockquote>Router({this.persistQueryParameters: false});<br>}</blockquote><p>OK, what’s the problem here? Now you’ve <em>added to your public API</em>, and if the team comes back and says “well, we’d like to persist <em>most</em> query parameters, but not <em>these</em>” you’ll have to change your API or introduce a new flag.</p><p>What if instead we <em>injected </em>a function that lets users customize how state changes occur? Let’s try it:</p><iframe src="" width="0" height="0" frameborder="0" scrolling="no"><a href="https://medium.com/media/716b9d2a905656c296613b74788801ac/href">https://medium.com/media/716b9d2a905656c296613b74788801ac/href</a></iframe><blockquote>— — Router 1 — — <br>Route {/ {referredId: 1234}} <br>Route {/contact {}}</blockquote><blockquote>— — Router 2 — — <br>Route {/ {referredId: 1234}} <br>Route {/contact {referredId: 1234}}</blockquote><p>We’ve given a little bit of flexibility — teams can now define a transformation function that lets them define how they will transition from a previous routing state to a new one — without hard-coding the transformation a specific team wanted.</p><p>Do you have your own strategies for writing <em>ridiculously </em>reusable Dart code?</p><img src="https://medium.com/_/stat?event=post.clientViewed&referrerSource=full_rss&postId=1cdcf5f7b163" width="1" height="1">
