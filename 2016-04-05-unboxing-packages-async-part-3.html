---
title: 'Unboxing Packages: async Part 3'
layout: post
published: '2016-04-05T13:32:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/04/unboxing-packages-async-part-3.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p>We’ve covered <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html">individual values</a> and we’ve covered <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html">streams</a>, but there are still a few more goodies available in the <a href="https://pub.dartlang.org/packages/async"><code>async</code></a> package. These don’t fit neatly in either bucket, but when you run into situations that call for them, they’re still plenty useful.</p>   <h2 id="wrappers">Wrappers</h2> <p>Just like the <a href="http://news.dartlang.org/2016/01/unboxing-packages-collection.html#wrappers"><code>collection</code> package</a>, <code>async</code> provides a set of wrapper classes. Each of these classes implements a <code>dart:async</code> class and forwards all calls to an inner instance of that class. This makes it easy for users to provide customized versions of those classes. In fact, the <code>async</code> package itself uses some of its own wrappers.</p> <p>There’s a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/DelegatingFuture-class.html"><code>DelegatingFuture</code></a> class, of course. There’s also a <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/DelegatingStreamSubscription-class.html"><code>DelegatingStreamSubscription</code></a>, and wrappers for every kind of sink or consumer you can name: <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/DelegatingSink-class.html"><code>DelegatingSink</code></a>, <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/DelegatingEventSink-class.html"><code>DelegatingEventSink</code></a>, <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/DelegatingStreamConsumer-class.html"><code>DelegatingStreamConsumer</code></a>, and of course <a href="https://www.dartdocs.org/documentation/async/1.8.0/dart.pkg.async/DelegatingStreamSink-class.html"><code>DelegatingStreamSink</code></a>. Of these, <code>DelegatingStreamSink</code> is used most often since it encompasses all the functionality of the other classes.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// A [StreamSink] that takes extra arguments for [close].</span><span class="pln"><br /></span><span class="kwd">class</span><span class="pln"> </span><span class="typ">WebSocketSink</span><span class="pln"> </span><span class="kwd">extends</span><span class="pln"> </span><span class="typ">DelegatingStreamSink</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">final</span><span class="pln"> </span><span class="typ">WebSocket</span><span class="pln"> _webSocket</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="typ">WebSocketSink</span><span class="pun">(</span><span class="typ">WebSocket</span><span class="pln"> webSocket</span><span class="pun">)</span><span class="pln"><br />      </span><span class="pun">:</span><span class="pln"> </span><span class="kwd">super</span><span class="pun">(</span><span class="pln">webSocket</span><span class="pun">),</span><span class="pln"><br />        _webSocket </span><span class="pun">=</span><span class="pln"> webSocket</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="com">/// Closes the web socket connection with the given [code] and [reason].</span><span class="pln"><br />  </span><span class="typ">Future</span><span class="pln"> close</span><span class="pun">([</span><span class="kwd">int</span><span class="pln"> code</span><span class="pun">,</span><span class="pln"> </span><span class="typ">String</span><span class="pln"> reason</span><span class="pun">])</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> _webSocket</span><span class="pun">.</span><span class="pln">close</span><span class="pun">(</span><span class="pln">code</span><span class="pun">,</span><span class="pln"> reason</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>You may notice that there’s no <code>DelegatingStream</code>. That’s because it already exists in the core libraries! It’s called <a href="https://api.dartlang.org/latest/dart-async/StreamView-class.html"><code>StreamView</code></a>, and it’s in <code>dart:async</code>. Its presence in the core libraries and its inconsistent name are historical accidents, and at some point we may add a <code>DelegatingStream</code> that just directly extends <code>StreamView</code> for consistency.</p> <h2 id="restartabletimer"><code>RestartableTimer</code></h2> <p>The <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/RestartableTimer-class.html"><code>RestartableTimer</code></a> class is very small, but despite that I think it’s useful enough to warrant a mention here. It’s a subclass of <a href="https://api.dartlang.org/latest/dart-async/Timer-class.html"><code>Timer</code></a>, and <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/RestartableTimer/RestartableTimer.html"><code>new RestartableTimer()</code></a>, <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/RestartableTimer/isActive.html"><code>isActive</code></a>, and <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/RestartableTimer/cancel.html"><code>cancel()</code></a> all work just the same as the superclass.</p> <p>The big difference is the all-new <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/RestartableTimer/reset.html"><code>reset()</code></a> method. This restarts the timer, with its original timer and callback. It’ll start counting down again whether or not it already fired, which means that the callback can be called more than once.</p> <p>This is really useful for implementing a <a href="https://en.wikipedia.org/wiki/Heartbeat_%28computing%29">heartbeat</a>—for example, in <a href="pub.dartlang.org/packages/test"><code>test</code></a>, we use a <code>RestartableTimer</code> to time out a test if it doesn’t interact with the test framework for too long.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">class</span><span class="pln"> </span><span class="typ">Invoker</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">RestartableTimer</span><span class="pln"> _timeoutTimer</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="typ">Invoker</span><span class="pun">(...)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    _timeoutTimer </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RestartableTimer</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Duration</span><span class="pun">(</span><span class="pln">seconds</span><span class="pun">:</span><span class="pln"> </span><span class="lit">30</span><span class="pun">),</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />      registerException</span><span class="pun">(</span><span class="str">"The test timed out."</span><span class="pun">);</span><span class="pln"><br />    </span><span class="pun">});</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /><br />  </span><span class="com">// Functions like `expect()` call this to notify the test runner that the test</span><span class="pln"><br />  </span><span class="com">// is still doing work. If it's not called for thirty seconds, the test times</span><span class="pln"><br />  </span><span class="com">// out.</span><span class="pln"><br />  </span><span class="kwd">void</span><span class="pln"> heartbeat</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    _timeoutTimer</span><span class="pun">.</span><span class="pln">reset</span><span class="pun">();</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <h2 id="stream-sink-utilities">Stream Sink Utilities</h2> <p>Conceptually, streams have two ends: the <code>Stream</code> object is where events are emitted, and it’s where most of the complexity lies, but for every <code>Stream</code> there’s a <a href="https://api.dartlang.org/latest/dart-async/StreamSink-class.html"><code>StreamSink</code></a> behind the scenes feeding it events. If your code is the one in charge of that sink, you may need utilities for dealing with them, and the <code>async</code> package is ready to serve.</p>   <h3 id="streamsinktransformer"><code>StreamSinkTransformer</code></h3> <p>The core <code>dart:async</code> library includes a <a href="https://api.dartlang.org/latest/dart-async/StreamTransformer-class.html"><code>StreamTransformer</code></a> class, which provides an abstraction for transforming streams in a predefined way. The core libraries use it for converters for formats like <a href="https://api.dartlang.org/stable/1.15.0/dart-convert/JsonEncoder-class.html">JSON</a> and <a href="https://api.dartlang.org/stable/1.15.0/dart-convert/Utf8Decoder-class.html">UTF-8</a>. But there’s no core library class for transforming <code>StreamSink</code>s, so <code>async</code> steps in to pick up the slack.</p> <p>The <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkTransformer-class.html"><code>StreamSinkTransformer</code></a> class works almost exactly like <code>StreamTransformer</code>: you pass in a sink to <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkTransformer/bind.html"><code>bind()</code></a>, and it returns a new sink that’s transformed according to the transformer’s internal logic. It also has a <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkTransformer/StreamSinkTransformer.fromHandlers.html"><code>new StreamSinkTransformer.fromHandlers()</code></a> transformer that’s just like <a href="https://api.dartlang.org/latest/dart-async/StreamTransformer/StreamTransformer.fromHandlers.html"><code>new StreamTransformer.fromHandlers()</code></a>: it invokes the handlers when the corresponding events are added to the transformed sink.</p> <p>The one novel API is the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkTransformer/StreamSinkTransformer.fromStreamTransformer.html"><code>new StreamSinkTransformer.fromStreamTransformer()</code></a> constructor. This transforms a <code>StreamTransformer</code> into a corresponding <code>SinkTransformer</code>, which lets you take advantage of all the useful transformers in the core libraries.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="pln">main</span><span class="pun">()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  </span><span class="com">// WebSocket implements both Stream and StreamSink. We want to communicate</span><span class="pln"><br />  </span><span class="com">// using JSON, so we decode the streamed events and encode the events added to</span><span class="pln"><br />  </span><span class="com">// the sink.</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> socket </span><span class="pun">=</span><span class="pln"> await </span><span class="typ">WebSocket</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="str">"ws://example.com"</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> stream </span><span class="pun">=</span><span class="pln"> socket</span><span class="pun">.</span><span class="pln">transform</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">decoder</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> sink </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">const</span><span class="pln"> </span><span class="typ">StreamSinkTransformer</span><span class="pun">.</span><span class="pln">fromStreamTransformer</span><span class="pun">(</span><span class="pln">JSON</span><span class="pun">.</span><span class="pln">encoder</span><span class="pun">)</span><span class="pln"><br />      </span><span class="pun">.</span><span class="pln">bind</span><span class="pun">(</span><span class="pln">socket</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="com">// ...</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <h3 id="streamsinkcompleter"><code>StreamSinkCompleter</code></h3> <p>This complements a class, not from the core libraries, but from the <code>async</code> package itself. In my last article, I talked about <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html#streamcompleter"><code>StreamCompleter</code></a>, which allows you to return a stream immediately when that stream is only actually generated later on. <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkCompleter-class.html"><code>StreamSinkCompleter</code></a> performs the same role, but for sinks.</p> <p>The API is pretty much entirely parallel to <code>StreamCompleter</code>: the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkCompleter/sink.html"><code>sink</code></a> getter returns the sink that’s being completed, and the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkCompleter/setDestinationSink.html"><code>setDestinationSink()</code></a> method sets the underlying implementation of that sink. There’s even a <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkCompleter/fromFuture.html"><code>StreamSink.fromFuture()</code></a> method that directly converts a <code>Future&lt;StreamSink&gt;</code> into a <code>StreamSink</code>.</p> <p>There is a bit of extra subtlety with the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamSinkCompleter/setError.html"><code>setError()</code></a> method, though. Sinks don’t emit events the same way streams do, but they do have a way of surfacing errors: the <a href="https://api.dartlang.org/stable/1.15.0/dart-async/StreamSink/done.html"><code>done</code></a> future. So when you call <code>setError()</code>, it causes the sink to ignore all events that are added and emit the given error through <code>done</code>.</p> <h2 id="streamqueue"><code>StreamQueue</code></h2> <p><a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue-class.html"><code>StreamQueue</code></a> may be my favorite of all the APIs in the <code>async</code> package. It straddles the boundary between streams and individual values by taking a stream—which operates by pushing events to callbacks—and exposing a pull-based API structured mostly around futures.</p> <p>The simplest example is the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue/next.html"><code>next</code></a> getter, which returns a future that completes to the next value in the stream. So the first time you call it, it returns the first event. Then it’ll return the second event, then the third, and so on. This is all true even if you call it multiple times before the first future completes—<code>StreamQueue</code> keeps track of which future events belong to which futures.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> queue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamQueue</span><span class="pun">(</span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Stream</span><span class="pun">.</span><span class="pln">fromIterable</span><span class="pun">([</span><span class="lit">1</span><span class="pun">,</span><span class="pln"> </span><span class="lit">2</span><span class="pun">,</span><span class="pln"> </span><span class="lit">3</span><span class="pun">]));</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> first </span><span class="pun">=</span><span class="pln"> queue</span><span class="pun">.</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> second </span><span class="pun">=</span><span class="pln"> queue</span><span class="pun">.</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> third </span><span class="pun">=</span><span class="pln"> queue</span><span class="pun">.</span><span class="kwd">next</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">await </span><span class="typ">Future</span><span class="pun">.</span><span class="pln">wait</span><span class="pun">([</span><span class="pln">first</span><span class="pun">,</span><span class="pln"> second</span><span class="pun">,</span><span class="pln"> third</span><span class="pun">]));</span><span class="pln"> </span><span class="com">// =&gt; [1, 2, 3]</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>If you call <code>next</code> and there turn out to be no events left in the stream, it’ll complete with a <code>StateError</code>. If you’re worried about this, you can check <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue/hasNext.html"><code>hasNext</code></a> first to see if such a value exists.</p> <p>There’s a <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue/take.html"><code>take()</code></a> method, which consumes a given number of events and returns a list containing them—or just all the remaining values, if there are fewer than the given number. There’s also <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue/skip.html"><code>skip()</code></a>, which is like <code>take()</code> except that it ignores the values entirely.</p> <p>If you have a <code>StreamQueue</code> and you want a stream instead, you can use the <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue/rest.html"><code>rest</code></a> getter. This returns the portion of the underlying stream <em>after</em> all the reserved events. We can use it to re-write the <code>firstAndRest()</code> function from <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-2.html#subscriptionstream">my last article</a>:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Calls [onFirst] with the first event emitted by [source].</span><span class="pln"><br /></span><span class="com">///</span><span class="pln"><br /></span><span class="com">/// Returns a stream that emits all events in [source] after the first.</span><span class="pln"><br /></span><span class="typ">Stream</span><span class="pln"> firstAndRest</span><span class="pun">(</span><span class="typ">Stream</span><span class="pln"> source</span><span class="pun">,</span><span class="pln"> </span><span class="kwd">void</span><span class="pln"> onFirst</span><span class="pun">(</span><span class="pln">value</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> queue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamQueue</span><span class="pun">(</span><span class="pln">source</span><span class="pun">);</span><span class="pln"><br />  queue</span><span class="pun">.</span><span class="kwd">next</span><span class="pun">.</span><span class="kwd">then</span><span class="pun">(</span><span class="pln">onFirst</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> queue</span><span class="pun">.</span><span class="pln">rest</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>Finally, when you’re done with a queue, you can call <a href="https://www.dartdocs.org/documentation/async/1.9.0/async/StreamQueue/cancel.html"><code>cancel()</code></a>. This cancels the subscription to the underlying stream, but by default, it waits to do so until after the stream fires enough events to complete all outstanding futures from <code>next</code> and friends. However, if you pass <code>immediate: true</code>, it’ll cancel the subscription right away instead. The outstanding futures will complete as though the stream had closed.</p> <p><code>StreamQueue</code> is particularly useful for testing streams. It lets you write very straightforward code that just tests each event in series, rather than fiddling around explicit calls to <code>Stream.listen()</code>. For example, here’s a real test for <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html#cancelableoperation"><code>CancelableOperation</code></a>:</p> <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  test</span><span class="pun">(</span><span class="str">"asStream() emits an error and then closes"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> completer </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">CancelableCompleter</span><span class="pun">();</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> queue </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamQueue</span><span class="pun">(</span><span class="pln">completer</span><span class="pun">.</span><span class="pln">operation</span><span class="pun">.</span><span class="pln">asStream</span><span class="pun">());</span><span class="pln"><br />    expect</span><span class="pun">(</span><span class="pln">queue</span><span class="pun">.</span><span class="kwd">next</span><span class="pun">,</span><span class="pln"> throwsA</span><span class="pun">(</span><span class="str">"error"</span><span class="pun">));</span><span class="pln"><br />    expect</span><span class="pun">(</span><span class="pln">queue</span><span class="pun">.</span><span class="pln">hasNext</span><span class="pun">,</span><span class="pln"> isFalse</span><span class="pun">);</span><span class="pln"><br />    completer</span><span class="pun">.</span><span class="pln">completeError</span><span class="pun">(</span><span class="str">"error"</span><span class="pun">);</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>In addition to writing great blog posts about cool packages, I maintain the <a href="https://pub.dartlang.org/packages/test"><code>test</code></a> package, and one of my long-term plans is to introduce a set of stream matchers. These matchers will be heavily based on <code>StreamQueue</code>, since it’s so handy for moving through a stream event by event.</p>   <h2 id="isempty"><code>isEmpty</code></h2> <p>Three articles later, and I’m finally done showing off everything cool in the <code>async</code> package—at least until more cool stuff gets added! Master these tools and you’ll be well on your way to being an asynchrony expert. Maybe you’ll even find some unfilled needs, work up a solution, and <a href="https://github.com/dart-lang/async/pulls">send us a pull request</a>!</p> <p>Come back again in two weeks when I talk about a package that builds a brand new abstraction on top of <code>async</code>.</p>
