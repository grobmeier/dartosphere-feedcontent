---
title: 'Unboxing Packages: stream_channel'
layout: post
published: '2016-04-26T11:58:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/04/unboxing-packages-streamchannel.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p>The <a href="https://pub.dartlang.org/packages/stream_channel"><code>stream_channel</code></a> package is the youngest I’ve written about so far—the first version was published on 28 January 2016, only three months ago as I write this! But despite its youth, it fills a very important role in the Dart ecosystem by providing a common abstraction for two-way communication.</p> <p>In <a href="http://news.dartlang.org/2016/02/one-of-best-aspects-of-package.html">my article on <code>source_span</code></a>, I wrote about how important it is for a package ecosystem to provide common conventions that can be used throughout the language. <code>stream_channel</code> is another great example of that. <a href="https://www.dartdocs.org/documentation/stream_channel/latest/index.html">The core API</a> it provides is extremely simple, just two getters and a set of rules for them to follow, but the ability for Dart code to implement protocols independent of the underlying implementation is profound.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">abstract</span><span class="pln"> </span><span class="kwd">class</span><span class="pln"> </span><span class="typ">StreamChannel</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">Stream</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> stream</span><span class="pun">;</span><span class="pln"><br />  </span><span class="typ">StreamSink</span><span class="pun">&lt;</span><span class="pln">T</span><span class="pun">&gt;</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> sink</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>The <a href="https://pub.dartlang.org/packages/test"><code>test</code></a> package uses <code>StreamChannel</code> to implement a protocol for running tests that works whether the tests are in an isolate, a separate process, or even an iframe in a browser window. The <a href="https://pub.dartlang.org/packages/web_socket_channel"><code>web_socket_channel</code></a> package uses it to define a common API for WebSockets that works the same on all platforms. And having a common API means that it’s also possible to create common utility classes in the style of the <a href="http://news.dartlang.org/2016/03/unboxing-packages-async-part-1.html"><code>async</code></a> package.</p>   <h2 id="the-rules">The Rules</h2> <p>As nice and simple as the API is, it’s important to note that there’s more to being a stream channel. A channel is logically a single entity, which means that the two APIs it exposes—its stream and its sink—have to work in concert with one another. So there are a set of rules that all valid implementations of <code>StreamChannel</code> must follow. These rules are designed to make it easy for users to interact with stream channels without leaving resources dangling or errors unhandled.</p> <p>They also model the behavior of the <code>dart:io</code> <a href="https://api.dartlang.org/stable/1.15.0/dart-io/WebSocket-class.html"><code>WebSocket</code></a> class almost exactly. Since it’s the only core library API that provides a connected stream and sink, it inspired a lot of the initial stream channel design.</p>   <h3 id="single-subscription">Single-Subscription</h3> <p>The core SDK defines two types of streams. The <a href="https://api.dartlang.org/stable/latest/dart-async/Stream/listen.html"><code>listen()</code></a> method may be called any number of times for broadcast streams, but only once for single-subscription streams. The first rule of stream channels is that <strong>the stream must be single-subscription</strong>. This is the default for streams, so most users will assume it unless stated otherwise, but it’s important to be explicit.</p> <h3 id="stream-closure">Stream Closure</h3> <p>Most of the rules have to do with the stream and/or the sink closing. This is no coincidence: the moment a channel is closed is one of the highest-risk times for logic errors, because resources can fail to be freed and events can happen in unexpected orders. The second rule addresses this: <strong>once the sink is closed, the stream closes without emitting any more events</strong>.</p> <p>This means that the callback passed to <code>stream.listen()</code> won’t ever be called once <a href="https://api.dartlang.org/stable/latest/dart-async/StreamSink/close.html"><code>sink.close()</code></a> is called. It eliminates a whole class of potential bugs where an event could sneak in before the underlying channel was fully closed.</p> <h3 id="sink-closure">Sink Closure</h3> <p>The third rule is the inverse of the second: <strong>once the stream closes, the sink silently drops all events</strong>. This means that if your code receives an <code>onDone</code> event from the stream, it doesn’t need to do any extra work to avoid calling sink methods; they just automatically don’t do anything, guaranteed.</p> <p>This and the stream closure rule work together to ensure that both components of the channel agree about whether it’s open or closed. Having a single canonical state makes channels more straightforward to work with and reason about, and give the user a consistent way to control and react to that state.</p> <h3 id="subscription-canceling">Subscription Canceling</h3> <p>The fourth rule is unusual in that it’s about a connection that <em>shouldn’t</em> exist between the stream and the sink. It says that <strong>canceling the stream’s subscription has no effect on the sink</strong>. This means that the only way for the channel to be closed locally is by calling <code>sink.close()</code>—code that’s dealing with the sink can be confident that only it (and the remote endpoint) is in charge of the channel’s connection.</p>   <h3 id="error-bouncing">Error Bouncing</h3> <p>The fifth rule only applies to channels that don’t have a way of transmitting arbitrary errors to the remote endpoint. <strong>If a channel can’t transmit an error, it closes and forwards the error to the sink</strong>—in particular, to the <a href="https://api.dartlang.org/stable/latest/dart-async/StreamSink/done.html"><code>sink.done</code></a> future. Errors sent to a channel that can’t handle them are probably caused by bugs in the program, and forwarding them to <code>done</code> makes it possible to handle them without making them look like events from the remote endpoint.</p>   <h3 id="early-closure">Early Closure</h3> <p>The sixth and final rule is less of a requirement and more of a guideline. <strong>If the stream closes before it has a listener, the sink should silently drop all events if possible</strong>, but only <em>if possible</em>. This is tricky because the connection may not be established at all until the stream has a listener, and if it’s not established there might be no way to tell when the stream closes. But if it is possible, this ensures that no events are sent over a channel that the user expects to be closed.</p>   <h2 id="premade-stream-channels">Premade Stream Channels</h2> <p>Even in the few short months that <code>stream_channel</code> has existed, there are already a few classes that implement the interface to wrap commonly-used two-way communication channels.</p>   <h3 id="isolatechannel"><code>IsolateChannel</code></h3> <p>The <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/IsolateChannel-class.html"><code>IsolateChannel</code></a> class is part of the <code>stream_channel</code> package. Its default constructor, <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/IsolateChannel/IsolateChannel.html"><code>new IsolateChannel()</code></a>, simply wraps an existing <a href="https://api.dartlang.org/stable/latest/dart-isolate/ReceivePort-class.html"><code>ReceivePort</code></a> and a <a href="https://api.dartlang.org/stable/latest/dart-isolate/SendPort-class.html"><code>SendPort</code></a> in a stream channel.</p> <p>That’s great if you already have both ports, but what if you’re establishing the initial connection? Anyone who’s written a bunch of isolate code knows what a pain it is to correctly do the dance of sending a port that sends back another port to establish a two-way connection. To make that easier, <code>IsolateChannel</code> provides two utility constructors. <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/IsolateChannel/IsolateChannel.connectReceive.html"><code>new IsolateChannel.connectReceive()</code></a> takes a <code>ReceivePort</code>, and <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/IsolateChannel/IsolateChannel.connectSend.html"><code>new IsolateChannel.connectSend()</code></a> takes the attached <code>SendPort</code>. They then use an internal protocol to connect ports going the other direction so you don’t have to worry about it.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Spawns a worker isolate and returns a [StreamChannel] for communicating with</span><span class="pln"><br /></span><span class="com">/// it.</span><span class="pln"><br /></span><span class="typ">Future</span><span class="pun">&lt;</span><span class="typ">StreamChannel</span><span class="pun">&gt;</span><span class="pln"> spawnWorker</span><span class="pun">()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> port </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">ReceivePort</span><span class="pun">();</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> isolate </span><span class="pun">=</span><span class="pln"> await </span><span class="typ">Isolate</span><span class="pun">.</span><span class="pln">spawn</span><span class="pun">(</span><span class="pln">worker</span><span class="pun">,</span><span class="pln"> port</span><span class="pun">.</span><span class="pln">sendPort</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IsolateChannel</span><span class="pun">.</span><span class="pln">connectReceive</span><span class="pun">(</span><span class="pln">port</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br /></span><span class="com">/// The entrypoint for the worker isolate.</span><span class="pln"><br /></span><span class="kwd">void</span><span class="pln"> worker</span><span class="pun">(</span><span class="typ">SendPort</span><span class="pln"> port</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> channel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">IsolateChannel</span><span class="pun">.</span><span class="pln">connectSend</span><span class="pun">(</span><span class="pln">port</span><span class="pun">);</span><span class="pln"><br />  </span><span class="com">/// ...</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h3 id="websocketchannel"><code>WebSocketChannel</code></h3> <p>This isn’t strictly part of the <code>stream_channel</code> package, but the <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/web_socket_channel/WebSocketChannel-class.html"><code>WebSocketChannel</code></a> class defined in the <code>web_socket_channel</code> package is another great example of a stream channel. It has two concrete implementations: <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/io/IOWebSocketChannel-class.html"><code>IOWebSocketChannel</code></a> wraps the <code>WebSocket</code> class from <code>dart:io</code>, whereas <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/html/HtmlWebSocketChannel-class.html"><code>HtmlWebSocketChannel</code></a> wraps the one from <code>dart:html</code>.</p> <p>Both implementations have one constructor that <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/html/HtmlWebSocketChannel/HtmlWebSocketChannel.html">wraps the underlying class</a>, as well as another that <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/io/IOWebSocketChannel/IOWebSocketChannel.connect.html">opens a new connection</a>. Otherwise, they provide pretty much the same API (with <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/html/HtmlWebSocketChannel/bufferedAmount.html">one platform-specific getter</a>).</p> <p><code>WebSocketChannel</code> is particularly interesting because it’s not <em>just</em> a vanilla <code>StreamChannel</code>. It provides a few additional APIs: <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/web_socket_channel/WebSocketChannel/protocol.html"><code>protocol</code></a> includes the meta-protocol if one was negotiated, and if the socket is closed by the remote end point <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/web_socket_channel/WebSocketChannel/closeCode.html"><code>closeCode</code></a> and <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/web_socket_channel/WebSocketChannel/closeReason.html"><code>closeReason</code></a> indicate why. Its sink is also a custom subclass whose <a href="https://www.dartdocs.org/documentation/web_socket_channel/latest/web_socket_channel/WebSocketSink/close.html"><code>close()</code></a> method allows the user to specify their own code and reason.</p>   <h2 id="creating-new-stream-channels">Creating New Stream Channels</h2> <p>If you need a stream channel for a different kind of underlying communication channel, you may need to create your own. You could just call <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/StreamChannel/StreamChannel.html"><code>new StreamChannel()</code></a> with a stream and a sink, but be careful: if your stream and sink don’t satisfy the rules I described above, you’re liable to run into some really tricky bugs.</p> <p>The <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/StreamChannel/StreamChannel.withGuarantees.html"><code>new StreamChannel.withGuarantees()</code></a> constructor is much safer, at the cost of providing some extra layers of wrapping. It ensures that, regardless of the behavior of the stream and sink that are passed in, the ones exposed by the channel satisfy all the rules.</p>   <h3 id="streamchannelcontroller"><code>StreamChannelController</code></h3> <p>If you don’t have a preexisting stream and sink, you can create a channel from scratch using the <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/StreamChannelController/StreamChannelController.html"><code>StreamChannelController</code></a> class. This exposes two stream channels. The code managing the controller interacts directly with the <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/StreamChannelController/local.html"><code>local</code></a> channel. This is connected to the <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/StreamChannelController/foreign.html"><code>foreign</code></a> channel, which is meant to be returned to be used by external code.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Returns a [StreamChannel] that communicates over [port].</span><span class="pln"><br /></span><span class="typ">StreamChannel</span><span class="pln"> messagePortChannel</span><span class="pun">(</span><span class="typ">MessagePort</span><span class="pln"> port</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> controller </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StreamChannelController</span><span class="pun">(</span><span class="pln">allowForeignErrors</span><span class="pun">:</span><span class="pln"> </span><span class="kwd">false</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="com">// Pipe all events from the message port into the local sink...</span><span class="pln"><br />  port</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">((</span><span class="pln">message</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> controller</span><span class="pun">.</span><span class="kwd">local</span><span class="pun">.</span><span class="pln">sink</span><span class="pun">.</span><span class="pln">add</span><span class="pun">(</span><span class="pln">message</span><span class="pun">.</span><span class="pln">data</span><span class="pun">));</span><span class="pln"><br /><br />  </span><span class="com">// ...and all events from the local stream into the send port.</span><span class="pln"><br />  controller</span><span class="pun">.</span><span class="kwd">local</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">(</span><span class="pln">port</span><span class="pun">.</span><span class="pln">postMessage</span><span class="pun">,</span><span class="pln"> onDone</span><span class="pun">:</span><span class="pln"> port</span><span class="pun">.</span><span class="pln">close</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="com">// Then return the foreign controller for your users to use.</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> controller</span><span class="pun">.</span><span class="pln">foreign</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p><code>StreamChannelController</code> automatically ensures that the stream channel rules are satisfied for both the local and remote channels. The <code>allowForeignErrors</code> parameter to the constructor controls how error bouncing is handled. By default, errors are passed straight from the foreign channel to the local one. But if there’s no way to deal with those errors, <code>allowForeignErrors: false</code> can be passed to forward those errors to <code>foreign.sink.done</code> instead.</p>   <h2 id="multichannel"><code>MultiChannel</code></h2> <p>I’ll finish this article by talking about one of the coolest stream channel utility classes. <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/MultiChannel-class.html"><code>MultiChannel</code></a> allows multiple independent virtual channels to communicate over a single underlying channel—it’s similar to having multiple <code>SendPort</code>s all communicating with different parts of the same isolate, but it works across any channel at all.</p> <p>The <code>MultiChannel</code> is itself a stream channel, and it’s usually used to establish the initial connection. But the most important part of the class is its virtual channels, which are created using the <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/MultiChannel/virtualChannel.html"><code>virtualChannel()</code></a> method. Each <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/VirtualChannel-class.html"><code>VirtualChannel</code></a> provides an opaque <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/VirtualChannel/id.html"><code>id</code></a> that the remote endpoint can pass to <code>virtualChannel()</code> to create its own virtual channel connected to the local one.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Serializes [test] into a JSON-safe map.</span><span class="pln"><br /></span><span class="typ">Map</span><span class="pln"> serializeTest</span><span class="pun">(</span><span class="typ">MultiChannel</span><span class="pln"> channel</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Test</span><span class="pln"> test</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="com">// Create a virtual channel for the test so that the remote endpoint can tell</span><span class="pln"><br />  </span><span class="com">// us to run it.</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> testChannel </span><span class="pun">=</span><span class="pln"> channel</span><span class="pun">.</span><span class="pln">virtualChannel</span><span class="pun">();</span><span class="pln"><br />  testChannel</span><span class="pun">.</span><span class="pln">stream</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">((</span><span class="pln">message</span><span class="pun">)</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">assert</span><span class="pun">(</span><span class="pln">message</span><span class="pun">[</span><span class="str">'command'</span><span class="pun">]</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">'run'</span><span class="pun">);</span><span class="pln"><br />    testChannel</span><span class="pun">.</span><span class="pln">add</span><span class="pun">({</span><span class="str">"result"</span><span class="pun">:</span><span class="pln"> await test</span><span class="pun">.</span><span class="pln">run</span><span class="pun">()});</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br /><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="str">"type"</span><span class="pun">:</span><span class="pln"> </span><span class="str">"test"</span><span class="pun">,</span><span class="pln"><br />    </span><span class="str">"name"</span><span class="pun">:</span><span class="pln"> test</span><span class="pun">.</span><span class="pln">name</span><span class="pun">,</span><span class="pln"><br />    </span><span class="str">"channel"</span><span class="pun">:</span><span class="pln"> testChannel</span><span class="pun">.</span><span class="pln">id<br />  </span><span class="pun">};</span><span class="pln"><br /></span><span class="pun">}</span><span class="pln"><br /><br /></span><span class="com">/// Deserializes [test] into a concrete [Test] class.</span><span class="pln"><br /></span><span class="typ">Test</span><span class="pln"> deserializeTest</span><span class="pun">(</span><span class="typ">MultiChannel</span><span class="pln"> channel</span><span class="pun">,</span><span class="pln"> </span><span class="typ">Map</span><span class="pln"> test</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="com">// Create a virtual channel connected to the one created in [serializeTest].</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> testChannel </span><span class="pun">=</span><span class="pln"> channel</span><span class="pun">.</span><span class="pln">virtualChannel</span><span class="pun">(</span><span class="pln">test</span><span class="pun">[</span><span class="str">'channel'</span><span class="pun">]);</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Test</span><span class="pun">(</span><span class="pln">test</span><span class="pun">[</span><span class="str">'name'</span><span class="pun">],</span><span class="pln"> testChannel</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>The underlying stream is only closed once the initial <code>MultiChannel</code> and <em>all</em> virtual channels are closed. This lets the channels remain fully independent, but it also means it’s important to be scrupulous about closing them when their job is done.</p>   <h2 id="sink-or-stream">Sink or Stream</h2> <p>This isn’t quite everything in the <code>stream_channel</code> package, but it’s all the most important parts. You’ll just have to check out <a href="https://www.dartdocs.org/documentation/stream_channel/latest/stream_channel/stream_channel-library.html">the API docs</a> for the rest! And next time you need two-way communication, you know where to look.</p> <p>Join me next week when I talk about a package that’s built on top of <code>stream_channel</code>.</p>
