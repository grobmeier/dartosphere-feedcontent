---
title: 'Factory Method Pattern and Polymer Paper Elements'
layout: post
published: '2016-02-10T23:40:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/byZWKwRCWWs/factory-method-pattern-and-polymer.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />I may regret this, but my web-based <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory method pattern</a> example lacked a "modern" touch. Well, that's not entirely true, it could add relatively new input elements like number, telephone, and week inputs to a form:<br /><br /><a href="https://3.bp.blogspot.com/-qn9fFNFYFxE/VrwwIOxJ7XI/AAAAAAABD8Y/p3neI4EszAc/s1600/01-build_old_factories.png" imageanchor="1" ><img border="0" src="https://3.bp.blogspot.com/-qn9fFNFYFxE/VrwwIOxJ7XI/AAAAAAABD8Y/p3neI4EszAc/s640/01-build_old_factories.png" width=570 /></a><br /><br />But darn it, what about awesome <a href="http://www.polymer-project.org/docs/elements/paper-elements.html">Paper Elements</a>? Will a <code>&lt;paper-input></code> element serve as a product of the pattern? It sure would be neat if I could simply drop it into the pattern without many changes.<br /><br />But alas, it seems that some changes are going to be required. Even though it behaves like an input field, the <a href="https://www.dartdocs.org/documentation/paper_elements/0.7.1/paper_elements.paper_input/PaperInput-class.html">PaperInput</a> class implements <code>HtmlElement</code>, not <code>InputElement</code> like my <code>FormBuilder</code> class wants:<pre class=prettyprint>abstract class FormBuilder {<br />  // ...<br />  void addInput() {<br />    var input = _labelFor(inputElement);<br />    container.append(input);<br />  }<br />  InputElement get inputElement;<br />  // ...<br />}</pre>The factory method in this example is the <code>inputElement</code> getter, which returns an <code>InputElement</code>. Because of the <code>PaperElement</code> inheritance, I have to change that to return the more general <code>HtmlElement</code>:<pre class=prettyprint>abstract class FormBuilder {<br />  // ...<br />  HtmlElement get inputElement;<br />  // ...<br />}</pre>How many other changes am I going to have to make?<br /><br />Well, I certainly have to list <a href="http://www.polymer-project.org/">Polymer</a> as a dependency in my project's <code>pubspec.yaml</code>. To get <code>&lt;paper-input></code>, I need <code>paper_elements</code> as well:<pre class=prettyprint>name: factory_method_code<br />dependencies:<br />  polymer: ">=0.15.1 <0.17.0"<br />  paper_elements: ">=0.7.0 <0.8.0"<br />transformers:<br />- polymer:<br />    entry_points:<br />    - web/index.html</pre>Next, I have to import the paper element into the containing page:<pre class=prettyprint>&lt;!doctype html><br />&lt;html lang="en"><br />  &lt;head><br />    &lt;!-- ... --><br />    &lt;link rel="import" href="packages/paper_elements/paper_input.html"><br />    &lt;script type="application/dart" src="input_factory.dart">&lt;/script><br />  &lt;/head><br />  &lt;body>&lt;!-- ... -->&lt;/body><br />&lt;/html><br /></pre>I have to do the same with the backing code in the <code>input_factory.dart</code> script:<pre class=prettyprint>import 'package:polymer/polymer.dart';<br />import 'package:paper_elements/paper_input.dart';<br /><br />abstract class FormBuilder {<br />  // ...<br />}<br />// Concrete factories here...</pre>The final Polymer-y thing that needs to happen is an <code>initPolymer()</code> call in my <code>main()</code> entry point, also in the <code>input_factory.dart</code> script:<pre class=prettyprint>main() async {<br />  await initPolymer();<br />  // Start up the factory code once Polymer is ready...<br />}</pre>That's it for the Polymer preliminaries. Now what needs to change in the pattern itself to accommodate <code>PaperInput</code>? Mercifully, not much. In the <code>RandomBuilder</code> class, which is a concrete factory implementation of the <code>FormBuilder</code>, I add a new random option (#5) for <code>PaperInput</code>:<pre class=prettyprint>class RandomBuilder extends FormBuilder {<br />  RandomBuilder(el): super(el);<br />  Element get inputElement {<br />    var rand = new Random().nextInt(7);<br /><br />    if (rand == 0) return new WeekInputElement();<br />    if (rand == 1) return new NumberInputElement();<br />    if (rand == 2) return new TelephoneInputElement();<br />    if (rand == 3) return new UrlInputElement();<br />    if (rand == 4) return new TimeInputElement();<br />    if (rand == 5) return new PaperInput();<br /><br />    return new TextInputElement();<br />  }<br />}</pre>Unfortunately, I also have to make a change in the superclass. Previously, when all of the products were <code>InputElement</code> instances, I could count on them supporting the <code>type</code> property (e.g. telephone, number, time), which I could use as a default <code>text</code> label on the page:<pre class=prettyprint>abstract class FormBuilder {<br />  // ...<br />  _labelFor(el) {<br />    var text = el.type;<br />    var label = new LabelElement()<br />      ..appendText("$text: ")<br />      ..append(el);<br /><br />    return new ParagraphElement()..append(label);<br />  }<br />}</pre>That will not work for <code>PaperInput</code>, which does not support the <code>type</code> property. If I had control of the product classes, I could force <code>PaperInput</code> to support <code>type</code>. Since that is not possible, I either have to create wrapper classes or, more easily, add an object type test for <code>InputElement</code>:<pre class=prettyprint>abstract class FormBuilder {<br />  // ...<br />  _labelFor(el) {<br />    var text = (el is InputElement) ? el.type : el.toString();<br />    // ...<br />  }<br />}</pre><p>By itself, that one line is not too horrible. That said, I can imagine things going quickly off the rails here by adding a non-<code>InputElement</code> into the mix. For a limited use case like this example, however, it works.</p><p>In the end, it was fairly easy to get a <code>PaperInput</code> element added to the mix of my <code>InputElement</code> factory method. Most of the effort was the usual Polymer overhead. The resulting interface mismatch likely will not cause too much trouble in this case, but could get ugly quickly in other scenarios.</p><p><span style="color: #ccc">Day #91</span>  </p><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/a-nearly-modern-factory-method-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/the-chain-of-responsibility-pattern-in.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/byZWKwRCWWs" height="1" width="1" alt=""/>
