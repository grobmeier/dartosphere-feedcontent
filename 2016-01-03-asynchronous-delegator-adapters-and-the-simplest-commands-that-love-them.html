---
title: 'Asynchronous Delegator Adapters and the Simplest Commands that Love Them'
layout: post
published: '2016-01-03T22:11:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/9_Ovz9fcIYY/asynchronous-delegator-adapters-and.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />So, pluggable adapters in <a href="http://dartlang.org">Dart</a> (or any languages for that matter)... I think I finally understand them. <br /><br />The strange thing is that plugable adapters discussion in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> make complete sense now. I never really understood that part of the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a> chapter before. Maybe it's simply that my brain is incapable of processing UML diagrams. Whatever the reason, it makes sense now—hopefully the previous two night's posts can attest to that.<br /><br />There is one thing missing in last night's delegating, pluggable adapter pattern: different delegator and adapter interfaces. I think it is likely perfectly acceptable for both delegator and adapter to implement the same interface. It probably helps to illustrate the pattern to have them implement two different interfaces.<br /><br />So my universal remote control for robots needs an interface that can be adapted to multiple robots. The <code>Ubot</code> interface describes the interface:<pre class=prettyprint>/*** Target ***/<br />abstract class Ubot {<br />  String get xyLocation;<br />  void moveForward();<br />  void moveBackward();<br />  void moveLeft();<br />  void moveRight();<br />}</pre>In my quest for robot control dominance, I currently have adapters for two different kinds of robots: the standard <code>Robot</code> class and the newer <code>Bot</code> class robots. Astromechs are next, but that's tale for another day. The adapters implement the <code>Ubot</code> interface:<pre class=prettyprint>/*** Adapters ***/<br />class RobotAdapterToUbot implements Ubot {<br />  Robot _robot;<br />  RobotAdapterToUbot(this._robot);<br /><br />  String get xyLocation => _robot.location;<br /><br />  void moveForward()  { _robot.move(Direction.NORTH); }<br />  // More move methods here...<br />}<br /><br />class BotAdapterToUbot implements Ubot {<br />  Bot _bot;<br />  BotAdapterToUbot(this._bot);<br /><br />  String get xyLocation => "${_bot.x}, ${_bot.y}";<br /><br />  void moveForward()  { _bot.goForward(); }<br />  // More move methods here...<br />}</pre>As of last night, the universal robot also implements the <code>Ubot</code> interface. Since it implements the same interface, all that it really does is delegate to the appropriate adapter in the constructor after which all methods invoke the method of the same name in the adapter:<pre class=prettyprint>/*** A common interface delegator ***/<br />class UniversalRemoteRobot implements Ubot {<br />  Ubot _ubot;<br />  UniversalRemoteRobot(robot) {<br />    if (robot is Robot) _ubot = new RobotAdapterToUbot(robot);<br />    else if (robot is Bot) _ubot = new BotAdapterToUbot(robot);<br />    else _ubot = new NullAdapterToUbot(robot);<br />  }<br /><br />  String get xyLocation => _ubot.xyLocation;<br /><br />  void moveForward()  { _ubot.moveForward(); }<br />  // More move methods here...<br />}</pre>Tonight, I remove that common interface and switch back to an asynchronous version of the universal remote control. Previously, that had been the adapter in the pattern that I was using, now it becomes the delegator to the appropriate adapter:<pre class=prettyprint>class UniversalRemoteRobot {<br />  Ubot _ubot;<br /><br />  UniversalRemoteRobot(robot) { _delegateRobot(robot); }<br /><br />  void _delegateRobot(robot) {<br />    if (robot is Robot) _ubot = new RobotAdapterToUbot(robot);<br />    else if (robot is Bot) _ubot = new BotAdapterToUbot(robot);<br />    else _ubot = new NullAdapterToUbot();<br />  }<br /><br />  // Asynchronous methods go here...<br />}</pre>The asynchronous methods, which move the robot until the movement is canceled (by pressing stop, releasing the move button, the robot crashing, etc.), can still be implemented with <code>Timer</code> objects:<pre class=prettyprint>const oneSecond = const Duration(seconds: 1);<br /><br />class UniversalRemoteRobot {<br />  // ...<br />  Timer moveForward() =><br />    new Timer.periodic(oneSecond, (_){ _ubot.moveForward(); });<br />  // ...<br />}</pre>That <code>moveForward()</code> method will start a timer that moves the adapted robot forward once every second. That is a little messy already, which will make the class messy once the other four directions are implemented. It would get even worse if I had to store the timer so that all active commands can be stopped:<pre class=prettyprint>class UniversalRemoteRobot {<br />  // ...<br />  Timer moveForward() {<br />    var t = new Timer.periodic(oneSecond, (_){ _ubot.moveForward(); });<br />    _activeControls.add(t);<br />    return t;<br />  }<br />  // ...<br />}</pre>Doing that four times would be crazy. So I need to pass the command (receiver and action) to a helper method. That sounds like a job for the command pattern!<br /><br />Except I would prefer to avoid using two patterns in the same example code. So do I send an anonymous function to a timer method?<pre class=prettyprint>class UniversalRemoteRobot {<br />  // ...<br />  Timer _executeControlledCommand(command) {<br />    var t = new Timer.periodic(oneSecond, (_){ command(); });<br />    _activeControls.add(t);<br />    return t;<br />  }<br />}</pre>That helper would execute the command on the delegated/adapted robot, add the timer to a list, then return the timer so that it could be canceled. But anonymous functions? Mirrors? Actual command objects?<br /><br />It turns out that there is a Dart command object that I neglected to cover in my first pass at researching the topic. I can simply pass the method and I get the receiver for free:<pre class=prettyprint>class UniversalRemoteRobot {<br />  // ...<br />  Timer moveForward()  => _executeControlledCommand(_ubot.moveForward);<br />  // Other move methods here...<br /><br />  Timer _executeControlledCommand(command) {<br />    var t = new Timer.periodic(oneSecond, (_){ command(); });<br />    _activeControls.add(t);<br />    return t;<br />  }<br />}</pre>I really am a JavaScript hostage. It never occurred to me that passing an object's method would bring the object along without having to resort to some <code>call()</code> or <code>apply()</code> calling context silliness. Who would have guessed that it would just work like one would expect? <br /><br />Well, I should have expected that it would work. And work it does. Now in the client context, I can create either a <code>Robot</code> or a <code>Bot</code>:<pre class=prettyprint><code>  var robot = new Robot();<br />  // This works exactly the same:<br />  // var robot = new Bot();</code></pre>And supply that to a new instance of <code>UniversalRemoteRobot</code>, starting it along the way:<pre class=prettyprint><code>  var universalRobot = new UniversalRemoteRobot(robot);<br /><br />  print("Start moving $robot.");<br />  var btnCtrl = universalRobot.moveForward();</code></pre>I can then cancel that 10 seconds later:<pre class=prettyprint><code>  // Simulate releasing the button after 10 seconds...<br />  new Timer(<br />    new Duration(seconds: 10),<br />    (){<br />      btnCtrl.cancel();<br />      print("The robot is now at: ${universalRobot.xyLocation}.");<br />    }<br />  );</code></pre>With that, I have an — ahem — asynchronous, non-common interface, delegating class to pluggable adapters. Or something like that.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/b135fab7fce92183cc08">https://dartpad.dartlang.org/b135fab7fce92183cc08</a>.</i><br /><br /><br /><br /><span style="color: #ccc">Day #53</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/delegated-pluggable-adapter-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/9_Ovz9fcIYY" height="1" width="1" alt=""/>
