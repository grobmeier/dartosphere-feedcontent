---
title: 'Unboxing Packages: vm_service_client'
layout: post
published: '2016-05-17T11:30:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/05/unboxing-packages-vmserviceclient.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p><a href="http://news.dartlang.org/2016/04/unboxing-packages-streamchannel.html">Three weeks ago</a>, I wrote about the <a href="https://pub.dartlang.org/packages/stream_channel"><code>stream_channel</code></a> package. <a href="http://news.dartlang.org/2016/05/unboxing-packages-jsonrpc2.html">Two weeks ago</a>, I wrote about the <a href="https://pub.dartlang.org/packages/json_rpc_2"><code>json_rpc_2</code></a> package which is built on top of <code>stream_channel</code>. This week I’ll complete the trifecta by writing about the <a href="https://pub.dartlang.org/packages/vm_service_client"><code>vm_service_client</code></a> package, which uses <code>json_rpc_2</code> in turn—and is a really cool package in its own right!</p> <p>One of the lesser-known corners of the Dart VM is its <a href="https://github.com/dart-lang/sdk/blob/master/runtime/vm/service/service.md">service protocol</a>, but it’s one of its most powerful components. It uses JSON-RPC 2.0 over WebSockets to allow clients to connect to the VM, inspect its internal state, set breakpoints, and all sorts of neat stuff. If you’ve ever used <a href="https://dart-lang.github.io/observatory/">Observatory</a> for debugging or profiling your Dart code, you’ve been using the service protocol under the hood: that’s how the Observatory web app talks to the VM’s internals.</p> <p>Because the protocol is fully documented and based on a standard underlying protocol, it’s possible for anyone to use from their code. And the <code>vm_service_client</code> package makes it downright easy: it provides a Dart-y object-oriented API for (more or less) everything in the protocol. And that turns out to be a lot of stuff: I count 108 classes in the <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/vm_service_client-library.html">API documentation</a>, with more added over time as the protocol adds new features.</p> <p>Because the client’s surface area is so broad, I’m not even going to attempt to cover all of it. I’ll discuss the most important classes, of course, but I also want to touch on the broader picture of how we took a language-independent RPC protocol and created a native-feeling API to use it.</p>   <h2 id="connecting-the-client">Connecting the Client</h2> <p>Before we go deep into the API, though, let’s start at the beginning: actually establishing a connection with a running VM instance. The first step is to get the VM to actually run the service protocol at all. If you run <code>dart --enable-vm-service</code>, it will listen for WebSocket connections on <code>ws://localhost:8181/ws</code> (by default).<a href="#fn:1" id="fnref:1" title="See footnote" class="footnote">1</a> You can also force a running Dart process to start the VM service by sending it a <code>SIGQUIT</code> signal, as long as you’re not on Windows, but that’s a lot less reliable and customizable.</p> <p>Once the service is running, you can connect a client to it using <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMServiceClient/VMServiceClient.connect.html"><code>new VMServiceClient.connect()</code></a>. This takes the service protocol’s WebSocket URL as either a string or a <code>Uri</code>—and, for convenience, it can also take Observatory’s HTTP URL, which it will use to figure out the corresponding WebSocket URL. If anything goes wrong, it’ll be reported through the <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMServiceClient/done.html"><code>done</code></a> future.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">"package:vm_service_client/vm_service_client.dart"</span><span class="pun">;</span><span class="pln"><br /><br />main</span><span class="pun">(</span><span class="typ">List</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;</span><span class="pln"> args</span><span class="pun">)</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> url </span><span class="pun">=</span><span class="pln"> args</span><span class="pun">.</span><span class="pln">isEmpty </span><span class="pun">?</span><span class="pln"> </span><span class="str">"ws://localhost:8181/ws"</span><span class="pln"> </span><span class="pun">:</span><span class="pln"> args</span><span class="pun">.</span><span class="pln">first </span><span class="kwd">as</span><span class="pln"> </span><span class="typ">String</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> client </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">VMServiceClient</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">args</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]);</span><span class="pln"><br /><br />  </span><span class="com">// ...</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h2 id="references">References</h2> <p>Almost every piece of data the service protocol provides comes in two varieties: the reference and the full version. The reference contains a little bit of metadata, as well as enough information to make an RPC that will provide the full version, which contains all available information.</p> <p>This split accomplishes two things. It makes the responses much more compact by avoiding unnecessary metadata. More importantly, though, it allows for circularity. A <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMLibrary-class.html">library</a> can refer to the <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMClassRef-class.html">classes</a> it contains, which can in turn refer back to the library that contains them.</p> <p>In the client, all reference classes end in <code>Ref</code>, whereas their full versions do not. So <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMLibraryRef-class.html"><code>VMLibraryRef</code></a> is a reference to a <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMLibrary-class.html"><code>VMLibrary</code></a>. The full versions extend their corresponding references, so you can pass a <code>VMLibrary</code> to a method that expects a <code>VMLibraryRef</code>. Every reference has a <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMLibraryRef/load.html"><code>load()</code></a> method that returns its full version.</p> <p>This is an important place where the client makes the API feel more native. Because the service protocol can’t really overload an RPC based on its argument type, it has to have different calls for resolving references to different types of objects. But as a Dart client, we can provide an extra degree of uniformity. This is a pattern that comes up several times throughout the client.</p>   <h3 id="runnable-isolates">Runnable Isolates</h3> <p>Isolates are a special case: they have <em>three</em> states instead of just two. There’s <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolateRef-class.html"><code>VMIsolateRef</code></a> and <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolate-class.html"><code>VMIsolate</code></a>, but neither of these will provide <em>all</em> the isolate’s information. For that you need <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMRunnableIsolate-class.html"><code>VMRunnableIsolate</code></a>.</p> <p>The extra layer exists because the VM loads an isolate in stages. First it creates the isolate with simple metadata like <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolateRef/name.html">its name</a> and <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolate/startTime.html">its start time</a>. But it needs to do a bunch of additional work, loading libraries and classes and stuff like that, before it can actually run any code in the isolate. Only once all that work is done is a <code>VMRunnableIsolate</code> available.</p> <p>You can use the <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMServiceClient/onIsolateRunnable.html"><code>VMServiceClient.onIsolateRunnable</code></a> stream to get a notification when the isolate you care about is runnable, but if you already have a reference to an unrunnable version there’s an easier way. <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolateRef/loadRunnable.html"><code>VMIsolateRef.loadRunnable()</code></a> returns the runnable version once it’s available, and does so in a way that’s guaranteed to be safe from race conditions.</p>   <h2 id="navigating-the-service">Navigating the Service</h2> <p>Once you have a connection to the service, you need to be able to find the part you want to interact with. I don’t mean looking up its API docs, I mean actually getting to it from your <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMServiceClient-class.html"><code>VMServiceClient</code></a> object. For the most part, the VM service is organized hierarchically:</p> <ul><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMServiceClient/getVM.html"><code>VMServiceClient.getVM()</code></a> gives you the client’s single <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VM-class.html"><code>VM</code></a>.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VM/isolates.html"><code>VM.isolates</code></a> gives you all the VM’s <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolateRef-class.html"><code>VMIsolateRef</code></a>s.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMRunnableIsolate/libraries.html"><code>VMRunnableIsolate.libraries</code></a> gives you all the <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIsolateRef/loadRunnable.html"><code>VMLibraryRef</code></a>s loaded by the isolate.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMLibrary/classes.html"><code>VMLibrary.classes</code></a> gives you all the <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMClassRef-class.html"><code>VMClassRef</code></a>s defined in the library.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMClass/fields.html"><code>VMClass.fields</code></a> gives you the class’s fields, and <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMClass/functions.html"><code>VMClass.functions</code></a> gives you its methods.</li></ul> <p>Note that many of these getters are maps. This comes entirely from the client: the service protocol always sends collections down as lists for compactness. But it’s useful for users to be able to look up libraries by their URIs or classes by their names, so the client converts the lists into the data structure that best fits with how we expect users to interact with the data.</p> <p>Let’s take a look at how you’d add a breakpoint at the beginning of a call to <a href="https://api.dartlang.org/stable/latest/dart-io/File/open.html"><code>File.open()</code></a> from <code>dart:io</code>:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">var</span><span class="pln"> vm </span><span class="pun">=</span><span class="pln"> await client</span><span class="pun">.</span><span class="pln">getVM</span><span class="pun">();</span><span class="pln"><br /></span><span class="kwd">var</span><span class="pln"> isolate </span><span class="pun">=</span><span class="pln"> await vm</span><span class="pun">.</span><span class="pln">isolates</span><span class="pun">.</span><span class="pln">first</span><span class="pun">.</span><span class="pln">loadRunnable</span><span class="pun">();</span><span class="pln"><br /></span><span class="kwd">var</span><span class="pln"> library </span><span class="pun">=</span><span class="pln"> await isolate</span><span class="pun">.</span><span class="pln">libraries</span><span class="pun">[</span><span class="typ">Uri</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="str">"dart:io"</span><span class="pun">)].</span><span class="pln">load</span><span class="pun">();</span><span class="pln"><br /></span><span class="kwd">var</span><span class="pln"> file </span><span class="pun">=</span><span class="pln"> await library</span><span class="pun">.</span><span class="pln">classes</span><span class="pun">[</span><span class="str">"File"</span><span class="pun">].</span><span class="pln">load</span><span class="pun">();</span><span class="pln"><br />future</span><span class="pun">.</span><span class="pln">functions</span><span class="pun">[</span><span class="str">"open"</span><span class="pun">].</span><span class="pln">addBreakpoint</span><span class="pun">();</span></code></pre>   <h2 id="instances">Instances</h2> <p>Code deals with data, so the VM service needs a way to represent data, and that way is the Instance class. Like most types, Instances have references and full values—these are represented in the client as <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMInstanceRef-class.html"><code>VMInstanceRef</code></a> and <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMInstance-class.html"><code>VMInstance</code></a>.</p> <p>On its own, <code>VMInstance</code> only provides two pieces of information. Its <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMInstanceRef/klass.html"><code>klass</code></a> getter returns the <code>VMClassRef</code> representing the instance’s class, and its <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMInstance/fields.html"><code>fields</code></a> getter returns its fields and their values. In practice, though, many instances include more information—the service provides extra information for many core library types, which the client represents as classes like <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMIntInstance-class.html"><code>VMIntInstance</code></a> and <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMListInstance-class.html"><code>VMListInstance</code></a>.</p> <p>The client also provides <a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMInstanceRef/getValue.html"><code>VMInstanceRef.getValue()</code></a>, a convenience method for converting instances to local Dart objects. Every <code>VMInstanceRef</code> subclass overrides this to recreate their particular type of object. It also takes an optional <code>onUnknownValue()</code> callback to which plain instances—including those in data structures—are passed to be converted into local values based on the caller’s logic.</p>   <h2 id="evaluating-code">Evaluating Code</h2> <p>The VM service doesn’t just let you look at the VM’s state, it lets you run code on it as well! A few different classes have <code>evaluate()</code> methods that take strings to evaluate and return <code>VMInstanceRef</code>s. Where you evaluate the code determines what names are accessible.</p> <ul><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMLibraryRef/evaluate.html"><code>VMLibraryRef.evaluate()</code></a> runs code in the context of a library. This lets the code access anything the library has imported, as well as any of its private names.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMClassRef/evaluate.html"><code>VMClassRef.evaluate()</code></a> runs code in the context of a class. This is mostly the same as the library context, except that the code can refer to static class members without needing to prefix them with the class’s name.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMInstanceRef/evaluate.html"><code>VMInstanceRef.evaluate()</code></a> runs code in the context of an instance. This means the code can refer to the instances fields and to <code>this</code>.</li><li><a href="https://www.dartdocs.org/documentation/vm_service_client/latest/vm_service_client/VMFrame/evaluate.html"><code>VMFrameRef.evaluate()</code></a> can be used when an isolate is paused to run code in the same context as one of the current stack frames.</li></ul> <p>This is another example of the client using the same API to draw similarities between different parts of the underlying protocol. Because the client has the well-known unifying metaphors of <em>objects</em> and <em>methods</em>, it’s able to take disparate APIs and expose them in a consistent way that isn’t possible using raw RPCs.</p>   <h2 id="go-forth-and-make-something-cool">Go Forth and Make Something Cool</h2> <p>In some ways, the VM service client is the most exciting package I’ve written about yet. It’s designed to make available a whole bunch of internal VM functionality, and the only limit on what can be done with that functionality is your imagination. So take this package and make something cool. Make a <a href="https://en.wikipedia.org/wiki/Read%E2%80%93eval%E2%80%93print_loop">REPL</a> or a visual object inspector. Heck, make an entirely new debugger!</p> <p>Join me again in two weeks when I write about one of the oldest and most fundamental packages in the entire Dart ecosystem.</p> <div class="footnotes"><hr><ol><li id="fn:1">Humans interacting directly with Observatory usually pass <code>--observe</code> flag instead of <code>--enable-vm-service</code>. This will also enable the service, but it also turns on a handful of other options, the exact set of which is subject to change. It’s much safer to use <code>--enable-vm-service</code> when writing code to interact with the VM. <a href="#fnref:1" title="Return to article" class="reversefootnote">↩</a></li></ol></div> <img border="0" style="display:none" src="https://4.bp.blogspot.com/-tyrjkN4E66k/VztsqcE4rLI/AAAAAAAANMA/u9yFhhkNAmkvUPebrjAbflCBWT-k6StRQCLcB/s1600/Screen%2BShot%2B2016-05-17%2Bat%2B12.08.17.png" />
