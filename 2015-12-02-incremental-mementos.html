---
title: 'Incremental Mementos'
layout: post
published: '2015-12-02T23:40:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/LPtn0bcHYGY/incremental-mementos.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - memento

---

<div class=top-chain-links></div><br />Let's have some fun with incremental mementos. I have a decent <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a> example ready for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. Hopefully it can be adapted to produce incremental memento objects instead of the full state object that it is currently returning. <br /><br />The example application is the velvet fog machine, used by lover's of Mel Tormé everywhere to produce the perfect playlist for any occasion. The originator class in the pattern is the <code>VelvetFogMachine</code>, which serves as a digital jukebox. It plays songs:<pre class=prettyprint>class VelvetFogMachine {<br />  // ...<br />  void play(String title, String album, [double time = 0.0]) {<br />    _play(new Song(title, album), time);<br />  }<br />  // ...<br />}</pre>It can send back mementos of the current song / time within the song:<pre class=prettyprint>class VelvetFogMachine {<br />  // ...<br />  Playing get nowPlaying => new Playing(currentSong, currentTime);<br />  // ...<br />}</pre>It can use these <code>Playing</code> mementos to return to previous states:<pre class=prettyprint>class VelvetFogMachine {<br />  // ...<br />  void backTo(Playing p) {<br />    print("\n===> (backTo)");<br />    _play(p._song, p._time);<br />  }<br />}<br /></pre>Currently, that <code>Playing</code> class stores both the <code>currentSong</code> and <code>currentTime</code> every time that the <code>nowPlaying</code> getter is invoked in <code>VelvetFogMachine</code>. But why bother doing that if the song stays the same while the time increases:<pre class=prettyprint><code>  List&lt;Playing> replayer = [];<br /><br />  var scatMan = new VelvetFogMachine();<br />  scatMan.play(<br />      'New York, New York Medley',<br />      'A Vintage Year'<br />  );<br />  replayer.add(scatMan.nowPlaying);<br />  replayer.add(scatMan.nowPlaying);<br />  replayer.add(scatMan.nowPlaying);<br />  replayer.add(scatMan.nowPlaying);<br /><br />  // Now move back to the different bookmarked times in the <br />  // New York, New York song<br />  scatMan.backTo(replayer.removeLast());<br />  scatMan.backTo(replayer.removeLast());<br />  scatMan.backTo(replayer.removeLast());<br />  scatMan.backTo(replayer.removeLast());</code></pre>The result of running this code looks something like:<pre class=prettyprint>Playing New York, New York Medley // A Vintage Year @ 0.00<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 5.10<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 4.22<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 2.35<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 0.51</pre>There really is no need to store the song in each memento. But where should the responsibility lie for remembering the previous memento, determining the difference between increments?<br /><br />I think it has to be the originator—the <code>VelvetForMachine</code>. One way or another, the <code>VeletFogMachine</code> needs to know what to do when it sees a <code>null</code> song in <code>backTo()</code>:<pre class=prettyprint><code>  void backTo(Playing p) {<br />    print("\n===> (backTo)");<br />    var song = (p._song == null) ? currentSong : p._song;<br />    _play(song, p._time);<br />  }</code></pre>So if the <code>VelvetFogMachine</code> is handling increments when restoring state, it stands to reason that it should do the same when creating state:<pre class=prettyprint><code>  Playing get nowPlaying {<br />    var song  = (_lastSong == currentSong) ? null : currentSong;<br />    _lastSong = currentSong;<br /><br />    return new Playing(song, currentTime);<br />  }</code></pre>Introduced here is <code>_lastSong</code> to track which song was playing the last time state was recorded in a memento. If the last song and the current song are the same, then the memento records a <code>null</code> song. Otherwise the actual song is recorded to note the change in songs.<br /><br />That seems to work. When the code is run, the output is reported as:<pre class=prettyprint>Playing New York, New York Medley // A Vintage Year @ 0.00<br />...<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 5.10<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 4.22<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 2.35<br /><br />===> (backTo)<br />Playing New York, New York Medley // A Vintage Year @ 0.51<br /></pre>Despite the seemingly working code, I have some reservations about this—at least about including it in the book. I am faking the times with a random increment. That does not seems conceptually hard for full state, but I worry that it will be confusing should I choose to discuss it in the book. Perhaps I can simply gloss over incremental changes as did the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>.<br /><br />I also have the feeling that this incremental code really ought to move out into its own class. I left it in the <code>VelvetFogMachine</code> as I explored, but if the rest of the pattern is obsessed with single-responsibility, then it seems like this is asking for trouble.<br /><br />All that said, I may investigate this further. Just because the GoF did not discuss incremental changes in detail does not give me warrant to do the same. If I can do so easily and if it helps support discussion of the pattern, I am obligated to pursue it. Tomorrow.<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/4bde9f50dfd2dea2c872">https://dartpad.dartlang.org/4bde9f50dfd2dea2c872</a>.</i><br /><br /><br /><span style="color: #ccc">Day #21</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/dart-has-friend-class-baked-in.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/LPtn0bcHYGY" height="1" width="1" alt=""/>
