---
title: 'How Much Mixin for the Chain of Responsibility?'
layout: post
published: '2016-02-15T20:17:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/QtmkoaK48h4/how-much-mixin-chain-of-responsibility.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - 'chain of responsibility pattern'
    - dart
    - dartlang
    - 'design patterns'
    - mixins

---

<div class=top-chain-links></div><br />After last night, I am again a fan of mixins in <a href="http://dartlang.org">Dart</a>. Mixins will not solve all problems, but they seem to solve several cases of <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">chain of responsibility pattern</a> nicely. I still have some follow-up questions, though. Up tonight how much of the chain can I get into the mixin class (and how much should I get in there)?<br /><br />The mixin in my current example adds purchasing power traits to an <code>Employee</code> class. Give that <code>Employee</code> supports a <code>reportsTo</code> property, the <code>_PurchasingPower</code> mixin delegates the chain of reponsibility's successor to this property:<pre class=prettyprint>abstract class _PurchasePower {<br />  get successor => reportsTo;<br />  // ...<br />}</pre>If the handler method in the chain is unable to process the current request, it will forward it along to this property. For a manager, this property might point to a director. For a director, it might point to a VP. <br /><br />As for handling the request, I currently do that via two methods:<pre class=prettyprint>abstract class _PurchasePower {<br />  // ...<br />  void processRequest(PurchaseRequest request) {<br />    if (_processRequest(request)) return;<br />    if (successor == null) return;<br /><br />    successor.processRequest(request);<br />  }<br /><br />  bool _processRequest(_) => false;<br />}</pre>The <code>processRequest()</code> method is responsible for the successor chain while <code>_processRequest()</code> is responsible for attempting to handle the actual request. The default implementation in the mixin is for <code>_processRequest()</code> to <i>not</i> handle the request. In practice, concrete handler classes are expected to override this behavior.<br /><br />I appreciate the separation of focus between the two methods. It is nice that subclasses only have to worry about overriding the processing of the request instead of handling the request and managing the successor chain. When <code>_PurchasePower</code> is mixed into the <code>Manager</code> class, for instance, it is completely unaware of the chain of responsibility:<pre class=prettyprint>class Manager extends Employee with _PurchasePower {<br />  final double _allowable = 10 * 1000.0;<br /><br />  bool _processRequest(PurchaseRequest request) {<br />    if (request.amount > _allowable) return false;<br /><br />    print("Manager will approve $request.");<br />    return true;<br />  }<br />}</pre>It either handles the request or it does not. Simple. <br /><br />And yet, I note that the manner in which it handles the request is very similar to the manner in which the <code>Director</code> class handles the same request:<pre class=prettyprint>class Director extends Employee with _PurchasePower {<br />  final double _allowable = 20 * 1000.0;<br /><br />  bool _processRequest(PurchaseRequest request) {<br />    if (request.amount > _allowable) return false;<br /><br />    print("Director will approve $request");<br />    return true;<br />  }<br />}</pre>The only thing that varies in the implementation of <code>_processRequest()</code> is the name of the employee that potentially has the appropriate purchasing power. The <code>Employee</code> base class can figure this out from the runtime type of the object:<pre class=prettyprint>class Employee {<br />  // ...<br />  String get title => "${this.runtimeType}";<br />  String toString() => title;<br />}<br /></pre>By defining the <code>toString()</code> method, I tell Dart how to interpolate this object into any string. Making use of that in the <code>_PurchasePower</code> mixin, I can declare a common <code>_processRequest()</code> handler method as:<pre class=prettyprint>abstract class _PurchasePower {<br />  final double _allowable = 0.0;<br />  // ...<br />  bool _processRequest(PurchaseRequest request) {<br />    if (request.amount > _allowable) return false;<br /><br />    print("$this will approve $request.");<br />    return true;<br />  }<br />}</pre>My <code>_PurchasePower</code> chain of responsibility mixin is getting crowded now. That said, the payoff is pretty nice. The employee subclasses with purchasing power now only need to declare the maximum allowed amount that they can handle:<pre class=prettyprint>class Manager extends Employee with _PurchasePower {<br />  final double _allowable = 10 * 1000.0;<br />}<br /><br />class Director extends Employee with _PurchasePower {<br />  final double _allowable = 20 * 1000.0;<br />}<br /><br />class VicePresident extends Employee with _PurchasePower {<br />  final double _allowable = 40 * 1000.0;<br />}</pre>The mixin takes care of both processing the request and handling the successor chain. Even with this wonderfully compact implementation, I still retain the ability to override the default behavior as when the <code>President</code> always halts the chain:<pre class=prettyprint>class President extends Employee with _PurchasePower {<br />  final double _allowable = 60 * 1000.0;<br /><br />  void processRequest(PurchaseRequest request) {<br />    if (request.amount > _allowable) {<br />      print("Your request for $request needs a board meeting!");<br />    }<br />    else {<br />      print("President will approve $request");<br />    }<br />  }<br />}</pre>Since there is no successor beyond <code>President</code> I override the <code>processRequest()</code> method, handling the request directly.<br /><br />And yes, the chain of responsibility still works as desired:<pre class="prettyprint"><code class="language-html">$ ./bin/purchase.dart 2000 <br />Manager will approve $2000.00 for General Purpose Usage.<br />$ ./bin/purchase.dart 12000<br />Director will approve $12000.00 for General Purpose Usage.<br />$ ./bin/purchase.dart 22000<br />VicePresident will approve $22000.00 for General Purpose Usage.<br />$ ./bin/purchase.dart 52000<br />President will approve $52000.00 for General Purpose Usage<br />$ ./bin/purchase.dart 82000<br />Your request for $82000.00 for General Purpose Usage needs a board meeting!</code></pre>So the answer to tonight's question would seem to be that, if the process handler is sufficiently generic, I can put everything into the chain mixin. The resulting concrete handler implementations are wonderfully succinct. There is barely any readability cost in the mixin class in this example thanks to Dart's <code>toString()</code> method. And I still retain the ability to override behavior in subclasses should that be required. Certainly this will not always be possible, but when there is sufficiently common process handling, this is a nice little code win.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/7cd84acd86da602301d5">https://dartpad.dartlang.org/7cd84acd86da602301d5</a>.</i> <br /><br /><br /><span style="color: #ccc">Day #96</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/the-chain-of-responsibility-with-mixins.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/in-which-i-take-things-one-step-too-far.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/QtmkoaK48h4" height="1" width="1" alt=""/>
