---
title: 'Unboxing Packages: json_rpc_2'
layout: post
published: '2016-05-04T13:10:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/05/unboxing-packages-jsonrpc2.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p><a href="http://news.dartlang.org/2016/04/unboxing-packages-streamchannel.html">Last week</a> I wrote about the <a href="https://pub.dartlang.org/packages/stream_channel"><code>stream_channel</code></a> package for two-way communication, so this week it seemed natural to move to a package that uses it: <a href="https://pub.dartlang.org/packages/json_rpc_2"><code>json_rpc_2</code></a>. This is an implementation of the <a href="http://www.jsonrpc.org/specification">JSON-RPC 2.0</a> specification, which is a popular protocol for providing structure and standardization to WebSocket APIs.</p> <p>Although it’s most commonly used with WebSockets, the protocol itself is explicitly independent of the underlying transport mechanism.  This makes it a great fit for stream channels, which can be used to represent a two-way stream of JSON objects in a way that works with any underlying mechanism. Thanks to stream channels, JSON-RPC 2.0 can be used across <a href="https://pub.dartlang.org/packages/web_socket_channel">WebSockets</a>, <a href="https://www.dartdocs.org/documentation/stream_channel/latest/index.html">isolates</a>, or any channel a user chooses to wrap.</p>   <h2 id="shared-apis">Shared APIs</h2> <p>There are three main classes in <code>json_rpc_2</code>: <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client-class.html"><code>Client</code></a> makes requests and receives responses, <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Server-class.html"><code>Server</code></a> handles requests and returns responses, and <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Peer-class.html"><code>Peer</code></a> does both at once. Because all of these involve two-way communication, they all have the same two constructors. The <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/Client.html">default constructor</a> takes a <code>StreamChannel&lt;String&gt;</code> where each string is an encoded JSON object, and automatically decodes incoming objects and encodes outgoing ones. On the other hand, if you want to communicate using decoded maps and lists, you can use the <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/Client.withoutJson.html"><code>withoutJson()</code></a> constructor, which only requires that the objects be JSON-compatible.</p> <p>The three classes also have the same lifecycle management. In order to give the user time to set up request handlers or enqueue request batches, they don’t start listening to the stream channel until <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/listen.html"><code>listen()</code></a> is called. Once it is, it returns a future that completes once the channel has closed—also accessible as the <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/done.html"><code>done</code></a> getter. And if the user wants to close the channel themselves, they can call <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/close.html"><code>close()</code></a>.</p>   <h2 id="client"><code>Client</code></h2> <p>The <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client-class.html"><code>Client</code></a> class is in charge of making requests of a server. The core method for this is <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/sendRequest.html"><code>sendRequest()</code></a>, which takes a method (the name of the remote procedure to call) and parameters to pass to that method.</p> <p>The structure of these parameters depends what the server accepts. JSON-RPC 2.0 allows both positional parameters, which are passed as an <code>Iterable</code> of JSON-safe objects, and named ones, which are passed as a <code>Map</code> from string names to JSON-safe values. The parameters can also be omitted entirely if the method doesn’t take any.</p> <p>The call to <code>sendRequest()</code> returns a future that completes with the server’s response. The protocol defines two types of response: “success” and “error”. On a success, the server returns a JSON-safe object which the <code>sendRequest()</code> future emits. On a failure, the server returns an error object with associated metadata. This metadata is wrapped up as an <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/RpcException-class.html"><code>RpcException</code></a> and thrown by the future.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">'package:json_rpc_2/json_rpc_2.dart'</span><span class="pln"> </span><span class="kwd">as</span><span class="pln"> rpc</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="com">/// Uses the VM service protocol to get the Dart version of a Dart process.</span><span class="pln"><br /></span><span class="com">///</span><span class="pln"><br /></span><span class="com">/// The [observatoryUrl] should be a `ws://` URL for the process's VM service.</span><span class="pln"><br /></span><span class="typ">Future</span><span class="pun">&lt;</span><span class="typ">String</span><span class="pun">&gt;</span><span class="pln"> getVersion</span><span class="pun">(</span><span class="typ">Uri</span><span class="pln"> observatoryUrl</span><span class="pun">)</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> channel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">WebSocketChannel</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">observatoryUrl</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> client </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> rpc</span><span class="pun">.</span><span class="typ">Client</span><span class="pun">(</span><span class="pln">channel</span><span class="pun">);</span><span class="pln"><br />  client</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">();</span><span class="pln"><br /><br />  </span><span class="com">// getVM() returns an object with a bunch of metadata about the VM itself.</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> vm </span><span class="pun">=</span><span class="pln"> await client</span><span class="pun">.</span><span class="pln">sendRequest</span><span class="pun">(</span><span class="str">"getVM"</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> vm</span><span class="pun">[</span><span class="str">"version"</span><span class="pun">];</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>If you don’t care whether the request succeeds, you can also call <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/sendNotification.html"><code>sendNotification()</code></a>. JSON-RPC 2.0 defines a <em>notification</em> as a request that doesn’t require a response, and a compliant server shouldn’t send one at all. Notifications are commonly used by peers for emitting events, but I’ll get to that later.</p> <p>JSON-RPC 2.0 also has a notion of <em>batches</em>, where a bunch of requests are sent as part of the same underlying message. The server is allowed to process batched requests in whatever order it wants, but it’s required to send the responses back as a single message as well. This can use less bandwidth if you have a bunch of requests that don’t have strong ordering needs.</p> <p>The <code>json_rpc_2</code> client lets the user create batches using the <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Client/withBatch.html"><code>withBatch()</code></a> method. This takes a callback (which may be asynchronous), and puts all requests that are sent while that callback is running into a single batch. This batch is sent once the callback is complete.</p>   <h3 id="server"><code>Server</code></h3> <p>The <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Server-class.html"><code>Server</code></a> class handles requests from one or more clients. Its core API is <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Server/registerMethod.html"><code>registerMethod()</code></a>, which controls how those requests are handled. It just takes a method name and a callback to run when that method is called. The value returned by that callback becomes the result returned to the client.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">"package:json_rpc_2/json_rpc_2.dart"</span><span class="pln"> </span><span class="kwd">as</span><span class="pln"> rpc</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">import</span><span class="pln"> </span><span class="str">"package:shelf/shelf_io.dart"</span><span class="pln"> </span><span class="kwd">as</span><span class="pln"> io</span><span class="pun">;</span><span class="pln"><br /></span><span class="kwd">import</span><span class="pln"> </span><span class="str">"package:shelf_web_socket/shelf_web_socket.dart"</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="kwd">var</span><span class="pln"> _i </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br /><br />main</span><span class="pun">()</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  io</span><span class="pun">.</span><span class="pln">serve</span><span class="pun">(</span><span class="pln">webSocketHandler</span><span class="pun">((</span><span class="pln">webSocketChannel</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> server </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> rpc</span><span class="pun">.</span><span class="typ">Server</span><span class="pun">(</span><span class="pln">webSocketChannel</span><span class="pun">);</span><span class="pln"><br /><br />    </span><span class="com">// Increments [_i] and returns its new value.</span><span class="pln"><br />    server</span><span class="pun">.</span><span class="pln">handleMethod</span><span class="pun">(</span><span class="str">"increment"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">()</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> </span><span class="pun">++</span><span class="pln">_i</span><span class="pun">);</span><span class="pln"><br />  </span><span class="pun">}),</span><span class="pln"> </span><span class="str">'localhost'</span><span class="pun">,</span><span class="pln"> </span><span class="lit">1234</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>The server presents an interesting API design challenge. Most methods require certain sorts of parameters—one might need exactly three positional parameters, one might need two mandatory named and one optional parameter, and another might not allow any parameters at all. JSON-RPC 2.0 is pretty clear about how to handle this at the protocol level, but how do we let the user specify it?</p> <p>We could have users manually validate the parameters—and in fact, for complex validations we do. Users can always manually throw <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/RpcException/RpcException.invalidParams.html"><code>new RpcException.invalidParams()</code></a> based on whatever logic they code. But it’s a huge pain to manually validate the presence and type of every parameter, so <code>Server</code> uses a couple clever tricks to figure out requirements with minimal user code.</p> <p>The first trick is that the callback passed to <code>registerMethod()</code> can take either zero or one parameters. This is how <code>Server</code> figures out whether the method allows parameters at all. In the example above, if a client tried to call <code>increment</code> with parameters of any kind, they would get an “invalid parameters” error. But the most clever trick is how parameters that <em>are</em> passed are parsed, and it involves an entirely new class.</p>   <h3 id="parameters"><code>Parameters</code></h3> <p>The <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameters-class.html"><code>Parameters</code></a> class wraps a JSON-safe object and provides methods to access it in a type-safe way that will automatically throw <code>RpcException</code>s if the object isn’t the expected format. It’s what gets passed to the <code>registerMethod()</code> callback, if it takes a parameter at all.</p> <p>If you call <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameters/asList.html"><code>asList</code></a> and the caller passed the parameters by name, it’ll throw an <code>RpcException</code>. If you call <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameters/asMap.html"><code>asMap</code></a> and the parameters were passed by position? <code>RpcException</code> as well. Or you can just call <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameters/value.html"><code>value</code></a> and get the underlying parameter no matter what form it takes.</p> <p><code>Parameters</code> also lets you verify the parameter values themselves. The <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameters/operator_get.html"><code>[]</code> operator</a> can be used for either positional parameters (with int arguments) or named parameters (with string arguments), and returns a <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter-class.html"><code>Parameter</code></a> object which extends <code>Parameters</code> with a bunch of methods for validating types beyond just lists and maps.</p> <p>All of the native JSON types have getters like <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/asString.html"><code>asString</code></a>, <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/asNum.html"><code>asNum</code></a>, and similar. Just like <code>asList</code> and <code>asMap</code>, these getters return the parameter values if they’re the correct types and throw <code>RpcException</code>s if they aren’t. There are also derived getters like <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/asDateTime.html"><code>asDateTime</code></a> and <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/asUri.html"><code>asUri</code></a> which ensure that the value can be parsed as the appropriate type, and <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/asInt.html"><code>asInt</code></a> which ensures that a number is an integer.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">// Sets [_i] to the given value.</span><span class="pln"><br />server</span><span class="pun">.</span><span class="pln">handleMethod</span><span class="pun">(</span><span class="str">"set"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">parameters</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  _i </span><span class="pun">=</span><span class="pln"> parameters</span><span class="pun">[</span><span class="lit">0</span><span class="pun">].</span><span class="pln">asInt</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> _i</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">});</span></code></pre> <p>It’s important to note that the <code>[]</code> operator will return a parameter <em>even if it doesn’t exist</em>, either because there weren’t enough positional parameters passed or because a parameter with that name wasn’t passed. This makes it easy to support optional parameters.</p> <p>A parameter that doesn’t exist will always throw an <code>RpcException</code> for its <code>asType</code> methods, and even for <code>value</code>. But there are methods where it won’t throw. If you call <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/asStringOr.html"><code>asStringOr()</code></a> for a parameter that exists, it behaves just like <code>asString</code>, but for a non-existent parameter it’ll return the <code>defaultValue</code> parameter. Every <code>asType</code> getter has a corresponding <code>asTypeOr()</code> method. Even <code>value</code> has <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Parameter/valueOr.html"><code>valueOr()</code></a>.</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">// Returns the logarithm of [_i].</span><span class="pln"><br /></span><span class="com">//</span><span class="pln"><br /></span><span class="com">// If the `"base"` named parameter is passed, uses that as the base. Otherwise,</span><span class="pln"><br /></span><span class="com">// uses `e`.</span><span class="pln"><br />server</span><span class="pun">.</span><span class="pln">handleMethod</span><span class="pun">(</span><span class="str">"log"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">parameters</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> math</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">_i</span><span class="pun">)/</span><span class="pln">math</span><span class="pun">.</span><span class="pln">log</span><span class="pun">(</span><span class="pln">parameters</span><span class="pun">[</span><span class="str">"base"</span><span class="pun">].</span><span class="pln">asNumOr</span><span class="pun">(</span><span class="pln">math</span><span class="pun">.</span><span class="pln">E</span><span class="pun">));</span><span class="pln"><br /></span><span class="pun">});</span></code></pre>   <h2 id="peer"><code>Peer</code></h2> <p>The <a href="https://www.dartdocs.org/documentation/json_rpc_2/latest/json_rpc_2/Peer-class.html"><code>Peer</code></a> class works as both a <code>Server</code> and a <code>Client</code> over the same underlying connection. In terms of API, it’s exactly the sum of those two classes. It adds no methods of its own, so in that sense you already know everything about it. But it’s still instructive to talk about <em>why</em> it exists.</p> <p>While I can easily imagine a structure where two endpoints are truly peers, each invoking methods on the other and receiving results, in practice most of the time I’ve seen peer-structured protocols has been for the sake of event dispatch. You see, JSON-RPC 2.0 doesn’t include an explicit mechanism for the server pushing events to the client. It can only respond to requests made by the client. This is intentional, since it makes the protocol much simpler, and the peer structure is the standard way around it.</p> <p>To support server events, both the client and server must act as peers, able to send <em>and</em> receive requests. In this world, events are modeled as requests sent from the server to the client—or more specifically, notifications, since the server doesn’t expect a response. The client registers a method for each type of event it wants to handle, and the server sends a request for every dispatch.</p> <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="com">/// Uses the VM service protocol to print the VM name.</span><span class="pln"><br /></span><span class="com">///</span><span class="pln"><br /></span><span class="com">/// Prints the VM name again every time it's changed.</span><span class="pln"><br /></span><span class="kwd">void</span><span class="pln"> printVersions</span><span class="pun">(</span><span class="typ">Uri</span><span class="pln"> observatoryUrl</span><span class="pun">)</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> channel </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">WebSocketChannel</span><span class="pun">.</span><span class="pln">connect</span><span class="pun">(</span><span class="pln">observatoryUrl</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> peer </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> rpc</span><span class="pun">.</span><span class="typ">Peer</span><span class="pun">(</span><span class="pln">channel</span><span class="pun">);</span><span class="pln"><br /><br />  peer</span><span class="pun">.</span><span class="pln">registerMethod</span><span class="pun">(</span><span class="str">"streamNotify"</span><span class="pun">,</span><span class="pln"> </span><span class="pun">(</span><span class="pln">parameters</span><span class="pun">)</span><span class="pln"> async </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">parameters</span><span class="pun">[</span><span class="str">"streamId"</span><span class="pun">].</span><span class="pln">asString </span><span class="pun">!=</span><span class="pln"> </span><span class="str">"VMUpdate"</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />      </span><span class="kwd">throw</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> rpc</span><span class="pun">.</span><span class="typ">RpcException</span><span class="pun">.</span><span class="pln">invalidParams</span><span class="pun">(</span><span class="pln"><br />          </span><span class="str">"Only expected VMUpdate events."</span><span class="pun">);</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    </span><span class="kwd">print</span><span class="pun">(</span><span class="str">"VM name is ${await peer.sendRequest("</span><span class="pln">getVM</span><span class="str">")["</span><span class="pln">version</span><span class="str">"]}."</span><span class="pun">);</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br />  client</span><span class="pun">.</span><span class="pln">listen</span><span class="pun">();</span><span class="pln"><br /><br />  </span><span class="kwd">print</span><span class="pun">(</span><span class="str">"VM name is ${await client.sendRequest("</span><span class="pln">getVM</span><span class="str">")["</span><span class="pln">version</span><span class="str">"]}."</span><span class="pun">);</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <h2 id="rpc-home">RPC Home</h2> <p>Next time you need to communicate with a JSON-RPC 2.0 server, you know where to turn. Next time you need to <em>create</em> an RPC server, I hope you look to JSON-RPC 2.0 as the underlying protocol. It’s clean and straightforward, and best of all, it’s got a great implementation already written and ready to use.</p> <p>I wrote about <code>stream_channel</code> in my last article. In this article, I wrote about <code>json_rpc_2</code>, which uses <code>stream_channel</code>. Join me in two weeks when I build this layer cake a little higher and write about a package that uses <code>json_rpc_2</code>!</p>
