---
title: '@MirrorsUsed Meta Targets'
layout: post
published: '2014-07-02T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/08h7JkinfuU/mirrorsused-meta-targets.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - mirrors

---

<div class=top-chain-links></div><br />I have to admit it. This took me a little while to figure out.<br /><br />Last night I was able to apply the <code>@MirrorsUsed</code> annotation to some mirror-based <a href="http://dartlang.org">Dart</a> code, thus reducing the size of <code>dart2js</code> compiled code from 1.6MB to 170<i>kb</i>.  The solution worked, but was not practical for the particular use I am exploring. So tonight, I figured out how to get <code>@MirrorsUsed</code> to do a little more.<br /><br />The code in question is a <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> pattern implementation. I already have a couple of other approaches as well, but being a goofball for dynamic language stuff, I cannot resist mirrors, even if they are <a href="http://japhr.blogspot.com/2014/06/benchmarking-dart2js-code.html">terribly slow</a>. But I would prefer my code not be slow and incredibly large, which is where <code>@MirrorsUsed</code> comes into the picture.<br /><br />Last night's approach specified the list of all classes that my code reflects upon. Since this is sample code, I only reflect on one class, <code>ConcreteProduct</code> (a name describing the classes role in the pattern, not an actual implementation). Since there is only one class that gets reflected, the <code>@MirrorsUsed</code> annotation looks like:<pre class=prettyprint>@MirrorsUsed(targets: 'ConcreteProduct')<br />import 'dart:mirrors';</pre>Easy-peasy.<br /><br />Except it will not work in the typical Factory Method pattern case of frameworks. In a framework, the base classes are in one package and libraries are usually in a separate packages. My base <code>Creator</code> class (that would reside the in framework package) is the one that does the reflecting:<pre class=prettyprint>abstract class Creator {<br />  Type productClass;<br /><br />  Product productMaker() {<br /><b>    return reflectClass(productClass).<br />      newInstance(const Symbol(''), []).<br />      reflectee;</b><br />  }<br />}</pre>The concrete creator class that defines the <code>productClass</code> instance variable and the concrete product class would both reside in a separate package:<pre class=prettyprint>class ConcreteCreator extends Creator {<br />  Type productClass = ConcreteProduct;<br />}<br />class ConcreteProduct extends Product {}<br /></pre>The problem is that the import occurs in the “framework” package, which means that the <code>@MirrorsUsed</code> annotation would have no way to know which class the concrete application classes will specific for reflection.<br /><br />This turns out the be the province of the <code>metaTargets</code> option to <code>@MirrorsUsed</code>. The <code>targets</code> option points to a list of classes that will be reflected. The <code>metaTargets</code>, on the other hand, are a list of code annotations that will identify classes that receive reflection.<br /><br />This means that I have to write my own annotations. So I define a <code>@product</code> annotation as:<pre class=prettyprint>const FactoryProduct product = const FactoryProduct();<br />class FactoryProduct {<br />  const FactoryProduct();<br />}</pre>I then tell the dart:mirrors package that it needs to reflect classes annotated with <code>@product</code> with the <code>metaTargets</code> option:<pre class=prettyprint>@MirrorsUsed(metaTargets: const[FactoryProduct])<br />import 'dart:mirrors';<br /></pre>Lastly, I annotate my concrete (application) class that will be reflected:<pre class=prettyprint>@product<br />class ConcreteProduct extends Product {}<br /></pre>With that, I can compile (relatively) small JavaScript:<pre class=prettyprint>$ dart2js -o tool/benchmark.dart.js tool/benchmark.dart<br />$ ls -lh tool/benchmark.dart.js<br />-rw-r--r-- 1 chris chris 171K Jul  2 23:03 tool/benchmark.dart.js<br /></pre>And my JavaScript benchmarking code still runs under Node:<pre class=prettyprint>$ node tool/benchmark.dart.js                          <br />Factory Method — Subclass(RunTime): 0.09583097409453985 us.<br />Factory Method — Map of Factories(RunTime): 4.2090907942975235 us.<br />Factory Method — Mirrors(RunTime): 7.62668883490888 us.</pre>In the end, it was not too tricky to get this working. It just took me a while to realize that annotations were the order of the day.<br /><br />That will do for my initial investigation into the Factory Method for <a href="http://designpatternsindart.com">Design Patterns in Dart</a>. Up tomorrow, I switch to a behavioral Design Pattern that I have always hated.<br /><br /><span style="color: #ccc">Day #110</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/mirrorsused.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/08h7JkinfuU" height="1" width="1"/>
