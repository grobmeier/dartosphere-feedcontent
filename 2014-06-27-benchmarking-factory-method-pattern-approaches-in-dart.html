---
title: 'Benchmarking Factory Method Pattern Approaches in Dart'
layout: post
published: '2014-06-27T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/GVwWcFha6C8/benchmarking-factory-method-pattern.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />A week of background work on <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> has left me with more questions than answers. I expected as much.<br /><br />The big questions that I have only started to grasp mostly revolve around organizing code that will support the book—especially “code in the wild.” Since most code will be available on GitHub, I will likely at least have an account there, but I might need an Organization with multiple accounts to keep everything organized. As private repos and submodules dance in my head, I try to keep my sights on something a little more concrete—benchmarks. <br /><br />At least some the reasoning behind certain design patterns and approaches to design patterns will be born of performance concerns, so I need to start thinking about how to approach this. Do I keep the harness in a public repository? Do I have a public facing book repository with the harness that includes the private book repository as a submodule? Submodules? Really? <br /><br />Gah! I'm terrible at maintaining focus on the small stuff. BUT, for tonight I am just going to set up a test harness in the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> code that I have devised so far to see how it runs.<br /><br />I have mostly been working with existing codebases so far, but for benchmarking, it is best to use small, sample code lest additional complexity impact the numbers. So I start a new <code>factory_method</code> <a href="http://pub.dartlang.org/">Dart Pub</a> package, starting with the <code>pubspec.yaml</code> package file:<pre class=prettyprint>name: factory_method_code<br />dev_dependencies:<br />  benchmark_harness: any</pre>For benchmarking in Dart, the <code>benchmark_harness</code> is probably all that anyone will ever need. Before installing it from <code>pubspec.yaml</code>, I lay out the rest of the code. I start with <code>lib/subclass.dart</code> which contains a subclass example of the Factory method:<pre class=prettyprint>library factory_method_subclass;<br /><br />abstract class Creator {<br />  Product productMaker();<br />}<br /><br />abstract class Product {}<br /><br />class ConcreteCreator extends Creator {<br />  productMaker()=> new ConcreteProduct();<br />}<br /><br />class ConcreteProduct extends Product {}</pre>Next, I create the benchmark “tool” in <code>tool/benchmark.dart</code>:<pre class=prettyprint>import 'package:benchmark_harness/benchmark_harness.dart';<br />import 'package:factory_method_code/subclass.dart';<br /><br />class FactoryMethodSubclassBenchmark extends BenchmarkBase {<br />  const FactoryMethodSubclassBenchmark() : super("Factory Method — Subclass");<br /><br />  static void main() {<br />    new FactoryMethodSubclassBenchmark().report();<br />  }<br /><br />  // The benchmark code.<br />  void run() {<br />    new ConcreteCreator().productMaker();<br />  }<br />}<br /><br />main() {<br />  // Run FactoryMethodSubclassBenchmark<br />  FactoryMethodSubclassBenchmark.main();<br />}</pre>Most of that is copied directly from the <a href="https://github.com/dart-lang/benchmark_harness#example">Example</a> provided on the <code>benchmark_harness</code> page.<br /><br />With the code and directory structure in place, I now install the <code>pubspec.yaml</code> dependencies with <code>pub install</code>:<pre class=prettyprint>➜  factory_method git:(master) ✗ pub install<br />Resolving dependencies... (1.4s)<br />Downloading benchmark_harness 1.0.4...<br />Got dependencies!</pre>With that, I can run my benchmark:<pre class=prettyprint>➜  factory_method git:(master) ✗ dart tool/benchmark.dart<br />Factory Method — Subclass(RunTime): 0.24725152118407764 us.</pre>OK that is  definitely a number, but without something to compare it to, it is a pretty useless number. I might as well compare it to the map-of-factories approach to Factory Method from last night. I <i>think</i> this can be boiled down to:<pre class=prettyprint>typedef Product productMaker();<br />Map&lt;Type, productMaker> Factory = {<br />  ConcreteCreator: (){ return new ConcreteProduct(); }<br />};<br /><br />abstract class Creator {<br />  Product productMaker()=> Factory[this.runtimeType]();<br />}<br /><br />abstract class Product {}<br /><br />class ConcreteCreator extends Creator {}<br /><br />class ConcreteProduct extends Product {}</pre>When it comes to the benchmarking code, I hit my first snag. The creator and product classes are names the same thing in both samples. So I need to prefix the imports:<pre class=prettyprint>import 'package:benchmark_harness/benchmark_harness.dart';<br /><b>import 'package:factory_method_code/subclass.dart' as Subclass;<br />import 'package:factory_method_code/map_of_factories.dart' as MapOfFactories;</b><br /><br />class FactoryMethodSubclassBenchmark extends BenchmarkBase {<br />  // ...<br />  void run() {<br /><b>    new Subclass.ConcreteCreator().productMaker();</b><br />  }<br />}<br /><br />class FactoryMethodMapBenchmark extends BenchmarkBase {<br />  const FactoryMethodMapBenchmark() : super("Factory Method — Map of Factories");<br /><br />  static void main() {<br />    new FactoryMethodMapBenchmark().report();<br />  }<br /><br />  void run() {<br /><b>    new MapOfFactories.ConcreteCreator().productMaker();</b><br />  }<br />}<br /><br />main() {<br />  FactoryMethodSubclassBenchmark.main();<br />  FactoryMethodMapBenchmark.main();<br />}<br /></pre>Aside from that, everything else works perfectly. And when I run my double benchmarks, I get:<pre class=prettyprint>➜  factory_method git:(master) ✗ dart tool/benchmark.dart<br />Factory Method — Subclass(RunTime): 0.24548983015417866 us.<br />Factory Method — Map of Factories(RunTime): 1.900878681170371 us.<br /></pre>Yikes! The map of factories approach is more than 600% slower. I expected the subclass approach to be quicker, but that amount really surprises me. So much so that I wonder if I am testing both at similar levels of abstraction. I will ruminate on this tomorrow (and also pull in tests of my mirror approach).<br /><br />Regardless, this benchmarking approach seems reasonable. It is good to be aware of the need to prefix the imports, but that aside, this seems a good way to obtain admittedly illuminating numbers.<br /><br /><br /><span style="color: #ccc">Day #105</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/06/compile-time-constant-factory-method.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/GVwWcFha6C8" height="1" width="1"/>
