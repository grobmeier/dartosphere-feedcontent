---
title: 'Serializing Mementos: A Good Idea? '
layout: post
published: '2015-12-04T23:00:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/pV9PacMflQ8/im-pretty-answer-is-going-to-be-dont.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - memento

---

<div class=top-chain-links></div><br />I'm pretty the answer is going to be "don't."<br /><br />Still, I would like to explore serializing the memento object in the <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a> for offline storage. The whole point of the memento pattern is to facilitate restoring state without allowing access to that state. This exercise may come down to semantics, but let's try it out first.<br /><br />Currently, I am working with my <a href="http://dartlang.org">Dart</a> <code>VelvetFogMachine</code> object, which aids in the search for the ultimate Mel Tormé playlist. This is the originator in the memento pattern. In the caretaker code, I keep a list of saved state and work with this <code>VelvetFogMachine</code>:<pre class=prettyprint><code>  // List of mementos<br />  List replayer = [];<br /><br />  // The originator<br />  var scatMan = new VelvetFogMachine();<br /></code></pre>This caretaker code cannot see inside the memento—and thus cannot access the internal state of the <code>VelvetFogMachine</code>. It can tell the machine to play music and, at particularly moving moments of playback, request a bookmark so that we can return to this point in the current song:<pre class=prettyprint><code><br />  // ...<br />  scatMan.play(<br />      '\'Round Midnight',<br />      'Tormé'<br />  );<br />  replayer.add(scatMan.nowPlaying);<br />  // ...<br />  scatMan.play(<br />      'New York, New York Medley',<br />      'A Vintage Year'<br />  );<br />  replayer.add(scatMan.nowPlaying);<br />  // ...</code></pre>The <code>play()</code> sends the currently playing song to STDOUT, so running this code results in a report similar to:<pre class=prettyprint>$ ./bin/play_melvie.dart<br />Playing 'Round Midnight // Tormé @ 0.00<br />...<br />Playing New York, New York Medley // A Vintage Year @ 0.00<br />...</pre>And, when the <code>VelvetFogMachine</code> is sent back to a memento:<pre class=prettyprint><code>  // Restore a memento<br />  scatMan.backTo(replayer.last);</code></pre>It is reported as:<pre class=prettyprint><code>  *** Whoa! This was a good one, let's hear it again :) ***<br />Playing New York, New York Medley // A Vintage Year @ 1.27</code></pre>So things work well and encapsulation is maintained. There is no way for the caretaker to get at the current state of the <code>VelvetFogMachine()</code>. All interaction goes through the <code>play()</code> method which is then solely responsible for updating the internal state of things. By keeping the <code>VelvetFogMachine</code> interface narrow like this, it will be more reliable and is more extensible.<br /><br />So what about storing the <code>replayer</code> list of mementos offline for later restore? Will something like the following break encapsulation?<pre class=prettyprint><code>  var saved = serializePlaylist(replayer);<br />  // Then, some time later...<br />  var restored = deserializePlaylist(saved);<br />  scatMan.backTo(restored.first);</code></pre>To answer that question, I start in the <code>velvet_fog_machine</code> library by importing the <code>dart:convert</code> library so that the object can be serialized into JSON:<pre class=prettyprint>library velvet_fog_machine;<br /><br />import 'dart:convert';<br />//... </pre>The memento object itself, which describes the currently playing song, will need to support a <code>toJson()</code> method to work with the <code>JSON.encode()</code> method:<pre class=prettyprint>// The Memento<br />class _Playing {<br />  Song _song;<br />  double _time;<br />  _Playing(this._song, this._time);<br />  Map toJson() => {'song': _song.toJson(), 'time': _time};<br />}</pre>That makes the <code>serializePlaylist()</code> helper function quite straight-forward. I can simply call <code>JSON.encode</code> on the list of <code>_Player</code>  mementos and <code>dart:convert</code> does the rest:<pre class=prettyprint>String serializePlaylist(List&lt;_Playing> list) => JSON.encode(list);</pre>As for getting the memento back, that is a little harder. This is where the knowledge of the underlying implementation is needed. I have to decode the JSON list of mementos, then map each item in the list into a <code>_Playing</code> object:<pre class=prettyprint>List&lt;_Playing> deserializePlaylist(String json) {<br />  return JSON.decode(json).map((p) {<br />    var time = p['time'];<br />    var song = new Song(p['song']['title'], p['song']['album']);<br />    return new _Playing(song, time);<br />  });<br />}</pre>With that, the serialize/deserialize code in the caretaker:<pre class=prettyprint><code>  var saved = serializePlaylist(replayer);<br />  var restored = deserializePlaylist(saved);<br />  scatMan.backTo(restored.first);</code></pre>Will produce:<pre class=prettyprint><code>  *** Whoa! This was a good one, let's hear it again :) ***<br />Playing New York, New York Medley // A Vintage Year @ 1.27<br />--<br />  *** Whoa! This was a good one, let's hear it again :) ***<br />Playing 'Round Midnight // Tormé @ 2.89</code></pre>So it works, but does it violate the either the letter or the spirit of the memento pattern law?<br /><br />I would argue that it does not violate the spirit of the law. All of the internal knowledge of the implementation details remains in the <code>velvet_fog_machine</code> library. The caretaker code still maintains the list of mementos. And it still cannot access the internal state of the <code>VelvetFogMachine</code>. <br /><br />That said, it <i>could</i> get access to the internal state and some idea of the implementation by looking at the serialized mementos in the list:<pre class=prettyprint>[{"song":<br />   {"title":"'Round Midnight","album":"Tormé"},<br /> "time":2.89},<br />{"song":<br />   {"title":"New York, New York Medley","album":"A Vintage Year"},<br />"time":1.27}]</pre>Ultimately, I think this is probably OK-ish. Even armed with with this knowledge, the caretaker code still cannot access the actual data in the memento. It is still forced to work through the <code>play()</code> method to interact with the internal state of the originator. Some details are exposed, but not in a manner in which the caretaker can affect the originator. So the originator retains encapsulation and the code remains maintainable. <br /><br />So the answer would seem to be, "do". But only if necessary.<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/69bc9464388fadee2042">https://dartpad.dartlang.org/69bc9464388fadee2042</a>.</i><br /><br /><br /><a href="http://designpatternsindart.com/">Design Patterns in Dart</a> <br /><br /><br /><span style="color: #ccc">Day #23</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/an-iterator-memento.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/the-caretaker-mel-and-one-velvet-fog.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/pV9PacMflQ8" height="1" width="1" alt=""/>
