---
title: 'Simple Visitor Pattern in Dart'
layout: post
published: '2014-07-04T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/oMj7SxHCiHE/simple-visitor-pattern-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />Digging through the Visitor pattern code in <a href="https://pub.dartlang.org/packages/polymer_expressions">polymer_expressions</a> was supremely illuminating yesterday. But I feel that I need some actual code to play with tonight. <br /><br />The point of this continues to help me to determine which questions I need to ask as I explore patterns for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. This is background research for my eventual research. The code review from yesterday served two purposes: looking at a solid implementation of the pattern in <a href="http://dartlang.org">Dart</a> and identifying the pattern in the wild. The former is purpose unto itself. The latter I need because the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> included discussion of each pattern in the wild, which is something that I appreciate.<br /><br />But there is nothing like the feel of real code.<br /><br />Not wanting to get involved in abstract syntax trees, which seem particularly well suited to the Visitor pattern, I instead translate the example from the GoF book into Dart. I start with an abstract <code>Equipment</code> class:<pre class=prettyprint>abstract class Equipment {<br />  String name;<br />  Equipment(this.name);<br /><br />  int watt;<br />  double netPrice;<br />  double discountPrice() => netPrice;<br /><br />  <b>void accept(vistor);</b><br />}</pre>There is nothing too fancy here, which is partially the point of Visitor—it keeps the nodes in a data structure clean of unnecessary code. Here, I declare that equipment in my list of inventory will have a name, the number of watts that it consumes, a price and, optionally, a discount price.<br /><br />There is one method that does not have anything to do with the intrinsic meaning of what equipment is or does. The <code>accept()</code> method will take some kind of visitor in order to do… something with it. What that “something” is will depend on the purpose of the visitor. Before building a visitor, I declare a few pieces of equipment. With apologies to the Gang of Four, I opt for newer types of equipment (what the heck is a “floppy disk”?):<pre class=prettyprint>class Mobile extends Equipment {<br />  Mobile(): super('Mobile Phone');<br />  double netPrice = 350.00;<br />  void accept(visitor) { visitor.visitMobile(this); }<br />}<br /><br />class Tablet extends Equipment {<br />  Tablet(): super('Tablet');<br />  double netPrice = 400.00;<br />  void accept(visitor) { visitor.visitTablet(this); }<br />}<br /><br />class Laptop extends Equipment {<br />  Laptop(): super('Laptop');<br />  double netPrice = 1000.00;<br />  double discountPrice() => netPrice * .9;<br />  void accept(visitor) { visitor.visitLaptop(this); }<br />}<br /></pre>Each piece of <i>modern</i> equipment has a name and price. To mix things up, I declare that laptops have discount prices of 90% of the net price while other pieces have no discount. The important aspect of each of these is that the concrete equipment classes accept a visitor and then call the method in the visitor that corresponds to the type of equipment. That is, the <code>Laptop</code> class calls <code>visitLaptop()</code> in the visitor. <br /><br />The implication is that, for each type of equipment that I have, all visitors will need to have a corresponding “visit” method. Since I currently have three possible types of equipment, that means that my equipment visitors will have to declare at least theses three visit methods:<pre class=prettyprint>abstract class EquipmentVisitor {<br />  void visitMobile(Mobile m);<br />  void visitTablet(Tablet t);<br />  void visitLaptop(Laptop l);<br />}</pre>The visitor example used in the GoF was a cost calculator. If I have a list of work stuff that looks like:<pre class=prettyprint><code>  var work_stuff = [<br />    new Mobile(),<br />    new Tablet(),<br />    new Laptop()<br />  ];</code></pre>Then I ought to be able to report on the total cost. If the report only needs to include the net cost, a simple iteration across this list would suffice. But what if there are different reporting rules for each kind of equipment? What if I need to report the net price for mobiles, but discount price for tablets and laptops? Conditionals inside iterators are ugly. Enter the <code>PricingVisitor</code>:<pre class=prettyprint>class PricingVisitor extends EquipmentVisitor {<br />  double _totalPrice = 0.00;<br /><br />  double get totalPrice => _totalPrice;<br /><br />  void visitMobile(e) { _totalPrice += e.netPrice; }<br />  void visitTablet(e) { _totalPrice += e.discountPrice(); }<br />  void visitLaptop(e) { _totalPrice += e.discountPrice(); }<br />}</pre>If I have three mobiles, each will call <code>visitMobile()</code> ensuring that I get an accurate count. If I do not require a tablet, <code>visitTablet()</code> will never be called and will not count toward the total. As long as each piece of work equipment is told to accept the <code>PricingVisitor</code>, I will get my total price. Best of all, any variations of rules are grouped in one place rather than scattered throughout a number of classes.<br /><br />To put this is use, I have the <code>main()</code> entry point for my code invoke <code>accept()</code> for each piece of equipment:<pre class=prettyprint>main() {<br />  var cost = new PricingVisitor();<br /><br />  var work_stuff = [<br />    new Mobile(),<br />    new Tablet(),<br />    new Laptop()<br />  ];<br /><br />  work_stuff.forEach((e){ e.accept(cost); });<br /><br />  print('Cost of work stuff: ${cost.totalPrice}.');<br />}<br /></pre>The result:<pre class=prettyprint>$ /bin/cost.dart<br />Cost of work stuff: 1650.0.<br /></pre>That was rather nice—and easy.<br /><br />There is still much to explore with the Visitor—difference implementations, additional visitors, more complex data structures than simple lists—but this GoF example seems promising even when translated to modern times.<br /><br /><br /><span style="color: #ccc">Day #112</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/patterns-in-wild-visitor-in-polymer.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/visitor-with-little-composite-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/oMj7SxHCiHE" height="1" width="1"/>
