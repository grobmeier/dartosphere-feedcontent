---
title: 'The Bridge Pattern with Websockets and HTTP'
layout: post
published: '2016-01-30T20:50:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Na5hsVKM308/the-bridge-pattern-with-websockets-and.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Design patterns don't tell us how to develop systems. Patterns are names applied to how we already develop. Knowing patterns well won't help us to implement them better in the future—we are already doing that very fine, thank you very much. Knowing a pattern is understanding its consequences and puts us in a better position to minimize or take advantage of those consequences. <br /><br />That's all fine—if you recognize the pattern. When I first started playing with it, I could not think of an example in which I had used the <a href="https://en.wikipedia.org/wiki/Bridge_pattern">bridge pattern</a>. It took me some brain digging, but I think I finally excavated a real-world example of it.<br /><br />Consider, if you will, a browser application that normally communicates with a server over websockets, but has to switch to plain-old HTTP under certain circumstances. The reason for switching might be an older client, a low-memory browser, or simply that this part of the application needs to talk to an HTTP-only server. <br /><br />Whatever the reason, the web application should not change when the communication implementation changes. If the application is a simple form, then the web form and backing code should never change when switching between HTTP and websockets:<br /><br /><a href="http://4.bp.blogspot.com/--tmtavv4bdI/Vq0lL7JULCI/AAAAAAABD3M/nvbNiSh4NE4/s1600/01-web_form_with_different_implementors.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/--tmtavv4bdI/Vq0lL7JULCI/AAAAAAABD3M/nvbNiSh4NE4/s640/01-web_form_with_different_implementors.png" width=570 /></a><br /><br />I need to suss out better names for the actors in this play, but I start by calling the web form a "messenger" and mechanism for talking "communication." They are kind of the same thing, so I need to work on that, but it will do for a start. The <code>Messenger</code> abstraction will require a <code>Communication</code> implementation of some kind and will need to know how to send messages with that communication channel. Expressed in <a href="http://dartlang.org">Dart</a>, that looks like:<pre class=prettyprint>abstract class Messenger {<br />  Communicator comm;<br />  Messenger(this.comm);<br />  void send();<br />}</pre>The refined abstraction is a web form messenger that gets the message to send from a text element:<pre class=prettyprint>class FormMessenger extends Messenger {<br />  Element _messageElement;<br />  FormMessenger(this._messageElement) : super(new HttpCommunicator());<br /><br />  void send() {<br />    comm.save(message);<br />  }<br /><br />  String get message => _messageElement.value;<br />}</pre>As can be seen from the <code>send()</code> method, the <code>Communication</code> class needs to support a <code>save()</code> method in order to save the message on the backend:<pre class=prettyprint>abstract class Communicator {<br />  void save(String message);<br />}</pre>The <code>HttpCommunicator</code> is simple enough, thanks to the <code>HttpRequest.postFormData()</code> method:<pre class=prettyprint>class HttpCommunicator implements Communicator {<br />  void save(message) {<br />    HttpRequest.postFormData('/save', {'message': message});<br />  }<br />}</pre>The second implementor, the <code>WebsocketCommunicator</code> class, takes a little more setup for websockets, but is still pretty straight forward:<pre class=prettyprint>class WebSocketCommunicator implements Communicator {<br />  WebSocket _socket;<br />  WebSocketCommunicator() { _startSocket(); }<br /><br />  _startSocket() async {<br />    _socket = new WebSocket('ws://localhost:4040/ws');<br /><br />    var _c = new Completer();<br />    _socket.onOpen.listen((_){ _c.complete(); });<br />    await _c.future;<br />  }<br /><br />  void save(message) {<br />    _socket.send(message);<br />  }<br />}</pre>And that pretty much does it. Aside from some better naming, this feels like a fairly accessible example. <br /><br />One of the implications of the bridge pattern is that a code decision needs to be made as to where to assign the implementor. For a fist pass, I listen to the two radio buttons in the form and, based on which is selected, I assign a different <code>Communicator</code>:<pre class=prettyprint><code>  queryAll('[name=implementor]').<br />    onChange.<br />    listen((e) {<br />      var input = e.target;<br />      if (!input.checked) return;<br /><br />      if (input.value == 'http')<br />        message.comm = new HttpCommunicator();<br />      else<br />        message.comm = new WebSocketCommunicator();<br />    });</code></pre>With that, I can switch between implementors and send messages to the server however I like:<pre class=prettyprint>$ ./bin/server.dart<br />[HTTP] message=A+web+form+message%21<br />[WebSocket] A web form message!<br />[HTTP] message=A+web+form+message%21<br />[HTTP] message=A+web+form+message%21<br />[HTTP] message=A+web+form+message%21</pre>Nice! Now all that is left is to come up with some better names.<br /><br /><i>Full code for the frontend and backend is located at: <a href="https://github.com/eee-c/design-patterns-in-dart/tree/master/bridge">https://github.com/eee-c/design-patterns-in-dart/tree/master/bridge</a>.</i><br /><br /><br /><span style="color: #ccc">Day #80</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/handle-body-reference-counting-in.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/when-to-choose-your-own-implementation.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Na5hsVKM308" height="1" width="1" alt=""/>
