---
title: 'Reflecting on Dart Classes and Variables'
layout: post
published: '2014-05-09T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/5kdGAYfXZR8/reflecting-on-dart-classes-and-variables.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - annotations
    - chain
    - dart
    - dartlang
    - reflection

---

<div class=top-chain-links></div><br />I have the beginnings of understanding for reflection in <a href="http://dartlang.org">Dart</a>. <br /><br />Coming from a predominantly dynamic language background, I confess that I find most of this painful and awkward. Still, there is something fascinating about it—and not just in a gawking-at-a-car-crash kind of way (though there is definitely some of that). Even if I stick mostly to dynamic languages, this stuff will give me a better appreciation for what is going on. But as Anguar.dart has proven, there is something inherently useful about this by itself.<br /><br />I left off last night with the ability to reflect on annotations on the current function:<pre class=prettyprint>import 'dart:mirrors';<br /><br /><b>@meta('This is main!')</b><br />main() {<br />  print('[main] Hello!');<br /><br /><b>  var selfMirror = (reflect(main) as ClosureMirror).function;<br />  var metaData = selfMirror.metadata;<br />  print('[main] Meta is: ${metaData[0].reflectee.note}');</b><br />}<br /><br />// The @meta annotation definition<br />class meta {<br />  final String note;<br />  const meta(this.note);<br />}<br /></pre>The above prints out the following when run from the command-line:<pre class=prettyprint>[main] Hello!<br />This foo is Bob.<br />[main] Meta is: This is main!</pre>What I would like tonight is to figure out how to reflect on class metadata (i.e. annotations). Just to make things interesting, I move my annotation class and the class on which I would like to reflect into a new code file, <code>foo.dart</code>:<pre class=prettyprint>@meta('Foo should not be used in real life')<br />class Foo {<br />  String name;<br />  Foo(this.name);<br />  toString() => "This foo is $name.";<br />}<br /><br />class meta {<br />  final String note;<br />  const meta(this.note);<br />}</pre>Back in <code>main.dart</code>, I import <code>foo.dart</code>, create and use an instance of the imported <code>Foo</code> to make sure it works, and then reflect on the <code>Foo</code> class:<pre class=prettyprint><b>import 'foo.dart';</b><br />import 'dart:mirrors';<br /><br />@meta('This is main!')<br />main() {<br />  print('[main] Hello!');<br /><br />  var selfMirror = (reflect(main) as ClosureMirror).function;<br />  var metaData = selfMirror.metadata;<br />  print('[main] Meta is: “${metaData[0].reflectee.note}”');<br /><br /><b>  var foo = new Foo('Bob');<br />  print(foo.toString());<br /><br />  var fooMirror = reflect(Foo);<br />  print(fooMirror);</b><br />}<br /></pre>This prints out the following when run:<pre class=prettyprint>$ dartanalyzer main.dart && dart main.dart<br />Analyzing main.dart...<br />No issues found<br />[main] Hello!<br />[main] Meta is: “This is main!”<br /><b>This foo is Bob.<br />InstanceMirror on Type: class 'Foo'</b></pre>So the <code>toSting()</code> method on <code>Foo</code> seems to work just fine. That is not the problem that I am trying to solve here. What I want is a way to extract metadata from the code. As I found last night, that <code>InstanceMirror</code> that I get by reflecting on <code>Foo</code> is not going to help me. I need something that implements a <code>DeclarationMirror</code>. For last night's function, that was a <code>MethodMirror</code>. For classes, that would appear to be a <code>ClassMirror</code>, but I can find no way to get to a <code>ClassMirror</code> from the reflected <code>InstanceMirror</code>.<br /><br />The answer turns out to be that I should not be reflecting on the <code>Foo</code> class. Instead I should be reflect-classing on the <code>Foo</code> class with with <code>reflectClass()</code> function:<pre class=prettyprint>main() {<br />  // ...<br /><b>  var fooMirror = reflectClass(Foo);</b><br />  var fooMetaData = fooMirror.metadata;<br />  print('[main] Foo meta is: “${fooMetaData[0].reflectee.note}”');<br />}</pre>With that, I am successfully able to grab the note from the <code>@meta</code> annotation:<pre class=prettyprint>$ dartanalyzer main.dart && dart main.dart<br />Analyzing main.dart...<br />No issues found<br />[main] Hello!<br />[main] Meta is: “This is main!”<br />This foo is Bob.<br /><b>[main] Foo meta is: “Foo should not be used in real life”</b></pre>To summarize, to grab metadata from a function, I reflect on the function, access the <code>function</code> property from the <code>ClosureMirror</code> to get a <code>MethodMirror</code>, which contains the metadata. To grab metadata from a class, I reflect-class on the class, which gives me direct access to the metadata. I do not have high hopes that I am going to remember that next week.<br /><br />Because that is not confusing enough, I find myself wondering about variable declaration annotations. So, what the heck, I annotate the <code>name</code> instance variable in my <code>Foo</code> class with my same custom <code>@meta</code> annotation:<pre class=prettyprint>@meta('Foo should not be used in real life')<br />class Foo {<br /><b>  @meta('This is the name of the Foo')</b><br />  String name;<br />  Foo(this.name);<br />}<br /></pre>Getting this meta information at runtime turns out to be fairly easy. Well, maybe not “fairly”—let's call it “relatively” easy.  The <code>ClassMirror</code> from <code>reflectClass()</code> has a <code>declarations</code> Map. I can iterate over that to get any declarations that contain annotation metadata with:<pre class=prettyprint>main() {<br />  // ...<br />  var fooMirror = reflectClass(Foo);<br />  var fooMetaData = fooMirror.metadata;<br />  print('[main] Foo meta is: “${fooMetaData[0].reflectee.note}”');<br /><br /><b>  for (var k in fooMirror.declarations.keys) {<br />    if (fooMirror.declarations[k].metadata.length == 0) continue;<br />    var _m = fooMirror.declarations[k].metadata;<br />    print("[main] $k: ${_m[0].reflectee.note}");<br />  }</b><br />}<br /></pre>I rather like that. It is nice that the <code>ClassMirror</code> has such nice information readily available. I'm not saying that I am going to drop all my dynamic languages or anything, but reflecting on variables makes merciful sense to me.<br /><br /><span style="color: #ccc">Day #58</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/05/reflecting-on-annotations.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/05/reflecting-on-class-reflecting-on-object.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/5kdGAYfXZR8" height="1" width="1"/>
