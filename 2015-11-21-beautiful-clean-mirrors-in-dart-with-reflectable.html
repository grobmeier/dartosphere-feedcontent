---
title: 'Beautiful, Clean Mirrors in Dart with Reflectable'
layout: post
published: '2015-11-21T23:06:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/AJm62WS9IuA/beautiful-clean-mirrors-in-dart-with.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - flyweight
    - mirrors

---

<div class=top-chain-links></div><br />Tonight, I hope to make better <a href="http://dartlang.org">Dart</a> mirrors with the <a href="https://pub.dartlang.org/packages/reflectable">reflectable</a> package. Better being a relative term, I hope to make my code clearer and the resulting compiled code smaller. Given my relatively small code, it may be asking too much of reflectable, but it always best to aim high.<br /><br />I am still working on different approaches to the <a href="https://en.wikipedia.org/wiki/Flyweight_pattern">Flyweight Pattern</a> for the forthcoming <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. The most recent tangent is exploring custom annotations that identify concrete flyweight classes in my code:<pre class=prettyprint>@flavor<br />class Cappuccino implements CoffeeFlavor {<br />  String get name => 'Cappuccino';<br />  double get profitPerOunce => 0.35;<br />}</pre>The factory constructor responsible for caching flyweights uses this custom <code>@flavor</code> annotation to identify the <code>Cappuccino</code> class as a concrete flyweight that can be used in my coffee shop application. <br /><br />Thanks to the built-in <a href="https://api.dartlang.org/stable/dart-mirrors/dart-mirrors-library.html">dart:mirrors</a> library, I was able to get this working. Thanks to the <code>@MirrorsUsed()</code> annotation from <code>dart:mirrors</code>, I got this compiled to somewhat smallish Javascript. Let's see if reflectable can be better than "working" and "smallish."<br /><br />I add <code>reflectable</code> to my <code>pubspec.yaml</code>:<pre class=prettyprint>name: flyweight_code<br />dependencies:<br />  reflectable: any<br /></pre>After a quick <code>pub get</code> to load the package and its dependencies, I replace the <code>dart:mirrors</code> import with <code>reflectable</code> in my coffee shop library:<pre class=prettyprint>library coffee_shop;<br /><br />// @MirrorsUsed(metaTargets: "coffee_shop.Flavor")<br />// import 'dart:mirrors';<br /><br />import 'package:reflectable/reflectable.dart';<br />// ...</pre>With that, I get errors related to missing <code>currentMirrorSystem</code> method that had been defined in <code>dart:mirrors</code>. Let's see if I can fix that.<br /><br />I start by replacing the <code>const</code> used for the <code>@flavor</code> annotation with a reflectable version:<pre class=prettyprint>class Flavor extends Reflectable {<br />  const Flavor()<br />    : super(newInstanceCapability);<br />}<br /><br />const flavor = const Flavor();<br /></pre>I need the <code>newInstanceCapability</code> to replace the functionality in the factory constructor for <code>CoffeeFlavor</code>. With <code>dart:mirrors</code> that looked like:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  factory CoffeeFlavor(name) {<br />    return _cache.putIfAbsent(name, () =><br />        classMirrors[new Symbol(name)].<br />            newInstance('', []).<br />            reflectee<br />    );<br />  }<br />  // ...<br />}</pre>This is the heart of the Flyweight Pattern that I am trying to replicate with reflectable. If a particular coffee flyweight is not present, this should add a single instance to the internal cache. Then, no matter how many times the same coffee flavor is ordered later, the same instance will be returned.<br /><br />This code is not the most difficult aspect of using mirrors in this case. Finding the annotated classes to build that <code>classMirrors</code> property is a gigantic pain in <code>dart:mirrors</code>:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  static Map _allDeclarations = currentMirrorSystem().<br />      libraries.<br />      values.<br />      fold({}, (memo, library) => memo..addAll(library.declarations));<br /><br />  static Map classMirrors = _allDeclarations.<br />    keys.<br />    where((k) => _allDeclarations[k] is ClassMirror).<br />    where((k) =><br />      _allDeclarations[k].metadata.map((m)=> m.type.reflectedType).contains(Flavor)<br />    ).<br />    fold({}, (memo, k) => memo..[k]= _allDeclarations[k]);<br />  // ...<br />}</pre>Mercifully, the <code>Reflectable</code> class has just what I need: an <code>annotatedClasses</code> property. Since the <code>Flavor</code> constant used for the <code>@flavor</code> annotation is a subclass of <code>Reflectable</code>, I don't have to do any work to find the concrete, <code>@flavor</code> annotated, flyweight classes. I can simply use that property. All of that work then becomes just:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  static Map classMirrors = flavor.<br />    annotatedClasses.<br />    fold({}, (memo, c) => memo..[c.simpleName]= c);<br />  // ...<br />}</pre>Even nicer, the reflectable package makes it easier to get ahold of real objectsâ€”no need for the <code>reflectee</code> property. The factory constructor then becomes simply:<pre class=prettyprint>class CoffeeFlavor {<br />  // ...<br />  factory CoffeeFlavor(name) {<br />    return _cache.putIfAbsent(name, () =><br />        classMirrors[name].<br />            newInstance('', [])<br />    );<br />  }<br />  // ...<br />}</pre>That is a big win for overall readability of my mirror-based Dart code. Content, I stop here for today. I will pick back up with transforming this code into JavaScript tomorrow. And unless it generates gigabyte-sized code, I have the feeling that the reflectable package will become my go-to solution for mirrors in Dart. That is some pretty mirror code!<br /><br /><br /><span style="color: #ccc">Day #10</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/11/impact-of-reflection-on-annotations-in.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/11/cant-transform-my-reflectable-flyweight.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/AJm62WS9IuA" height="1" width="1" alt=""/>
