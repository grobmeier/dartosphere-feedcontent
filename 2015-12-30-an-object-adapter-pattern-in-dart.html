---
title: 'An Object Adapter (Pattern) in Dart'
layout: post
published: '2015-12-30T21:54:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/SJd4OHxQwPA/an-object-adapter-pattern-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />It would have been fun to come up with a class <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a> in <a href="http://dartlang.org">Dart</a>. Sadly, the best that I could come up with is of <a href="http://japhr.blogspot.com/2015/12/class-adapters-in-dart-vague-attempt.html">very limited use</a>. Even though I usually get in trouble when I say this, I suspect that the object adapter will be easy to implement. Let's see how much trouble that causes.<br /><br />I am still working with generic implementation names for my classes. <code>Target</code> describes the simple interface that I am trying to support:<pre class=prettyprint>class Target {<br />  void request() {<br />    print("[Target] A request.");<br />  }<br />}</pre>So all my adaptee needs to support is the <code>request()</code> method. Currently, however, it resides in a separate library over which I nominally have no control:<pre class=prettyprint>library adaptee;<br /><br />class Adaptee {<br />  void specificRequest() {<br />    print("[Adaptee] A specific request.");<br />  }<br />}</pre>In the sample code in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>, client code creates an instance of the adaptee to supply to the adapter. To follow along with that example, I need something along the lines of:<pre class=prettyprint>import 'package:adapter_code/adaptee.dart';<br />import 'package:adapter_code/adapter.dart';<br /><br />main() {<br />  var adaptee = new Adaptee();<br />  var adapter = new Adapter(adaptee);<br /><br />  // Invoke a target method, not available on the adaptee:<br />  adapter.request();<br />}</pre>Then, to implement the adapter class, I need to accept an <code>Adaptee</code> argument in the constructor and define a <code>request()</code> method that, among other things, invokes a specific method on that <code>Adaptee</code>:<pre class=prettyprint>class Adapter extends Target {<br />  Adaptee _adaptee;<br /><br />  Adapter(this._adaptee);<br /><br />  void request() {<br />    print("[Adapter] doing stuff..");<br />    _adaptee.specificRequest();<br />  }<br />}</pre>Of note, I extend <code>Target</code> rather than implement its interface. The end result is the same in this case since I redefine request. Still, this might come in handy should I need access to another helper method from <code>Target</code>.<br /><br />Whoops! That's some premature generalization if ever there was some. I note that I <i>could</i> do that if needed, but, for now, I only implement the interface:<pre class=prettyprint>class Adapter implements Target {<br />  Adaptee _adaptee;<br /><br />  Adapter(this._adaptee);<br /><br />  void request() {<br />    print("[Adapter] doing stuff..");<br />    _adaptee.specificRequest();<br />  }<br />}</pre>With that, I have my object adapter. Running the client code results in some work in the adapter and some in the adaptee:<pre class=prettyprint>$ ./bin/adapt.dart                                             <br />[Adapter] doing stuff..<br />[Adaptee] A specific request.</pre>One of last night's laments—that the class adapter exposed the adaptee's methods publicly—is no longer applicable here. The only publicly supported method is <code>request()</code> from the target interface. Of course, the client code still has access to the adaptee's <code>specificRequest()</code> method via <code>adaptee</code>. The point is to maintain proper encapsulation, not to prevent access, so this is acceptable.<br /><br />So for once I did not jinx myself. The adapter pattern in object form really is pretty darn easy. There are a couple of not-too-surprising implications (implement the target until extending is required, the adaptee is available in the client context, encapsulation is resolved), but this really went pretty much as expected. Darn it.<br /><br />Maybe a specific case tomorrow will provide a little more excitement!<br /><br /><i>Play with the boring code yourself on DartPad: <a href="https://dartpad.dartlang.org/0cbca96caaa3ac9f95da">https://dartpad.dartlang.org/0cbca96caaa3ac9f95da</a>.</i><br /><br /><br /><br /><span style="color: #ccc">Day #49</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/class-adapters-in-dart-vague-attempt.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/adapting-procedural-code.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/SJd4OHxQwPA" height="1" width="1" alt=""/>
