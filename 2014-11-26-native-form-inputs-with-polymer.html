---
title: 'Native Form Inputs with Polymer'
layout: post
published: '2014-11-26T23:59:00-05:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/StaR2VGvIs0/native-form-inputs-with-polymer.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - polymer

---

<div class=top-chain-links></div><br /><a href="http://www.polymer-project.org/">Polymer</a>'s inability to define form elements still bugs me. Recent work to support this in <a href="http://www.polymer-project.org/docs/elements/paper-elements.html">Paper Elements</a> is progress, but sometimes you just don't want an input element that looks like a Google property. <br /><br />I have <i>a</i> solution in <a href="http://patternsinpolymer.com/">Patterns in Polymer</a>. Said solution works with minimal overhead in both JavaScript and <a href="http://dartlang.org">Dart</a>. Still, there is overhead and the penalty is paid by the developer using my awesome custom element... which makes my awesome custom element slightly less awesome. <br /><br />The current approach in <a href="http://patternsinpolymer.com/">Patterns in Polymer</a> requires additional code to sync a hidden <code>&lt;input></code>'s value with that of the Polymer custom element. So why not have the Polymer element be responsible for synchronizing with the hidden input? And why not take that a step further by making the Polymer element responsible for creating the hidden input in the containing light DOM?<br /><br />The answer to the last question is encapsulation. But darn it, if Polymer can't make native form elements then screw encapsulation. This turns out to be surprisingly easy to implement. To add support to the <code>&lt;x-pizza></code> element for a "toppings" form input value, I can add a hidden input when <code>&lt;x-pizza></code> is attached to the DOM:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br /><b>  Element lightInput;</b><br />  // ...<br />  void attached() {<br />    super.attached();<br />    // ...<br /><b>    lightInput = new HiddenInputElement()..name = 'toppings';<br />    parent.append(lightInput);</b><br />  }<br />  // ...<br />}</pre>With that element in the light DOM, I can keep it in sync with the internal pizza state by making the already defined <code>_updatePizzaState()</code> method responsible for updating the hidden field as well:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  updatePizzaState([_]) {<br />    // ...<br />    if (lightInput == null) return;<br /><b>    lightInput.value = state;</b><br />  }<br />  // ...<br />}</pre>And that works perfectly fine:<br /><br />I still think that the MutationObserver approach is a useful pattern for the book, but I am hard-pressed to think that it is a better solution that a breaks-encapsulation light-DOM input. I'll give it a day or two.<br /><br /><br /><span style="color: #ccc">Day #6</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/11/better-polymerdart-tests-with-futures.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/StaR2VGvIs0" height="1" width="1"/>
