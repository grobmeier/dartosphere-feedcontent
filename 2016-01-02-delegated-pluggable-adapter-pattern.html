---
title: 'Delegated Pluggable Adapter Pattern'
layout: post
published: '2016-01-02T22:29:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/hiyv8IFc1VE/delegated-pluggable-adapter-pattern.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I am reasonably happy with last night's pluggable adapter pattern in <a href="http://dartlang.org">Dart</a>. But there are always nagging concerns.<br /><br />My current solution builds a large registry of methods and arguments, organized by type. In this case, my pluggable adapters support a universal remote control for robots, so the registry is organized by robot class:<pre class=prettyprint><code>  static Map&lt;Type, Map> _registry = {<br />    Robot: {<br />      'forward':  [#move, [Direction.NORTH]],<br />      'backward': [#move, [Direction.SOUTH]],<br />      'left':     [#move, [Direction.WEST]],<br />      'right':    [#move, [Direction.EAST]]<br />    },<br />    Bot: {<br />      'forward':  [#goForward, []],<br />      'backward': [#goBackward, []],<br />      'left':     [#goLeft, []],<br />      'right':    [#goRight, []]<br />    }<br />  };</code></pre>I am a little concerned that this would grow past manageable state once the universal remote control supports more than a dozen robots or so. I also imagine that I will wind up adding conditionals for more than one type of robot in the various movement methods that I am adapting. Currently, they are a relatively clean mirror-based implementation:<pre class=prettyprint><code>  void moveForward() {<br />    var _ = _registry[_robot.runtimeType]['forward'];<br />    reflect(_robot).invoke(_[0], _[1]);<br />  }</code></pre>But, like I said, I can see that getting messy after a while.<br /><br />So instead, I try moving the adapted methods back into individual classes, one for each kind of robot. So the <code>Robot</code> adapter, which its <code>move()</code> method and direction arguments will look like:<pre class=prettyprint>class RobotAdapterToUbot implements Ubot {<br />  Robot _robot;<br />  RobotAdapterToUbot(this._robot);<br /><br />  String get xyLocation => _robot.location;<br /><br />  void moveForward()  { _robot.move(Direction.NORTH); }<br />  // other move methods here...<br />}</pre>Similarly, the adapter for <code>Bot</code>, which sports go-* methods for movements will look like:<pre class=prettyprint>class BotAdapterToUbot implements Ubot {<br />  Bot _bot;<br />  BotAdapterToUbot(this._bot);<br /><br />  String get xyLocation => "${_bot.x}, ${_bot.y}";<br /><br />  void moveForward()  { _bot.goForward(); }<br />  // other move methods here...<br />}</pre>I like this solution for cases in which there is variation in adaptee interfaces. For example, the <code>Bot</code> adapter supports a specialized <code>xyLocation</code> getter without having to perform a type check in a single adapter class. <br /><br />These adapters need to support the same interface, <code>Ubot</code> in this case, so that a delegating class can invoke the same method regardless of adaptee. The delegating class will provide the object that gets used in client code. To start with, I make that delegating class implement the same <code>Ubot</code> interface:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  Ubot _ubot;<br />  UniversalRemoteRobot(robot) {<br />    if (robot is Robot) _ubot = new RobotAdapterToUbot(robot);<br />    else if (robot is Bot) _ubot = new BotAdapterToUbot(robot);<br />  }<br /><br />  String get xyLocation => _ubot.xyLocation;<br /><br />  void moveForward()  { _ubot.moveForward(); }<br />  // other move methods here...<br />}</pre>This class sets the delegated adapter in the constructor based on the adaptee type. If <code>UniversalRemoteRobot</code> is constructed for a <code>Robot</code>, then the <code>RobotAdapterToUbot</code> is used. For a <code>Bot</code>, the delegated adapter is a <code>BotAdapterToUbot</code>. As long as new robot types are assigned adapters to the <code>Ubot</code> interface, it should be easy to add them—they just need to be delegated in the constructor.<br /><br />This is, I believe, the exact structure of the second pluggable adapter from the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>, though their example had the delegating class and the adapters supporting different interfaces. I may try something like that tomorrow. For now, it does not get much easier than having the <code>moveForward()</code> in the delegator invoke the same method in the delegated adapter.<br /><br />With that, my universal remote control works exactly the same for <code>Bot</code> and <code>Robot</code> instances:<pre class=prettyprint><code>  var r = new Bot();<br />  // This works exactly the same:<br />  // var r = new Robot();<br /><br />  var universalRobot = new UniversalRemoteRobot(r);<br />  print("Start moving the robot.");<br />  universalRobot<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward();<br />  print("The robot is now at: ${universalRobot.xyLocation}.");</code></pre>I still think last night's mirror-based approach has its place—especially in situations where I am assured of simple method invocations on the adaptees. But this delegated pluggable adapter approach feels like a better all-purpose solution.<br /><br />I will likely put that sentiment to the test. Tomorrow.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/2c87242d40969a9a3c2c">https://dartpad.dartlang.org/2c87242d40969a9a3c2c</a>.</i><br /><br /><br /><span style="color: #ccc">Day #52</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/what-heck-is-pluggable-adapter.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/hiyv8IFc1VE" height="1" width="1" alt=""/>
