---
title: 'Highlights from the TC52 meeting on Feb 24, 2015'
layout: post
published: '2015-03-12T03:45:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2015/03/highlights-from-tc52-meeting-on-feb-24.html'
author:
    name: 'Anders Thorhauge Sandholm'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/02074725733613485890'

---

At the last TC52 meeting on Feb 24, 2015, we discussed a number of additional language features for Dart - including async, tear-offs and null-aware operators.<br /><br /><h4>Update on async</h4>Gilad reported that the implementation had, unsurprisingly, exposed some subtleties in the spec that need to be considered. &nbsp;Some small adjustments in the language specification may follow from this. <br /><br />The virtual machine now implements the <span style="font-family: Courier New, Courier, monospace;">sync*</span> mechanism. &nbsp;The <span style="font-family: Courier New, Courier, monospace;">async*</span> mechanism is coming along. &nbsp;The dart2js implementation is complete with respect to the feature set, but it still needs to be debugged.<br /><br />The development of the async features has given rise to some useful insights. &nbsp;For instance, <span style="font-family: Courier New, Courier, monospace;">sync*</span> creates a synchronous generator, handling all the boilerplate for lazy iteration. &nbsp;However, the documentation of the library classes need an enhanced level of precision in order for this to work well with the language implementation and specification. &nbsp;The connection arises because the language specification says that <span style="font-family: Courier New, Courier, monospace;">Iterable</span> is implemented by <span style="font-family: Courier New, Courier, monospace;">sync*</span> methods. &nbsp;A conflict arises because <span style="font-family: Courier New, Courier, monospace;">Iterator</span> and other classes are allowed to cache some values such as the length, but this is not applicable for <span style="font-family: Courier New, Courier, monospace;">sync*</span> functions, and so the spec needs to restrict that. &nbsp;Consequently, the library documentation has been revised.<br /><br />An issue arises with “nested” empty iterables for <span style="font-family: Courier New, Courier, monospace;">yield*</span>. &nbsp;The idea is that <span style="font-family: Courier New, Courier, monospace;">yield*</span> is used to merge the output from a subiterator into the output of a given iterator. &nbsp;The wording in the language specification did not specify exactly what to do if that subiterator were empty, but the intention is that the subiterator should be processed normally and iteration should be continued from where it was before that subiterator was inserted. &nbsp;Adjustments to the specification will be made to clarify this.<br /><br />Several issues have come up in connection with async primitives:<br /><br />One issue is whether a construct on the form <span style="font-family: Courier New, Courier, monospace;">await (throw x)</span> can throw immediately, or “await always awaits” must prevail.<br /><br />It was noted that the return type of async uses flatten to avoid nested future types, and also that this should not create any difficulties for the type analysis.<br /><br />It is not obvious whether await-for loops should require a <span style="font-family: Courier New, Courier, monospace;">Stream</span> as the source of the awaited data, or they should allow for non-<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>&nbsp;objects with the required features. &nbsp;The question arises statically, where a type warning may or may not be given for a non-<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>. &nbsp;The question arises dynamically where a non-<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>&nbsp;may cause a runtime type error.<br /><br />Currently, the implementation performs such a check dynamically, even in production mode. &nbsp;We quickly agreed that it is problematic to have a dynamic check without an accompanying static warning, and also that any such dynamic check should probably only be performed in checked mode. &nbsp;It is not obvious how to resolve the overall issue, though.<br /><br />Erik pointed out that there is an underlying principle for this kind of decision: &nbsp;The language may allow for any object that responds to the requests made by the generated code, or it may enforce a nominal type such that only objects implementing&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>&nbsp;can be used. &nbsp;The rationale for the former approach&nbsp;(let us call it the “pragmatic” approach) is to run everything that can plausibly be given a semantics, no matter whether or not it is aligned with the associated type structure. &nbsp;The rationale for the latter approach (let us call it the “typeful” approach) is to support software correctness via explicit contractual obligations and expectations (as expressed by nominal types and supported by dartdoc comments etc.). &nbsp;It is possible to use both a pragmatic approach and a typeful approach, both statically and dynamically, so all four combinations must be considered.<br /><br />Dynamically, the pragmatic approach seems to be well aligned with many other decisions in the language design (it’s the “Darty” choice); but as Gilad mentioned, the code that actually implements the features which are used in this context is so subtle that ad-hoc alternative implementations to the ones in the standard library are very likely to be a steady source of stubborn bugs. &nbsp;For the few highly sophisticated developers who insist on writing their own implementations of “something that works as a stream” it should be easy to add an <span style="font-family: Courier New, Courier, monospace;">implements Stream</span> clause to their implementation, such that it works with the stricter, typeful approach.<br /><br />Statically, the pragmatic approach may be seen as a mistake, especially in the (presumably, vast majority of) cases where a non-<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>&nbsp;is used by accident rather than by intention. &nbsp;Conversely, if a static warning is given whenever a non-<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>&nbsp;is used in this context, it will cause frustration for the sophisticated developers who have carefully chosen to use a non-<span style="font-family: 'Courier New', Courier, monospace;">Stream</span>.<br /><br />In summary, we may have implicitly preferred the typeful approach statically and the pragmatic approach dynamically, but no explicit decision was made.<br /><br />Another matter is that a decision on an underlying principle in this case naturally affects the treatment of similar constructs, including the standard <span style="font-family: Courier New, Courier, monospace;">for</span> statement, where changes would obviously be much more difficult.<br /><br />A quite different issue is the decision about whether <span style="font-family: Courier New, Courier, monospace;">yield</span> in <span style="font-family: Courier New, Courier, monospace;">async*</span> may suspend. &nbsp;If a tight loop contains a <span style="font-family: Courier New, Courier, monospace;">yield</span>, it may produce a large number of data items which are not being received quickly enough. &nbsp;These situations create a need for more flexibility than that which is currently granted by the specification.<br /><br />Finally, Gilad mentioned that there are some missing static warnings in relation to <span style="font-family: Courier New, Courier, monospace;">async*</span><span style="font-family: Arial, Helvetica, sans-serif;">/</span><span style="font-family: Courier New, Courier, monospace;">sync*</span>, and a few other small issues.<br /><br /><h4>Update on “Dart Enhancement Proposal”</h4>We are ready to <a href="http://news.dartlang.org/2015/03/evolving-dart-language-with-dart.html">launch</a> the process, and several activities are already taking place. &nbsp;The process is github-based (see <a href="https://github.com/dart-lang/dart_enhancement_proposals">https://github.com/dart-lang/dart_enhancement_proposals</a>). &nbsp;The idea is that DEP authors file an issue in this github repository which includes a link to the proposal itself, which is stored as a separate github repository. &nbsp;The proposal repository may also contain other elements such as examples, implementation etc. &nbsp;The committee will go over incoming proposals according to the flowchart.<br /><br /><div class="separator" style="clear: both; text-align: center;"><a href="https://camo.githubusercontent.com/489139c68f01716334bb02e18894971c8f062d43/68747470733a2f2f646172742d6c616e672e6769746875622e696f2f646172745f656e68616e63656d656e745f70726f706f73616c732f466c6f7763686172742e737667" imageanchor="1" style="margin-left: 1em; margin-right: 1em;"><img border="0" height="300" src="https://camo.githubusercontent.com/489139c68f01716334bb02e18894971c8f062d43/68747470733a2f2f646172742d6c616e672e6769746875622e696f2f646172745f656e68616e63656d656e745f70726f706f73616c732f466c6f7763686172742e737667" width="400" /></a></div><br />TC52 has a royalty-free patent policy. Therefore, when a proposal is accepted by the DEP committee for processing by TC52, the original contributor of the DEP needs to sign the 'ECMA TC52 external contributor form'.<br /><br /><h4>Update on language extensions</h4>Two things are likely to be ready for the next version of the language specification: Generalized tear-offs, and null-aware operators.<br /><br />For generalized tear-offs, the coverage and discussions at the previous meeting are still valid. &nbsp;Now there is a complete proposal which is currently getting prepared for markdown presentation etc. &nbsp;It can be found at <a href="https://github.com/gbracha/generalizedTearOffs">https://github.com/gbracha/generalizedTearOffs</a>. &nbsp;It is done in a way that should be identical to the way that an external contributor could submit a proposal, such that it also serves as a test of the procedure and the associated documents.<br /><br />For null-aware operators, the information and discussions from the previous meeting are still valid. &nbsp;In this case it is a very simple proposal, just syntactic sugar, but it comes at a low cost.<br /><br />We briefly discussed a proposal from Erik to change the class <span style="font-family: Courier New, Courier, monospace;">Function</span> to take one type argument which would be the return type of the function represented by the given instance. &nbsp;This could enable the type <span style="font-family: Courier New, Courier, monospace;">Function&lt;T&gt;</span> to be more useful than the current type&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Function</span>, and it seems to be a benign change&nbsp;because all existing occurrences of&nbsp;<span style="font-family: 'Courier New', Courier, monospace;">Function</span>&nbsp;would be reinterpreted to mean&nbsp;<span style="font-family: Courier New, Courier, monospace;">Function&lt;dynamic&gt;</span>, which would have a backward compatible semantics.<br /><br />We did not discuss configurable imports, union types, generic methods, closure tear-offs, improvements to Type Promotion, nor subtyping for function types. &nbsp;In most cases this was because there is nothing new. &nbsp;For function type subtyping it was because we need to consider changes to the runtime semantics of Dart very, very carefully before we commit to them.<br /><br /><h4>Next meeting</h4>The next TC52 meeting is on March 19th, 2015. Main topics expected are finalization of tear-offs and null-aware operators.
