---
title: 'Factory Method Pattern (Take 2)'
layout: post
published: '2016-02-04T22:01:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/63iHoqVpq-0/factory-method-pattern-take-2.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Crazy what happens when you start writing a book, take a break for a year and a half, then come back. I had completely forgotten that I <a href="http://japhr.blogspot.com/search/label/factory%20method%20pattern">have already researched</a> the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory method pattern</a> for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. But research it I did.<br />  <br />Crazy too is that the approach I was taking to design patterns back then is very different to the one that I have been doing on this recent chain of posts. My focus recently has been to understand the consequences of patterns and different approaches to the pattern. Back then I spent the entire time benchmarking. I think it is especially funny that I included benchmarks for a mirror based solution—some things don't change.<br /><br />To gain a better understanding of the pattern, I start anew. For my initial example, I adapt the Java example maze from the Wikipedia page which itself was adapted from the C++ example in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>. <br /><br />The prime mover in this pattern is the "creator" class. In the maze example, the <code>MazeGame</code> is the creator:<pre class=prettyprint>abstract class MazeGame {<br />  List&lt;Room> rooms = [];<br /><br />  MazeGame() {<br />    Room room1 = _makeRoom();<br />    Room room2 = _makeRoom();<br />    room1.connect(room2);<br />    addRoom(room1);<br />    addRoom(room2);<br />  }<br /><br />  Room _makeRoom();<br /><br />  void addRoom(Room r) { rooms.add(r); }<br />}</pre>The constructor for this class creates 2 rooms, connects them, and adds the 2 rooms to the game. The <code>_makeRoom()</code> method is left abstract by virtue of having no method body. In other words, it is up to concrete implementations of this class to define how to make a room. This is the crux of the pattern. The <code>MazeGame</code> does not know the exact type of rooms with which it will be working, so it delegates that responsibility to subclasses.<br /><br />The first concrete creator might create nothing but magic rooms in a magic maze:<pre class=prettyprint>class MagicMazeGame extends MazeGame {<br />  @override<br />  Room _makeRoom() => new MagicRoom();<br />}</pre>A second concrete creator might create nothing but ordinary rooms for an early level in the game:<pre class=prettyprint>class OrdinaryMazeGame extends MazeGame {<br />  @override<br />  Room _makeRoom() => new OrdinaryRoom();<br />}</pre>More interestingly, there is nothing stopping me from generating any kind of room in a subclass:<pre class=prettyprint>class CrazyMazeGame extends MazeGame {<br />  @override<br />  Room _makeRoom() =><br />    new Random().nextBool() ? new OrdinaryRoom() : new MagicRoom();<br />}</pre>That is the pattern in a nutshell. The things being created are "products" in this pattern. Products in this pattern have no requirements other than there must be multiple types—otherwise there is no reason for a subclass to choose. The <code>Room</code> product that will work with that above code might look like:<pre class=prettyprint>// Product<br />class Room {<br />  List<Room> connectedRooms = [];<br /><br />  void connect(Room other) {<br />    connectedRooms.add(other);<br />  }<br />}<br /><br />// Concrete Product #1<br />class MagicRoom extends Room {}<br /><br />// Concrete Product #1<br />class OrdinaryRoom extends Room {}</pre>With that, client code can make use of the creator class:<pre class=prettyprint><code>  MazeGame crazyGame = new CrazyMazeGame();<br />  print(crazyGame);</code></pre>Which results in something like:<pre class=prettyprint>$ ./bin/maze.dart<br />CrazyMazeGame has 2 rooms: Instance of 'MagicRoom', Instance of 'OrdinaryRoom'<br /></pre>That will do for an introduction to the pattern. There are still implications to explore. I would also like to come up with a "modern web" example of the pattern. Way back when, I used this pattern in a <a href="http://documentcloud.github.com/backbone/">Backbone.js</a> knockoff, so I might do that again. It would be better, however, to come up with something a little more accessible to most programmers. Grist for forthcoming days.<br /><br /><i>Play with the code so far on DartPad: <a href="https://dartpad.dartlang.org/561d021f19910a79c194">https://dartpad.dartlang.org/561d021f19910a79c194</a>.</i><br /><br /><br /><span style="color: #ccc">Day #85</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/degenerate-abstractions.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/63iHoqVpq-0" height="1" width="1" alt=""/>
