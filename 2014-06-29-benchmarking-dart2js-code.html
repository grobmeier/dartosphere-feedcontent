---
title: 'Benchmarking dart2js Code'
layout: post
published: '2014-06-29T23:58:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/UyM1yJdsS3s/benchmarking-dart2js-code.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dart2js
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />I probably have enough initial research on the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> to get me started with <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. I do not necessarily need to have all the questions answered at this point, but I hope to have done enough to begin to understand what questions to ask. <br /><br />But before I move on from this creational design pattern to a (likely) behavioral pattern, I would like to try one more benchmark. Specifically, I would like to see how my mirror-based pattern fares in the <a href="https://github.com/dart-lang/benchmark_harness">benchmark_harness</a> sweepstakes.<br /><br />The classic Factory Method pattern done in <a href="http://dartlang.org">Dart</a> looks something like:<pre class=prettyprint>abstract class Creator {<br />  Product productMaker();<br />}<br /><br />abstract class Product {}<br /><br />class ConcreteCreator extends Creator {<br />  productMaker()=> new ConcreteProduct();<br />}<br /><br />class ConcreteProduct extends Product {}</pre>The intent here is to defer the specific instance of the product to be created to a subclass. Here, the <code>Creator</code> does not know which subclass of <code>Product</code> that a subclass would want, so it declares <code>productMake()</code> as an abstract method (in Dart, that means no method body). A subclass of the creator—here <code>ConcreateCreator</code>—then defines <code>producMaker()</code> to return something useful.<br /><br />For me, it is helpful to think of the creator class as the base collection class in a web MVC framework. In such a case, the framework collection has no way of know what kinds of models it will be holding, so it defers the creation of those objects to the subclass in actual application code.<br /><br />In contrast to this subclass approach, the mirror approach does not rely on the concrete creator to generate concrete products. Instead, it merely defines the class that will be used. The creator base class can use that to generate instances of the concrete product—thanks to the magic of mirrors:<pre class=prettyprint>import 'dart:mirrors';<br /><br />abstract class Creator {<br />  Type productClass;<br /><br />  Product productMaker() {<br />    return reflectClass(productClass).<br />      newInstance(const Symbol(''), []).<br />      reflectee;<br />  }<br />}<br /><br />abstract class Product {}<br /><br />class ConcreteCreator extends Creator {<br />  Type productClass = ConcreteProduct;<br />}<br /><br />class ConcreteProduct extends Product {}<br /></pre>Regardless of your feelings on the syntax of mirrors in the <code>Creator</code> base class, the remainder of the code in the pattern is mercifully terse. But how fast is it?<br /><br />Using the same approach to benchmarking that I have for the subclass approach (and last night's map-of-factories), my benchmark harness for my mirror approach looks like:<pre class=prettyprint>import 'package:benchmark_harness/benchmark_harness.dart';<br />import 'package:factory_method_code/mirrors.dart' as Mirrors;<br />// ...<br />class FactoryMethodMirrorBenchmark extends BenchmarkBase {<br />  const FactoryMethodMirrorBenchmark() : super("Factory Method — Mirrors");<br />  static void main() { new FactoryMethodMirrorBenchmark().report(); }<br />  void run() {<br />    new Mirrors.ConcreteCreator().productMaker();<br />  }<br />}</pre>As in the other Factory method approaches, I am measuring the time that it takes to create an instance of the concrete creator and invoke the <code>productMaker()</code>. I add this benchmark to the <code>main()</code> entry point in my code as:<pre class=prettyprint>import 'package:benchmark_harness/benchmark_harness.dart';<br />// ...<br />main() {<br />  FactoryMethodSubclassBenchmark.main();<br />  FactoryMethodMapBenchmark.main();<br /><b>  FactoryMethodMirrorBenchmark.main();</b><br />}<br /></pre>With that, I find:<pre class=prettyprint>$ dart tool/benchmark.dart                <br />Factory Method — Subclass(RunTime): 0.08687553108098094 us.<br />Factory Method — Map of Factories(RunTime): 1.7346083861377035 us.<br />Factory Method — Mirrors(RunTime): 12.741612833352447 us.</pre>Well, that was pretty much to be expected. The map-of-factories approach is 20 times slower than the traditional subclass approach and the mirror approach is 7 times slower than the map of factories. This does not rule out the slower two approaches as they can still be useful in certain situations—especially when it is unlikely that many concrete products will be instantiated. Still, it darned handy to be able to understand the tradeoffs when making these decisions.<br /><br />Except...<br /><br />Do I really understand the tradeoffs as the code is likely to be run? Since the primary usage of Dart code is compiled to JavaScript. I really ought to understand what the numbers are like when compiled. But how?<br /><br />As a first pass, I simply compile to JavaScript:<pre class=prettyprint>$ dart2js -o factory_method/tool/benchmark.dart.js factory_method/tool/benchmark.dart<br />Hint: 1 warning(s) suppressed in dart:_js_mirrors.<br />factory_method/tool/benchmark.dart:<br />Hint: 2391 methods retained for use by dart:mirrors out of 3411 total methods (70%).<br /><br />factory_method/tool/packages/factory_method_code/mirrors.dart:3:1:<br />Info: This import is not annotated with @MirrorsUsed, which may lead to unnecessarily large generated code.<br />Try adding '@MirrorsUsed(...)' as described at https://goo.gl/Akrrog.<br />import 'dart:mirrors';<br />^^^^^^^^^^^^^^^^^^^^^^</pre>Then I run the JavaScript with Node.js:<pre class=prettyprint>$ node factory_method/tool/benchmark.dart.js<br />Factory Method — Subclass(RunTime): 0.11682296216069209 us.<br />Factory Method — Map of Factories(RunTime): 4.732708458059921 us.<br />Factory Method — Mirrors(RunTime): 8.318221896887321 us.</pre>Interesting.<br /><br /><span style="color: #ccc">Day #107</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/06/benchmarking-apples-and-apples.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/UyM1yJdsS3s" height="1" width="1"/>
