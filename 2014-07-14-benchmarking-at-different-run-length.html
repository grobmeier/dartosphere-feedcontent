---
title: 'Benchmarking at Different Run Length'
layout: post
published: '2014-07-14T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/_Bt856IZlPs/benchmarking-at-different-run-length.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />It seems that my benchmarks may be hitting a garbage collection limit somewhere along the way. Or something.<br /><br />I continue to benchmark three (slightly) different implementations of the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> in <a href="http://dartlang.org">Dart</a>. The actual goal is reasonable assurance that I am suggesting the most performant version of each pattern in the forthcoming <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. Toward that end, I am seeking out as many considerations involved in benchmarking patterns as possible (and I have found a number). At this point, the actual numbers are not as important as the process. Still, the numbers do suggest considerations of which I need to be aware.<br /><br />The source code for this is located in <a href="https://github.com/eee-c/design-patterns-in-dart/tree/14dea8561ae52706e04b50f7e13904d96457946d/visitor">the public facing code repository</a> for the book.<br /><br />I have noted that the time-per-run seems dependent on the number of loops used in the benchmark. Normally, the benchmark_harness package will run as many loops as necessary to fill a 2 second run. In order to get the numbers to be  relatively stable between runs, I have been experimenting with increasing the number of loops in the benchmark. The results seem relatively consistent for limited numbers of loops in my benchmark code:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  // ...<br />  void run() {<br />    for (var i=0; i&lt;10; i++) {<br />      visitor.totalPrice = 0.0;<br />      nodes.accept(visitor);<br />    }<br />  }<br />}</pre>But, if I change the comparison from 10 to 1,000 to 100,000, then strange things happen to my numbers.<br /><br />To test this out in detail, I add command line options to my benchmarks (using the nice args Dart package), write a shell script to exercise them:<pre class=prettyprint>#!/bin/sh<br /><br />for X in 10 100 1000 10000 100000<br />do<br />    echo ''<br />    echo '=='<br />    echo "Loop size: $X"<br />    ./tool/benchmark.dart --loop-size=$X<br />    echo '--'<br />    ./tool/benchmark_single_dispatch_iteration.dart --loop-size=$X<br />    echo '--'<br />    ./tool/benchmark_visitor_traverse.dart --loop-size=$X<br />done<br /></pre>What I find is (numbers are microseconds for a single run):<br /><table border=1><tr style="border-bottom: 1px solid black"><th>Loop Size</th><th>Classic</th><th>Nodes Traverse (single dispatch)</th><th>Visitor Traverses</th></tr><tr><td>10</td><td>131.6</td><td>122.7</td><td>121.4</td></tr><tr><td>100</td><td>125.9</td><td>113.6</td><td>120.15</td></tr><tr><td>1000</td><td>123.8</td><td>122.8</td><td>120.65</td></tr><tr><td>10000</td><td>157.0</td><td>153.25</td><td>120.45</td></tr><tr><td>100000</td><td>158.05</td><td>154.65</td><td>121.05</td></tr></table><br />Or, in graphical form:<br /><br /><a href="http://1.bp.blogspot.com/-wgijZEHljXo/U8SzfFP-vcI/AAAAAAAAdOQ/iCQgLprw1TM/s1600/image+(2).png" imageanchor="1" ><img border="0" src="http://1.bp.blogspot.com/-wgijZEHljXo/U8SzfFP-vcI/AAAAAAAAdOQ/iCQgLprw1TM/s640/image+(2).png" /></a><br /><br />I am unsure if that is really garbage collection, but <i>something</i> reliably affects the two implementations in which the node structure is responsible for traversing itself. And somehow making the visitor responsible for traversing the node structure (even with double dispatching) is not affected.<br /><br />It is worth noting that the last two loop sizes push the benchmark run to and past the 2 second built-in lower limit of benchmark_harness. This may be a coincidence, especially since this does not seem to affect all three implementations. <br /><br /><br /><span style="color: #ccc">Day #122</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/long-vs-short-benchmarks-also-im-true.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/constant-constructors-and-benchmark.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/_Bt856IZlPs" height="1" width="1"/>
