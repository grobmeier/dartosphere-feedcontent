---
title: 'Simple Solutions to Asynchronous Polymer.dart Testing'
layout: post
published: '2015-03-19T22:17:00-07:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/RmK1NwtY_hA/simple-solutions-to-asynchronous.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - polymer
    - testing

---

<div class=top-chain-links></div><br />In the development release of <a href="http://dartlang.org">Dart</a> and <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a>, the simplest that I can write is still complex:<pre class=prettyprint><code>  group("&lt;hello-you>", (){<br />    setUp((){ /* Add element here... */ });<br /><br />    test("has a shadowRoot", (){<br />      Polymer.onReady.then(expectAsync((_) {<br />        expect(<br />          query('hello-you').shadowRoot,<br />          isNotNull<br />        );<br />      }));<br />    });<br />  });</code></pre>I add my custom element to the page and expect that, by virtue of Polymer goodness, it has a <a href="http://www.polymer-project.org/platform/shadow-dom.html">Shadow DOM</a>. This is not a completely useless test—verifying that Polymer is decorating an otherwise unknown HTML element tells me a lot. Still, it would be nice if there was not so much… asynchronous goop obfuscating an otherwise simple expectation.<br /><br />At its heart, this test is just:<pre class=prettyprint><code>        expect(<br />          query('hello-you').shadowRoot,<br />          isNotNull<br />        );</code></pre>But it is hard to see with everything else that needs to take place to ensure that the test runs and that it runs in <code>content_shell</code>, the dirt-simple headless testing solution for Dart.<br /><br />My last thought yesterday remains my first thought tonight. Why not simplify this with a Polymer-specific test matcher? This turns out to be the wrong idea, but bear with me...<br /><br />I start with a function that tries to wrap the expected asynchronous call like so:<pre class=prettyprint>polymerExpect(actual, matcher) {<br />  Polymer.onReady.then(expectAsync((_) {<br />    expect(actual, matcher);<br />  }));<br />}</pre>The main reason that this is wrong is that the <code>actual</code> value would have already been determined <i>before</i> this helper method is invoked. That is, if I try to rewrite my test with this helper, it would look like:<pre class=prettyprint><code>    test("has a shadowRoot", (){<br />      polymerExpect(<br />        query('hello-you').shadowRoot,<br />        isNotNull<br />      );<br />    });</code></pre>Since there is no wait-for-Polymer or any other delay in here, this code is evaluated immediately. I query for the <code>&lt;hello-you></code> element in the test page and send its <code>shadowRoot</code> into <code>polymerExpect()</code> without waiting for Polymer to be ready. In other words, I send <code>null</code> as the "actual" value—not what I want.<br /><br />While contemplating how to rewrite this so that evaluation of the <code>shadowRoot</code> can be deferred, I finally realize how I should have done this from the start—and it does not even require using the <a href="https://pub.dartlang.org/packages/scheduled_test">scheduled_test</a> asynchronous wrapper around unittest.<br /><br />If the <code>setup()</code> block in unittest returns a <code>Future</code>, the test runner will block until that <code>Future</code> completes. So all I have to do is return <code>Polymer.onReady</code> from <code>setup()</code>:<pre class=prettyprint><code>  group("&lt;hello-you>", (){<br />    setUp((){<br />      // Add the element here...<br /><b>      return Polymer.onReady;</b><br />    });<br /><br />    test("has a shadowRoot", (){<br />      expect(<br />        query('hello-you').shadowRoot,<br />        isNotNull<br />      );<br />    });<br />  });</code></pre>With that, my test is as simple (and readable) as possible and it runs in <a href="http://www.dartlang.org/dartium/">Dartium</a> and <code>content_shell</code> alike.<br /><br />I feel pretty dumb for not recognizing that before. As penance for my stupidity, I write two new tests for this element. It is from an example very early in <a href="http://patternsinpolymer.com/">Patterns in Polymer</a>, so it does not have ID attributes to make it easier to find elements within the shadow DOM. That aside, the tests are fairly straight forward:<pre class=prettyprint><code>    test("name updates the template", (){<br />      _el.your_name = "Bob";<br />      _el.async(expectAsync((_){<br />        var h2 = _el.shadowRoot.querySelector('h2');<br />        expect(h2.text, 'Hello Bob');<br />      }));<br />    });<br /><br />    test("color changes", (){<br />      var h2 = _el.shadowRoot.querySelector('h2');<br />      expect(h2.style.cssText, '');<br /><br />      _el.shadowRoot.querySelector('input[type=submit]').click();<br />      _el.async(expectAsync((_){<br />        expect(h2.style.cssText, startsWith('color'));<br />      }));<br />    });</code></pre>The <code>&lt;hello-you></code> element has the <code>your_name</code> property bound to the <code>&lt;h2></code> of its template. The first test verifies that the <code>&lt;h2></code> contains “Bob” if the <code>your_name</code> property is set to "Bob". The second verifies that the <code>&lt;h2></code> starts life without a color style, but is randomly assigned a color when the button in <code>&lt;hello-you></code> is clicked.<br /><br />Both tests rely on my <a href="http://japhr.blogspot.com/2014/04/bare-minimum-polymerdart-testing.html">old friend async()</a>, which mostly ensures that the Polymer UI and computed properties have been updated. With those tests added, I have three tests passing:<pre class=prettprint>PASS<br />1       PASS<br />Expectation: &lt;hello-you> has a shadowRoot .<br /><br />2       PASS<br />Expectation: &lt;hello-you> name updates the template .<br /><br />3       PASS<br />Expectation: &lt;hello-you> color changes .<br /><br />All 3 tests passed</pre>The added tests are nice (and verify that multiple tests work), but the real win is removing the unnecessary asynchronous code from my tests. Many Polymer tests involve some form of asynchronous code. Best not to start with things cluttered.<br /><br /><br /><span style="color: #ccc">Day #3</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/03/proper-async-testing-of-polymerdart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/03/bleeding-edge-angulardart-and.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/RmK1NwtY_hA" height="1" width="1" alt=""/>
