---
title: 'Wacky Successor Chain of Responsibility'
layout: post
published: '2016-02-13T22:14:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/eQ1qmY8Jfu4/wacky-successor-chain-of-responsibility.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - 'chain of responsibility pattern'
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Let's talk about the successor chain in the <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">chain of responsibility pattern</a>. In the purchasing power example that I have been using so far, the handler maintains responsibility for defining new links via a <code>successor</code> setter method:<pre class=prettyprint>abstract class PurchasePower {<br />  PurchasePower _successor;<br />  void set successor(PurchasePower successor) {<br />    _successor = successor;<br />  }<br />  // ...<br />}</pre>This required client code to establish the links between instances:<pre class=prettyprint><code>  var manager = new ManagerPurchasePower();<br />  var director = new DirectorPurchasePower();<br />  var vp = new VicePresidentPurchasePower();<br />  var president = new PresidentPurchasePower();<br /><br />  manager.successor = director;<br />  director.successor = vp;<br />  vp.successor = president;</code></pre>I am OK with the approach here, but I am not a fan of the name <code>successor</code>. Really, in general, I am not a fan of using pattern names or participants in patterns—not even in examples. I much prefer domain specific names that are optionally annotated with pattern names.<br /><br />In the case of organization purchase power, the successor would be better expressed as reports to / direct reports relationships:<pre class=prettyprint>abstract class PurchasePower {<br />  // Successor in the chain of responsibility<br />  PurchasePower _reportsTo;<br />  void set reportsTo(PurchasePower reportsTo) {<br />    _reportsTo = reportsTo;<br />  }<br />  // ...<br />}</pre>Now when I look at the chain of responsibility being established, there is less mental translation between design pattern naming and the current domain:<pre class=prettyprint><code>  var manager = new ManagerPurchasePower();<br />  var director = new DirectorPurchasePower();<br />  var vp = new VicePresidentPurchasePower();<br />  var president = new PresidentPurchasePower();<br /><br />  manager.reportsTo = director;<br />  director.reportsTo = vp;<br />  vp.reportsTo = president;</code></pre>Everything about this feels more comfortable. Maybe there are people out there that look at a problem, tap their chin while considering things until finally shouting, "a-ha! the chain of responsibility will work here!" For me, the relationship comes first, after which I might come up with an approach to decide which member in the relationship needs to handle things. Then, if I am really paying attention, I might even think "ooh, that's the chain of responsibility!" <br /><br />Hopefully if I keep plugging away at these patterns, I will get to the point at which they are more recognizable in situations like this. But I seriously doubt I will ever get to the chin-tapping state. And I am unsure that I would ever want to. I think the code is more maintainable with the domain names instead of the pattern names (and really, no one ever liked classes named abstract factory factory). <br /><br />But I digress.<br /><br />Another possible approach to the chain of responsibility is to exploit either the data structure in use or the domain. There is not really a data structure in play with this example, but the domain certainly implies a hierarchy—a manager will always report to a director, who will always report to a VP, etc. I can exploit that to eliminate the explicit assignment of <code>reportsTo</code> properties.<br /><br />I start with a static mapping of runtime types pointing to the last used instance of that type:<pre class=prettyprint>abstract class PurchasePower {<br />  static Map&lt;Type, PurchasePower> _instances = {};<br />  PurchasePower() {<br />    _instances[this.runtimeType] = this;<br />  }<br />  // ...<br />}</pre>Any subclass of the <code>PurchasePower</code> handler will invoke the constructor here, caching the last instance of the give type. That is, when a <code>ManagerPurchasePower</code> instance is created, this superclass constructor will be called storing the instance index by the type.<br /><br />The <code>DirectorPurchasePower</code> constructor can then make use of this, finding the most recent <code>ManagerPurchasePower</code> and assigning this instance as the <code>reportsTo</code>:<pre class=prettyprint>class DirectorPurchasePower extends PurchasePower {<br />  // ...<br />  DirectorPurchasePower() : super() {<br />    _directReport(ManagerPurchasePower);<br />  }<br />  // ...<br />}</pre>After setting the default successor chain like this in the VP and President purchase power classes, I no longer have to explicitly specify the chain of responsibility. I simply create the various instances, start with the lowest and see which claims responsibility along the way:<pre class=prettyprint><code>  var manager   = new ManagerPurchasePower();<br />  var director  = new DirectorPurchasePower();<br />  var vp        = new VicePresidentPurchasePower();<br />  var president = new PresidentPurchasePower();<br /><br />  var req = new PurchaseRequest(25*1000, "General Purpose Usage");<br />  manager.processRequest(req);</code></pre>This particular recent instance storage and lookup implementation feels a little forced. Explicitly setting the chain was not too horrible and this approach is non-trivial. Still, it was good to explore the successor chain in a little more depth.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/ec62b7918eebf6e7e130">https://dartpad.dartlang.org/ec62b7918eebf6e7e130</a>.</i><br /><br /><br /><span style="color: #ccc">Day #94</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/chain-of-responsibility-but-with.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/eQ1qmY8Jfu4" height="1" width="1" alt=""/>
