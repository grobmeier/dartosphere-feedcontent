---
title: 'Simple Commands in a Complex Command System'
layout: post
published: '2015-12-18T22:41:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/DfSv5WC4Z4c/simple-commands-in-complex-command.html'
author:
    name: Anonymous
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/00135361916531185929'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I suffer an abundance of commands. I am trying to keep my exploration of the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> simple as I prepare for the corresponding entry in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. My simple code has 10 commands:<pre class=prettyprint><code>  // Concrete command instances<br />  var moveNorth = new MoveNorthCommand(robot),<br />    moveSouth = new MoveSouthCommand(robot),<br />    moveEast = new MoveEastCommand(robot),<br />    moveWest = new MoveWestCommand(robot),<br />    danceHappy = new DanceHappyCommand(robot),<br />    startRecording = new StartRecordingCommand(camera),<br />    stopRecording = new StopRecordingCommand(camera),<br />    undo = new UndoCommand(history),<br />    redo = new RedoCommand(history);</code></pre>I can likely eliminate several of those for a terser discussion, but this still begs the question, what the heck would I do with this in live code? <br /><br />The problems is not so much the 10 instances of command objects. If there are 10 buttons in the UI (which is a problem for another book), then I need 10 commands. The trouble here is that I had to manually declare all 10 of those commands, each with varying degrees of complexity:<pre class=prettyprint>class MoveNorthCommand implements Command {<br />  Robot robot;<br />  MoveNorthCommand(this.robot);<br />  void call() { robot.move(Direction.NORTH); }<br />  void undo() { robot.move(Direction.SOUTH); }<br />}</pre>The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> suggests the use of <a href="https://en.wikipedia.org/wiki/Template_(C%2B%2B)#Class_templates">C++ template classes</a> to overcome class overload. As long as a command is simple enough (receiver + action, no undo), then C++ templates seems a nice solution. One template declaration can generate any number of simple command types. <br /><br />There are no template classes in <a href="http://dartlang.org">Dart</a>. There is no way to dynamically generate a class at run or compile time. Either the class is hard-coded before compiling or it does not exist. So what are my options if I want to avoid command class explosion?<br /><br />One option comes from the GoF themselves. They characterize commands as an object-oriented replacement for commands. Callbacks cannot support undo, but I only need a solution for simple commands, like making my robot say a word or phrase:<pre class=prettyprint><code>  var btnSayHi = new Button("Hi!", (){ robot.say("Hi!"); });<br />  var btnScare = new Button("Scare Robot", (){ robot.say("Ahhhhh!"); });<br /><br />  btnSayHi.press();<br />  btnScare.press();</code></pre>I have cleverly been naming my command execution method <code>call()</code>, which is what the <code>Button</code>'s <code>press()</code> method invokes:<pre class=prettyprint>class Button {<br />  String name;<br />  Command command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />  }<br />}</pre>Functions in Dart respond to <code>call()</code> by invoking the function. So this quick and dirty solution works:<pre class=prettyprint>$ ./bin/play_robot.dart<br />[pressed] Hi!<br />Hi!<br />[pressed] Scare Robot<br />Ahhhhh!</pre>It works, but there are at least two problems. First is that the <code>command</code> property in <code>Button</code> is declared as a <code>Command</code> type. Supplying a function instead results in analyzer errors:<pre class=prettyprint>$ dartanalyzer bin/play_robot.dart lib/robot.dart<br />Analyzing [bin/play_robot.dart, lib/robot.dart]...<br />[warning] The argument type '() → dynamic' cannot be <br />          assigned to the parameter type 'Command' <br />(/home/chris/repos/design-patterns-in-dart/command/bin/play_robot.dart, line 34, col 36)<br />[warning] The argument type '() → dynamic' cannot be<br />          assigned to the parameter type 'Command' <br />(/home/chris/repos/design-patterns-in-dart/command/bin/play_robot.dart, line 35, col 44)<br />2 warnings found.</pre>I can get around this by declaring that the <code>command</code> property must be a <code>Function</code>:<pre class=prettyprint>class Button {<br />  String name;<br />  Function command;<br />  Button(this.name, this.command);<br />  // ...<br />}</pre>And then declaring that the <code>Command</code> interface implements <code>Function</code>:<pre class=prettyprint>abstract class Command implements Function {<br />  void call();<br />}</pre>That give me no type analysis errors:<pre class=prettyprint>$ dartanalyzer bin/play_robot.dart lib/robot.dart<br />Analyzing [bin/play_robot.dart, lib/robot.dart]...<br />No issues found</pre>And my robot can still perform simple speech commands:<pre class=prettyprint>$ ./bin/play_robot.dart<br />[pressed] Hi!<br />Hi!<br />[pressed] Scare Robot<br />Ahhhhh!</pre>The other problem with this approach is undo history. I specifically do not want to store these simple commands in my history since they do not support undo. I have yet to ignore these so they get added all the same. If I attempt an undo after making the robot speak:<pre class=prettyprint><code>  // ...<br />  btnUp.press();<br /><br />  btnSayHi.press();<br />  btnScare.press();<br /><br />  btnUndo.press();<br />  // ...</code></pre>Then I get an exception from calling <code>undo()</code> on my callback command:<pre class=prettyprint>// ...<br />[pressed] Up<br />  I am moving Direction.NORTH<br />[pressed] Hi!<br />Hi!<br />[pressed] Scare Robot<br />Ahhhhh!<br />[pressed] Undo<br />Undoing Closure: () => dynamic<br />Unhandled exception:<br />Closure call with mismatched arguments: function 'undo'</pre>I am adding to history in the button <code>press()</code> method:<pre class=prettyprint>class Button {<br />  String name;<br />  Function command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />    History.add(command);<br />  }<br />}</pre>I can add a guard clause to the <code>History.add()</code> static method to prevent adding callback commands to the undo history. This is a little tricky for functions, however. First, I cannot check to see if the command is a <code>Function</code> because all my commands are now functions:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(Function c) {<br />    // Nothing gets added now :(<br />    if (c is Function) return;<br /><br />    // Add to singleton history instance<br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>Comparing the <code>runtimeType</code> is not much easier. The <code>runtimeType</code> of an anonymous function is not, in fact, <code>Function</code>:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(Function c) {<br />    // Matches nothing, callback functions still get added :(<br />    if (c.runtimeType == Function) return;<br /><br />    // Add to singleton history instance<br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>Oddly, even if I compare the <code>runtimeType</code> to the <code>runtimeType</code> of a actual function, I still do not get a proper guard clause:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(Function c) {<br />    // Not equal for some reason, all callbacks still added to undo history :(<br />    if (c.runtimeType == (){}.runtimeType) return;<br /><br />    // Add to singleton history instance<br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>What does work is converting the <code>runtimeType</code> to a <code>String</code> for comparison:<pre class=prettyprint>class History {<br />  // ...<br />  static void add(Function c) {<br />    // Both are '() => dynamic'<br />    if (c.runtimeType.toString() == (){}.runtimeType.toString()) return;<br /><br />    // Add to singleton history instance<br />    _h._undoCommands.add(c);<br />  }<br />  // ...<br />}</pre>With that, I have a relatively complex command pattern implementation that supports undo (and redo) history, yet still allows for very simple command definitions via callbacks. In the end it did not require too much effort. I may not have a full-blown class like a template might have produced, but this still seems an acceptable approach.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/c9f076a1c2df94fc3243">https://dartpad.dartlang.org/c9f076a1c2df94fc3243</a>.</i><br /><br /><br /><span style="color: #ccc">Day #37</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/a-happy-dance-for-macro-commands.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2015/12/generic-commands.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/DfSv5WC4Z4c" height="1" width="1" alt=""/>
