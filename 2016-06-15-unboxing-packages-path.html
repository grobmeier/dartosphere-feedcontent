---
title: 'Unboxing Packages: path'
layout: post
published: '2016-06-15T13:12:00-07:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/06/unboxing-packages-path.html'
author:
    name: 'Kevin Moore'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/08411979841477351623'
tags:
    - 'Unboxing Packages'

---

<p>I want to do something a little different with my blog post this week. When I’ve written about packages in the past, I’ve mostly done a high-level overview of their APIs and how they fit into the Dart ecosystem as a whole. But <a href="https://pub.dartlang.org/packages/path"><code>path</code></a> is one of the very oldest packages in the ecosystem, and any Dart user who’s written any server-side or command-line apps is probably already familiar with the API.</p> <p>So instead of a high-level overview, I want to do a deep dive. I want to talk about why we made the design decisions we made when writing <code>path</code>, and how we implemented our design effectively and efficiently. This post will be as much about <em>how</em> the package was constructed as it is about what the final product looks like.</p> <h2 id="initial-design">Initial Design</h2> <p>It first became clear that Dart needed a solid solution for path manipulation when <a href="https://github.com/munificent">Bob Nystrom</a> and I first started working on <a href="https://www.dartlang.org/tools/pub/">pub</a>. Paths may seem simple on their face, but there’s a lot of hidden complexity when you need to make them work with all the edge case formats that can crop up across all the operating systems we support.</p> <p>This became our first design constraint: <strong>make something that handles all the edge-cases</strong>. This is less obvious than it sounds: a lot of times, good design involves sacrificing some edge-case behavior to make the common case better, or even just simpler to implement. But we knew that <code>path</code> would be widely-used across the ecosystem, and we wanted users to be totally confident in it. If an application had to sanitize its paths before handing them off to us, we weren’t doing our job.</p> <p>Another important early decision was to <strong>make the core API use top-level methods</strong>. We often look at other languages’ APIs for inspiration, but they were split on this point. Node uses <a href="https://nodejs.org/api/path.html">top-level functions</a>, whereas Java uses <a href="https://nodejs.org/api/path.html">instance methods on a <code>Path</code> class</a>. Ruby uses <a href="http://ruby-doc.org/core-2.2.0/File.html#method-c-basename">static methods</a> for simple manipulation and <a href="http://ruby-doc.org/stdlib-2.2.0/libdoc/pathname/rdoc/Pathname.html">a <code>Pathname</code> class</a> for more complex ones. This didn’t provide clear guidance.</p> <p>We decided to rely on a rule of thumb: <em>only create a class when it’s the canonical representation of its data type</em>¹. There were already a bunch of APIs, both in the core and in external code, that logically took paths and accepted only strings, not our hypothetical <code>Path</code> objects. Certainly everywhere the end user supplied a path, that path would be made available to the program as a string.</p> <p>So we decided to go with the flow of the existing APIs and continue representing paths as strings. All the path manipulation APIs now take strings and return strings, and the world is simpler for it.</p> <p>We chose functions for the package based on a combination of our own needs and APIs that were common among other languages’ path manipulation suites. Some of them, like <a href="https://www.dartdocs.org/documentation/path/latest/path/join.html"><code>join()</code></a> and <a href="https://www.dartdocs.org/documentation/path/latest/path/relative.html"><code>relative()</code></a>, were pretty obvious. Others like <a href="https://www.dartdocs.org/documentation/path/latest/path/rootPrefix.html"><code>rootPrefix()</code></a> only became apparent because they filled holes in actual code. And a few, like <a href="https://www.dartdocs.org/documentation/path/latest/path/prettyUri.html"><code>prettyUri()</code></a>, only got added well after the package was released.</p>   <h2 id="the-quest-for-correctness">The Quest for Correctness</h2> <p>We wanted to make our users confident in the correctness of <code>path</code>’s logic, which meant we had to be confident ourselves first. To do this, we wrote tests. Lots and lots of tests. Today, the package has 2.5 times more lines of test code than implementation code, and that’s how we like it.</p> <p>Writing tests isn’t trivial, though. We had to be careful to include all the cases that came up in practice. This meant that, for every function where they were relevant, we tested combinations of:</p> <ul><li>Directory paths that did or did not end in separators.</li><li>Paths with zero, one, or two extensions.</li><li>Paths with multiple separators in a row.</li><li>Paths containing, or entirely composed of, the directory traversal operators <code>.</code> and <code>..</code>.</li><li>Absolute and relative paths.</li><li>Different formats of the current working directory.</li></ul> <p>We wrote those tests first for the Posix style of path, which are used by OS X and Linux. Then we ported them over to Windows paths², and added even more cases:</p> <ul><li>Windows supports both <code>/</code> and <code>\</code> as separators, so we tested both and their combinations.</li><li>Not only does Windows support <code>C:\</code>-style path roots, it supports <code>\\server\share\</code>-style UNC paths as well.</li><li>You can also start a path with <code>\</code> in Windows to indicate that it’s relative to the current working directory’s roots.</li></ul> <p>Determining the proper behavior for all of these involved looking up specifications online, manually testing path behavior on the command line, and a healthy amount of discussion about exactly the right way to handle edge-cases. These discussions led to our next round of design decisions.</p> <p>Not all paths are valid. Sometimes they run afoul of an operating system’s rules for valid characters, and sometimes they just don’t make sense at all—consider the path <code>/..</code>, for example, or just an empty string. I initially advocated for throwing errors in these cases since in general failing fast is good, but we discussed options and Bob convinced me that <strong>path operations should never fail</strong>³.</p> <p>While failing fast can make errors easier to track down, it also means that a defensive programmer has to be aware of the potential for failure anywhere it could occur. Path operations are frequently used in small utility methods that aren’t expected to fail, and most of the time their output is ultimately passed to IO operations which already need error handling.</p> <p>So instead of throwing an error, the path operations just do the best they can on meaningless input. For most operations, <code>/..</code> is considered the same as <code>/</code> and the empty path is considered the same as <code>.</code>, but we don’t work too hard to adhere to these definitions if it would get in the way of efficiently processing valid paths.</p> <p>We also had to figure out what to do with paths that contained irrelevant characters, like <code>foo//bar</code> or <code>foo/./bar</code>, both of which are semantically identical to <code>foo/bar</code>. We ended up deciding to <strong>preserve the existing format as much as possible</strong>. The user would be able to explicitly call <a href="https://www.dartdocs.org/documentation/path/latest/path/normalize.html"><code>normalize()</code></a> if they wanted clean paths, but otherwise they’d get something like what they passed in.</p> <p>This decision made it easier to interoperate with other software that did, for whatever reason, care about the exact format of a path. For example, code using less-robust path manipulation logic might not be able to tell that <code>foo/baz/qux</code> was within <code>foo/bar/../baz</code>, so it’s useful for <code>p.join("foo/bar/../baz", "qux")</code> to return <code>"foo/bar/../baz/qux"</code>.</p>   <h2 id="platforms-and-customization">Platforms and Customization</h2> <p>Paths are unusual in that their semantics are deeply platform-specific, but following those semantics mostly doesn’t actually require running the code on the platform in question. We wanted to take advantage of this to allow users to do path manipulations for platforms they weren’t using, but we also wanted to make the easy default use the current platform. This called for more design.</p> <p>We came up with the idea of a <a href="https://www.dartdocs.org/documentation/path/latest/path/Context/Context.html"><code>Context</code></a> object, which would take a style of path (Posix, Windows, or eventually URI) and the only OS-specific piece of data path manipulation used—the current directory path. <code>Context</code> had a set of methods that exactly mirrored the top-level functions in <code>path</code>. In fact, <code>path</code>’s functions just forward to a context!</p> <p>We used contexts heavily in our own tests. They allowed us to run Windows path tests on Linux, for example, and to test operations like <code>relative()</code> without having to make any assumptions about the current directory.</p> <p>While adding contexts, we also made a design decision that turned out to be a mistake in retrospect. We’d defined a <a href="https://www.dartdocs.org/documentation/path/latest/path/Style-class.html"><code>Style</code></a> enum for determining which platform style a context should use, which would have been fine if we hadn’t decided to make public the methods <code>Context</code> called on the style.</p> <p>We had a vague notion that this would allow third-party packages to define custom styles, but no one ever did. Even if they’d wanted to, different path styles are so idiosynctatic that they probably couldn’t have encoded all the custom logic in the methods we provided. So instead we had a bunch of public API surface that was tightly coupled to the internal implementation of path manipulation.</p> <p>Eventually the implementation needed tweaking in a way that affected the <code>Style</code> methods. We couldn’t change those methods, so instead we deprecated them and added an internal implementation of <code>Style</code> where we could add new methods privately. The lesson here is <strong>sometimes maximal extensibility isn’t worth the pain</strong>.</p>   <h2 id="making-it-fast">Making it Fast</h2> <p>When we first implemented <code>path</code>, we were primarily concerned with correctness and not speed. Our philosophy was (and is) to avoid optimizing packages until we have a clear idea of what parts are slowest and used most heavily. If the package started out correct and well-tested, we could be sure that any performance improvements later on preserved the necessary behavior.</p> <p>But eventually the time came to make those changes. Users were doing path manipulations in performance-critical loops, and that meant it had to be fast. We set up a benchmark so we could track our progress, and used <a href="https://dart-lang.github.io/observatory/">Observatory</a> to see exactly what parts of our code were taking the most time. Then we called in <a href="https://github.com/skabet">Anders Johnsen</a>, one of our resident performance experts who’s since moved on from Google, to see what he could do.</p> <p>It turned out he could do a lot! Not only did our code get faster, we learned quite a bit about strategies for keeping it fast.</p> <p>The first change was to <strong>avoid parsing the whole path</strong>. Our original code heavily used an internal <code>ParsedPath</code> class that eagerly parsed the entire path and exposed its components as fields. We still use this class for particularly complex functions, but for anything simple and performance-critical, we now deal with the string directly. This removes a lot of extra unnecessary work and allocations.</p> <p>The second change was to <strong>stop using regular expressions</strong>. At the time, Dart’s regular expression engine was very slow. It’s since been dramatically improved, but explicit string operations still tend to involve a lot less overhead. We had been using regexps for very simple operations anyway, so switching away from them ended up being pretty straightforward.</p> <p>Finally, we had to <strong>short-circuit early when possible</strong>. A lot of path operations were very complex in the worst case—they required a lot of logic and maybe even iteration over the whole path. But the worst case didn’t actually come up all that often, and it turned out to be pretty easy to detect when it didn’t. For example, Windows paths can have a lot of different roots, which makes finding the root difficult. But if the path starts with <code>/</code>, then it’s guaranteed to be a root-relative path, so the root is <code>"/"</code>. These sorts of checks may seem nitty, but they helped a lot.</p>   <h2 id="coming-up-for-air">Coming Up For Air</h2> <p>I tried something new today, and I’m curious what you thought. Leave me feedback in the comments if you’d like to see more deep dives, or if you prefer my previous articles that gave a high-level overview of package APIs. For my part, I like writing both of them, so I’d be happy to continue doing a mix in the future.</p> <p>Join me again in two weeks when I cover a very generalized package that’s only used in one place so far.</p> <p><em><a href="https://twitter.com/nex3">Natalie</a> is still doing the writing here. I’m just hitting publish. – Kevin</em></p> <hr> <p>1: If it were up to me, the <a href="https://api.dartlang.org/stable/latest/dart-io/File-class.html"><code>File</code></a> class’s methods would be top-level functions as well.</p> <p>2: We also support <a href="https://www.dartdocs.org/documentation/path/latest/path/Style/url.html"><code>url</code></a> paths, but these were added later on.</p> <p>3: There’s one exception to this rule: <code>path</code> calls <a href="https://api.dartlang.org/stable/latest/dart-core/Uri/base.html"><code>Uri.base</code></a> to figure out the working directory for operations like <a href="https://www.dartdocs.org/documentation/path/latest/path/relative.html"><code>relative()</code></a>, which is an IO operation and so could <em>theoretically</em> fail. In pratice, though, it basically never does.</p>
