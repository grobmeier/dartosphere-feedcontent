---
title: 'Waiting for Polymer Assets'
layout: post
published: '2014-05-29T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/fbh36LsSi90/waiting-for-polymer-assets.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - polymer

---

<div class=top-chain-links></div><br />I really should have done this before I went through all the SVG craziness, but it would be super helpful if I could specify toppings via attribute of my <code>&lt;x-pizza></code> Polymer element, which enables building pizzas via web component:<br /><br /><a href="http://2.bp.blogspot.com/-1aUu2oVm2jg/U4efAajI7aI/AAAAAAAAZ7U/RO6IGDJ7G6M/s1600/03-x_pizza_with_svg_images.png" imageanchor="1" ><img border="0" src="http://2.bp.blogspot.com/-1aUu2oVm2jg/U4efAajI7aI/AAAAAAAAZ7U/RO6IGDJ7G6M/s400/03-x_pizza_with_svg_images.png" /></a><br /><br />That is, I would like to specify that a two topping special starts as something akin to:<pre class=prettyprint><code>  &lt;body><br />    &lt;div class="container"><br />      &lt;h1>Ye Olde Dart Pizza Shoppe&lt;/h1><br /><b>      &lt;x-pizza toppings="sausage,pepperoni">&lt;/x-pizza></b><br />    &lt;/div><br />  &lt;/body></code></pre>I expect that it will be fairly easy to push this information into my Polymer element, complicated only slightly by the model-driven view approach taken inside the element. Slightly more difficult is reflecting internal changes back on this attribute. <br /><br />Anyhow, getting started, I try a simple <code>split()</code> to break the attribute into a list of attributes that can be added to the model. I do this in the <code>created()</code> life-cycle method of the Polymer class:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  //...<br />  @published String toppings = '';<br />  XPizza.created(): super.created() {<br />    model = new Pizza();<br /><br /><b>    toppings.<br />      split(new RegExp(r'\s*,\s*')).<br />      forEach((t){ model.wholeToppings.add(t); });</b><br />  }<br />  //...<br />}</pre>When I load the page, however, I get all manner of errors related to adding empty SVG content. It turns out that my <code>&lt;polymer-ajax></code> <a href="http://japhr.blogspot.com/2014/05/polymer-elements-loading-svg-in-polymer.html">strategy for loading SVG assets</a> finally bit me. By starting the drawing off with toppings, I am no longer giving my assets time to load.<br /><br />Async Dart to the rescue. I add an <code>svgLoaded</code> completed in the <code>created()</code> method:<pre class=prettyprint>Completer svgLoaded;<br />  XPizza.created(): super.created() {<br />    // ...<br /><b>    svgLoaded = new Completer();</b><br />  }</code></pre>The <code>_updateGraphic()</code> method now needs to honor that completer. If the completer is still in progress, then updating the graphics needs to wait for the assets to fully load and, only then, actually update the graphic:<pre class=prettyprint><code>  _updateGraphic() {<br /><b>    if (!svgLoaded.isCompleted) {<br />      svgLoaded.future.then((_) => _updateGraphic());<br />      return;<br />    }</b><br /><br />    svg = new SvgElement.svg(svgContent['pizza.svg']);<br />    $['pizza']<br />      ..children.clear()<br />      ..append(svg);<br /><br />    _addWholeToppings();<br />    _addFirstHalfToppings();<br />    _addSecondHalfToppings();<br />  }</code></pre>Once <code>svgLoaded</code> has completed for the first time, the <code>svgLoaded.isComplete</code> check will always return true. In other words, <code>_updateGraphic()</code> will wait at first but once the assets have loaded, the check for <code>svgLoaded.isComplete</code> will be ignored for the remainder of the element's lifetime.<br /><br />Deciding when the assets are fully loaded will be the responsibility of the recently created <code>responseReceived()</code> method:<pre class=prettyprint><code>  responseReceived(e, detail, node){<br />    svgContent[node.id] = detail['response'];<br />    if (node.id == 'pizza.svg') _updateGraphic();<br />  }</code></pre>This method accepts what the <code>&lt;polymer-ajax></code> method supplies when invoked from an <code>on-polymer-response</code> callback. Each of the assets in the <code>&lt;x-pizza></code> template call this method:<pre class=prettyprint>&lt;polymer-element name="x-pizza"><br />  &lt;template><br />    &lt;polymer-ajax<br />       id="pizza.svg"<br />       url="/packages/svg_example/images/pizza.svg"<br />       <b>on-polymer-response="{{responseReceived}}"</b>>&lt;/polymer-ajax><br />    &lt;polymer-ajax<br />       id="pepperoni.svg"<br />       url="/packages/svg_example/images/pepperoni.svg"<br />       <b>on-polymer-response="{{responseReceived}}"</b>>&lt;/polymer-ajax><br />    &lt;polymer-ajax<br />       id="sausage.svg"<br />       url="/packages/svg_example/images/sausage.svg"<br />       <b>on-polymer-response="{{responseReceived}}"</b>>&lt;/polymer-ajax><br />    &lt;polymer-ajax<br />       id="green_pepper.svg"<br />       url="/packages/svg_example/images/green_pepper.svg"<br />       <b>on-polymer-response="{{responseReceived}}"</b>>&lt;/polymer-ajax><br />     &lt;!-- ... --><br />  &lt;/template><br />  &lt;script type="application/dart" src="x_pizza.dart">&lt;/script><br />&lt;/polymer-element></pre>So, by the time all assets have loaded, <code>responseReceived()</code> will have been invoked 4 times. I could hard-code this, but that would not be future-proof. Instead, I query my element's shadow DOM for the number of <code>&lt;polymer-ajax></code> elements:<pre class=prettyprint><code>  responseReceived(e, detail, node){<br />    svgContent[node.id] = detail['response'];<br /><b>    if (svgContent.length == shadowRoot.queryAll('polymer-ajax').length) {<br />      svgLoaded.complete();<br />    }</b><br /><br />    if (node.id == 'pizza.svg') _updateGraphic();<br />  }</code></pre>With that, I have <code>&lt;x-pizza></code> accepting start values:<br /><br /><a href="http://3.bp.blogspot.com/-gsID3o_AHsk/U4gFaXz6O9I/AAAAAAAAZ70/d1yIGgj_3i8/s1600/01-setting_polymer_attributes.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-gsID3o_AHsk/U4gFaXz6O9I/AAAAAAAAZ70/d1yIGgj_3i8/s400/01-setting_polymer_attributes.png" /></a><br /><br />That seems a good stopping point for tonight. Tomorrow, I will pick back up with reflecting changes back from the model onto topping attributes. There may be little more than watching attribute changes, but if tonight is any indication, it is a good bet that some previous silly assumption on my part will come back to bite me. Stayed tuned!<br /><br /><br /><span style="color: #ccc">Day #78</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/05/svg-viewports-who-knew.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/05/model-driven-attributes.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/fbh36LsSi90" height="1" width="1"/>
