---
title: 'Handle Body Reference Counting in Garbage Collected Dart'
layout: post
published: '2016-01-29T22:19:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Q_XcVhuffrs/handle-body-reference-counting-in.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Oh, what the hell. I finished yesterday hand-waving over a particular implementation. Let's see if I can actually implement a reference counting <a href="http://c2.com/cgi/wiki?HandleBodyPattern">handle body</a> in <a href="http://dartlang.org">Dart</a>. There may be no practical application for this in a garbage collected language like Dart, but we'll see...<br /><br />I continue to use <code>Shape</code> as the abstraction in my <a href="https://en.wikipedia.org/wiki/Bridge_pattern">bridge pattern</a> exploration. It will now serve double duty as the handle class, holding references to the body implementation. Well, it already did that (which is rather the point of the pattern), but now it needs to reference, dereference, and delete implementors as well.<br /><br />The implementor is <code>DrawingApi</code>, which knows that subclasses will, among other things, know how to draw a circle:<pre class=prettyprint>abstract class DrawingApi {<br />  void drawCircle(double x, double y, double radius);<br />}<br /></pre>To maintain reference counts, <code>DrawingApi</code> needs a <code>_refCount</code> instance variable along with <code>ref()</code> and <code>deref()</code> methods to increase and decrease that counter:<pre class=prettyprint>abstract class DrawingApi {<br />  int _refCount = 0;<br />  void ref() {<br />    _refCount++;<br />    print('  $this Increased refcount to $_refCount');<br />  }<br />  void deref() {<br />    _refCount--;<br />    print('  $this Decreased refcount to $_refCount');<br />  }<br />  void drawCircle(double x, double y, double radius);<br />}<br /></pre>In client code, I can create an instance of two subclasses of <code>DrawingApi</code>:<pre class=prettyprint>main() {<br />  var api1 = new DrawingApi1(),<br />      api2 = new DrawingApi2();<br />  // ...<br />}</pre>Then I initially set those as the "drawer" (the thing that draws, not a thing that holds stuff in desks) property for <code>Circle</code> instances:<pre class=prettyprint>main() {<br />  // ...<br />  var circle1 = new Circle(1.0, 2.0, 3.0)..drawer = api1,<br />      circle2 = new Circle(0.0, 6.0, 1.0)..drawer = api1,<br />      circle3 = new Circle(2.0, 2.0, 1.5)..drawer = api2;<br />  // ...<br />}</pre>The <code>Circle</code> class is a concrete implementor of the <code>Shape</code> abstraction / handle class. So assigning <code>api1</code> to two difference <code>Circle</code> instances needs to update the number of references to <code>api1</code> accordingly.<br /><br />I more or less copy the code from the handle / body example from the bridge pattern chapter in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a>. The <code>drawer()</code> setter is responsible for noting the new reference, and noting the derefence for the existing  object. If the reference count goes to zero, the handle class needs to delete the reference, which I do by assigning the <code>_drawingApi</code> instance variable to <code>null</code>:<pre class=prettyprint>abstract class Shape {<br />  DrawingApi _drawingApi;<br /><br />  set drawer(DrawingApi other) {<br />    other.ref();<br />    if (_drawingApi != null) {<br />      _drawingApi.deref();<br />      if (_drawingApi._refCount == 0) {<br />        print('  ** Deleting no longer used $_drawingApi **');<br />        _drawingApi = null;<br />      }<br />    }<br />    _drawingApi = other;<br />  }<br />}</pre>It is here that I finally realize that there is no point to doing any of thisâ€”at least not in this example. Even without explicitly setting <code>_drawingApi</code> to <code>null</code>, it gets assigned to a different value on the following line. Once that happens, Dart itself notes that there is one fewer references to the object and, if zero, schedules the object for garbage collection.<br /><br />I don't know why I thought this might be necessary in some cases. I do get easily confused in the presence of C++.<br /><br />Anyhow, back in my client code, I draw those circles with the mixture of <code>api1</code> and <code>api2</code>, then update the drawers so that everyone is using <code>api2</code>:<pre class=prettyprint>main() {<br />  // ...<br />  circle1.draw();<br />  circle2.draw();<br />  circle3.draw();<br /><br />  circle1.drawer = api2;<br />  circle2.drawer = api2;<br /><br />  api1 = api2 = null;<br /><br />  circle1.draw();<br />  circle2.draw();<br />  circle3.draw();<br />}</pre>When I run this code, I get what I expect. The first time through a mixture of <code>api1</code> and <code>api2</code> drawers are used, when I switch to all-<code>api2</code>, the deletion of the <code>api2</code> reference is noted, then <code>api2</code> drawing commences:<pre class=prettyprint>./bin/draw.dart<br />  Instance of 'DrawingApi1' Increased refcount to 1<br />  Instance of 'DrawingApi1' Increased refcount to 2<br />  Instance of 'DrawingApi2' Increased refcount to 1<br />[DrawingApi1] circle at (1.0, 2.0) with radius 3.000<br />[DrawingApi1] circle at (0.0, 6.0) with radius 1.000<br />[DrawingApi2] circle at (2.0, 2.0) with radius 1.500<br />  Instance of 'DrawingApi2' Increased refcount to 2<br />  Instance of 'DrawingApi1' Decreased refcount to 1<br />  Instance of 'DrawingApi2' Increased refcount to 3<br />  Instance of 'DrawingApi1' Decreased refcount to 0<br />  ** Deleting no longer used Instance of 'DrawingApi1' **<br />[DrawingApi2] circle at (1.0, 2.0) with radius 3.000<br />[DrawingApi2] circle at (0.0, 6.0) with radius 1.000<br />[DrawingApi2] circle at (2.0, 2.0) with radius 1.500</pre>So it works, but Dart already had me covered with garbage collection. The effort is not a complete waste. I did clear up whatever C++ confusion I was suffering. Potentially more important, I have client code that can demonstrate sharing implementors such that garbage collection will reclaim them when they go unused. <br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/43585b1f6e0f1403fc5a">https://dartpad.dartlang.org/43585b1f6e0f1403fc5a</a>.</i><br /><br /><br /><span style="color: #ccc">Day #79</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/sharing-implementors-is-easy-in-bridge.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/the-bridge-pattern-with-websockets-and.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Q_XcVhuffrs" height="1" width="1" alt=""/>
