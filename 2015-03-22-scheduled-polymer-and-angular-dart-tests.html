---
title: 'Scheduled Polymer and Angular (Dart) Tests'
layout: post
published: '2015-03-22T02:26:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/zi_Vdpt9sSc/scheduled-polymer-and-angular-dart-tests.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - angular
    - chain
    - dart
    - dartlang
    - polymer
    - testing

---

<div class=top-chain-links></div><br />I continue to evaluate <a href="http://patternsinpolymer.com/">Patterns in Polymer</a> against the latest pre-release version of <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a> (0.16). Last night I verified that <a href="https://github.com/angular/angular.dart">Angular.dart</a> solution from the book still works. Previously, I verified that simple testing still works. Tonight, I hope to verify that testing with Angular.dart works—thus verifying that more complex testing is still working with Polymer.dart 0.16.<br /><br />I'm fond of <a href="https://pub.dartlang.org/packages/scheduled_test">scheduled_test</a> for testing asynchronous <a href="http://dartlang.org">Dart</a> code. It sits right on top of the standard unittest, so most of the usual methods and matchers work. What it adds to unittest is nicer support for scheduling otherwise asynchronous actions in order, making tests for this type of code deterministic.<br /><br />The scheduled_test version of the simple, Polymer 0.16 test from the other day is:<pre class=prettyprint>library angular_test;<br /><br />import 'package:scheduled_test/scheduled_test.dart';<br />import 'package:unittest/html_config.dart';<br />import 'package:polymer/polymer.dart';<br /><br />main() {<br />  useHtmlConfiguration();<br />  initPolymer();<br /><br />  var _el;<br />  group("&lt;x-pizza>", (){<br />    setUp((){<br />      schedule(()=> Polymer.onReady);<br /><br />      schedule((){<br />        _el = createElement('&lt;x-pizza>&lt;/x-pizza>');<br />        document.body.append(_el);<br />      });<br /><br />      currentSchedule.onComplete.schedule(() => _el.remove());<br />    });<br /><br />    test('has a shadow root', (){<br />      schedule(() =><br />        expect(query('x-pizza').shadowRoot, isNotNull)<br />      );<br />    });<br />  });<br />}</pre>I import the testing, test output formatter, and Polymer packages. In the <code>main()</code> entry point, I use the test formatter and initialize Polymer, then I start my test. In <code>setUp()</code>, I have two schedules. The first returns the <code>Polymer.onReady</code> future. The scheduled_test library will want until this future completes before running any other schedules. So, in <code>setUp()</code>, the custom <code>&lt;x-pizza></code> Polymer element will not be added to the test page until Polymer is ready to process it—perfect! The last bit of code in <code>setUp()</code> is the scheduled_test version of a tear-down block—it removes the custom element after the test is executed.<br /><br />As for the test itself, it schedules the expectation that the shadow DOM of the custom element is present—a very basic sanity check that Polymer is working. It is important that this test wrap a schedule. Without it, this test will run before the <code>setUp()</code> schedules, which are placed into a queue. In other words, omitting the test schedule would evaluate expectation before Polymer was ready and before the element had been added to the page.<br /><br />That test passed, but what about a Polymer test on an Angular page? The Angular.dart package contains a lot of testing infrastructure, but I find it hard to use for application testing. It seems of more benefit for testing Angular itself, which is its purpose after all.<br /><br />So I create an entire application in my test:<pre class=prettyprint><code>    group("angular", (){<br />      XPizzaComponent xPizza;<br /><br />      setUp((){<br />        schedule((){<br />          var app = new PizzaStoreApp()<br />            ..bind(NodeBindDirective)<br />            ..bind(RouteInitializerFn, toValue: storeRouteInitializer);<br /><br />          applicationFactory()<br />            .addModule(app)<br />            .rootContextType(Pizza)<br />            .run();<br />        });<br />        // More schedules here...<br />      });<br />      // Tests here...<br />    });<br /></code></pre>The <code>PizzaStoreApp()</code> and router are dumbed-down versions of the ones used in the actual application. It is probably a mistake on my part, but my router actually points to a separate page in my test directory:<pre class=prettyprint>void storeRouteInitializer(Router router, RouteViewFactory views) {<br />  views.configure({<br />    'custom-pizza': ngRoute(<br />        defaultRoute: true,<br /><b>        view: 'custom.html'</b><br />      )<br />  });<br />}</pre>I am purposely trying to test that my Polymer element works when used in an Angular route, so I need something like this, but I am unsure if this is the best way to go about doing so. If nothing else, this requires me to wait for the <code>custom.html</code> partial to be loaded and inserted into the view. And I have no idea how to do this in Angular.dart, so I cheat:<pre class=prettyprint><code>    group("angular", (){<br />      setUp((){<br />        schedule((){ /* Schedule Angular app setup */ });o<br /><b>        schedule((){<br />          var _completer = new Completer();<br />          new Timer(new Duration(milliseconds: 50), ()=> _completer.complete());<br />          return _completer.future;<br />        });</b><br />        // ...<br />      });<br />    });</code></pre>If this were AngularJS, I could wait for a <code>$viewContentLoaded</code> event before completing this schedule. Unfortunately, there is no Anguar.dart equivalent for this event. So I am forced to wait some arbitrary amount of time. Ew.<br /><br />Ugliness aside, my tests still work. I can verify that an Angular value bound to my Polymer element is updated in response to a change in the Polymer element:<pre class=prettyprint><code>      test('can double-bind to Polymer properties', (){<br />        schedule(()=> xPizza.addWholeTopping('green peppers'));<br />        schedule((){<br />          var angular_el = document.query('pre');<br />          expect(<br />            angular_el.text,<br />            contains('"whole":["green peppers"]')<br />          );<br />        });<br />      });</code></pre>The <code>xPizza</code> object is a <a href="https://code.google.com/p/selenium/wiki/PageObjects">Page Object</a> that makes testing interaction a little clearer in my tests. In the end, these (and other) tests pass with the latest Polymer.dart:<pre class=prettyprint>PASS<br />1       PASS<br />Expectation: &lt;x-pizza> has a shadow root .<br /><br />2       PASS<br />Expectation: &lt;x-pizza> defaults to a blank pizza .<br /><br />3       PASS<br />Expectation: &lt;x-pizza> adding toppings updates the pizza state with new toppings .<br /><br />4       PASS<br />Expectation: &lt;x-pizza> angular can double-bind to Polymer properties .<br /><br />All 4 tests passed</pre>I really ought to get a better handle on testing Angular applications, but the hack that I have been using all along in Patterns in Polymer continues to work. <br /><br /><br /><br /><span style="color: #ccc">Day #5</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/03/bleeding-edge-angulardart-and.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="//feeds.feedburner.com/~r/JaphrByChrisStrom/~4/zi_Vdpt9sSc" height="1" width="1" alt=""/>
