---
title: 'Common Dart Scenarios for the ''Future'' API'
layout: post
published: '2012-10-05T15:15:00-05:00'
feed: 'phylotic connections'
link: 'http://phylotic.blogspot.com/2012/10/common-dart-scenarios-for-future.html'
author:
    name: Anonymous
    email: noreply@blogger.com
    url: ''
tags:
    - dart
    - dartlang
    - future
    - futures

---

A <a href="http://api.dartlang.org/docs/continuous/dart_core/Future.html" target="_blank">Future&lt;T&gt;</a> object represents a unit of work that will complete at some point in the - you guessed it - future. &nbsp;I use Futures a lot in my code and I thought that rather than do an exhaustive walk-through of the class itself, I'd share some of the more common patterns and concepts that I often find useful.<br /><br /><div><h2><span style="font-size: large;">In Future Does Not Mean In Parallel</span></h2></div><div>If you come from the .net world, you'll probably have some experience with Task&lt;T&gt; and the whole parallel processing API. &nbsp;Futures aren't that. &nbsp;They are more like structured callbacks, which will almost always run in the same memory space and thread as your application. &nbsp;They won't run in their own threads or multi-core on their own. &nbsp;If you're interested in parallelism, consider exploring Dart's <a href="http://api.dartlang.org/docs/continuous/dart_isolate.html" target="_blank">Isolates API</a>.<br /><br /></div><div><h2><span style="font-size: large;">Futures Are Not Automatically Asynchronous</span></h2></div><div><i>At the time of this writing, there is a <a href="http://code.google.com/p/dart/issues/detail?id=3356" target="_blank">ticket open in the Dart queue</a> to make all futures asynchronous, but for now what you are about to read remains accurate.</i><br /><br />It is important to understand that Futures are not necessarily asynchronous by default. Let's look at this example:</div><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> // This future is not asynchronous and will complete as soon as it is called.  <br /> Future&lt;bool&gt; greaterThan42(int number){  <br />   final c = new Completer();  <br />   c.complete(number &gt; 42);    <br />   return c.future;  <br /> }  <br /></code></pre><br />This above code is synchronous, in fact you can write it in a much more succinct way using the .immediate() constructor of the Future class:<br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future&lt;bool&gt; greaterThan42(int number) =&gt;  new Future.immediate(number &gt; 42);  <br /></code></pre><br />Futures are really most powerful when dealing with asynchronous work, lets use the Timer class to simulate that here:<br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future&lt;bool&gt; greaterThan42(num number){  <br />   final c = new Completer();  <br />   <br />   void doWork(_){  <br />    c.complete(number &gt; 42);  <br />   }  <br />   <br />   // take 3 long seconds to return our result  <br />   new Timer(3000, doWork);  <br />   <br />   return c.future;  <br /> }  <br /></code></pre><br />The example above uses the Timer asynchronously callback a function after a 3 seconds has elapsed.<br /><br /><h2><span style="font-size: large;">A Couple Of Common Future Scenarios</span></h2><h3><span style="font-size: large;">Waiting For One Or More Futures To Complete</span></h3>The futures API provides a very convenient way to deal with this scenario, in Futures.wait(). &nbsp;Lets see how it works by modifying our greaterThan42 future a bit. <br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Future&lt;bool&gt; greaterThan42(num number, int howLongMs){  <br />   final c = new Completer();  <br />   <br />   void doWork(_){  <br />    c.complete(number &gt; 42);  <br />   }  <br />   <br />   // take 3 long seconds to return our result  <br />   new Timer(howLongMs, doWork);  <br />   <br />   return c.future;  <br /> }  <br />   <br /> main(){  <br />   Futures  <br />    .wait([greaterThan42(5, 1000), greaterThan42(100, 3000)])  <br />    .then((List&lt;bool&gt; results){  <br />      print(results);  <br />    }  <br /> }  <br /></code></pre><br />So what is happening above when we send a list of 2 futures into Futures.wait()? &nbsp;Well, it waits! &nbsp;It does all the mundane work necessary to be sure that all the futures in the list have completed. &nbsp;It then itself returns a Future, containing a list of the results returned by the Futures we were waiting on.<br /><br />The results of running the above code will yield: <br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> [false, true]  <br /></code></pre><br />Similar to this, we often need to iterate over a list of objects, where a method in each object returns a future. Dealing with this in a standard iteration construct won't work cleanly, &nbsp;because the iteration will continue happily along whether or not our future has completed. &nbsp;We can use Futures.wait() and a .map() to deal with this nicely:<br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> main(){  <br />   Futures   <br />   .wait(listOfFoos.map((foo) =&gt; foo.callFutureMethod()))   <br />   .then(results){  <br />     // now we can safely iterate the results of the future calls  <br />     results.forEach((bar) { // ... });  <br />   }   <br /> }   <br /></code></pre><br /><br /><h3><span style="font-size: large;">Working with Futures in Sequence</span></h3>Often times we want to receive the result of some Future, and then pass that result into another Future. &nbsp;Do this 4 or 5 times and you get a really nasty scaffolding effect: <br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> callFutureA()  <br />   .then((resultA){  <br />    callFutureB(resultA)  <br />      .then((resultB){  <br />       callFutureC(resultB)  <br />         .then((resultC){  <br />           print('Kill me now!');  <br />         });  <br />      });  <br />   });  <br /></code></pre><br />Fortunately, the Future API gives us a nice way to deal with this as well, with Future.chain(). &nbsp;Future.chain() takes some result and then returns another future, such that you can keep your control flow flat: <br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> callFutureA()  <br />  .chain((resultA) =&gt; callFutureB(resultA))  <br />  .chain((resultB) =&gt; callFutureC(resultB))  <br />  .chain((resultC) =&gt; callFutureD(resultC))  <br />  .then((resultD){  <br />    print('Wait, don't kill me after all!');  <br />   });  <br /></code></pre><br />Furthermore, if you are just doing a simple transforms on a future, you don't have to wrap all of your transformational functions in Futures. &nbsp;You can use the Future.transform() function to achieve the same result:<br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> futureA(String foo) =&gt; new Future.immediate('$foo A');  <br /> functionB(String foo) =&gt; '$foo B';  <br /> functionC(String foo) =&gt; '$foo C';  <br /> functionD(String foo) =&gt; '$foo D';  <br />   <br />   <br /> main(){  <br />  futureA('Transform me!')  <br />   .transform(functionB)  <br />   .transform(functionC)  <br />   .transform(functionD)  <br />   .then((result) =&gt; print('$result'));  <br /> }  <br /></code></pre><br />Yields: <br /><pre style="background-image: URL(http://2.bp.blogspot.com/_z5ltvMQPaa8/SjJXr_U2YBI/AAAAAAAAAAM/46OqEP32CJ8/s320/codebg.gif); background: #f0f0f0; border: 1px dashed #CCCCCC; color: black; font-family: arial; font-size: 12px; height: auto; line-height: 20px; overflow: auto; padding: 0px; text-align: left; width: 99%;"><code style="color: black; word-wrap: normal;"> Transform me! A B C D<br /></code></pre><br />Now, I could go off on a tangent here about the need for an <b>await </b>keyword in Dart, and how that would make dealing with asynchronous control flows even more simple to work with, but I'll save that for another post (maybe).<br /><br /><h2><span style="font-size: large;">Summary</span></h2>The Future API provides a great way to manage asynchronous coding in Dart. &nbsp;Smart use of the API will keep your asynchronous code well managed and readable.
