---
title: 'When to Choose Your Own Implementation in the Bridge Pattern'
layout: post
published: '2016-01-31T20:29:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/cyCEXFb3GTw/when-to-choose-your-own-implementation.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - websockets

---

<div class=top-chain-links></div><br />At this rate, every pattern in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> is going to include a websocket. That is a little crazy considering that I do not use websockets all that often in actual client code, but they have the dual benefits of having an accessible API and being conceptually easy to understand. So who knows, maybe I will find a way to include them in every single pattern.<br /><br />The pattern of current investigation is the <a href="https://en.wikipedia.org/wiki/Bridge_pattern">bridge pattern</a>. As I found last night, websockets can serve as a realistic alternative to vanilla HTTP for communication. The alternative implementations for communication make the situation well suited for the bridge pattern, which seeks to "bridge" between an abstraction and multiple implementations. <br /><br />What I would like to examine tonight is creating the right implementor object. Last night, I made two quick decisions on when to create the <code>Communication</code> implementor. Perhaps I could have done that better.<br /><br />The abstraction in this bridge pattern example remains a <code>Messenger</code> class. It could be a mobile app for posting status updates or sending direct messages. It could be a web form that does the same thing. Either way, a messenger needs a reference to a concrete implementation of <code>Communication</code> and it needs to know how to post updates. So the interface that refined <code>Messenger</code> classes will need to extend looks like:<pre class=prettyprint>// Abstraction<br />abstract class Messenger {<br />  Communication comm;<br />  Messenger(this.comm);<br />  void updateStatus();<br />}</pre>The refined messenger class that I am using is a <code>WebMessenger</code>. Its constructor stores a text input element from which it can obtain messages to send:<pre class=prettyprint>class WebMessenger extends Messenger {<br />  InputElement _messageElement;<br />  WebMessenger(this._messageElement) :<br />    super(new HttpCommunication());<br />  // ...<br />}</pre>The bit after the constructor is a redirection to the superclass constructor, which supplies a <code>Communication</code> implementation to the <code>Messenger</code> superclass. Here is where I make my first decision about when to construct a <code>Communication</code> implementation. By default, I opt to create an <code>HttpCommunication</code> implementation of the <code>Communication</code> interface. Since the superclass requires a <code>Communication</code> object in its constructor, I either had to create one right in the constructor as I have done here or I could have required client code to do so. <br /><br />The choice of whether the client should provide the implementation or if it should be done in the refined abstraction comes down to the details of the code. To be perfectly honest, I did it this way because it was quickest. It probably was not the correct choice, however. Yesterday's implementation has the client choose when to switch between the websocket and HTTP concrete implementations. If the client code chose when to switch, it probably should determine initial state as well.<br /><br />But let's move the choice of implementation from the client and instead put in into the <code>WebMessenger</code>. It makes sense to start with a low-overhead <code>HttpCommunication</code> object. Given that, the redirecting constructor can stay as-is. But, should the client find itself at the mercy of a power user who is updating status more often than 3 times a minute, then the <code>WebMessenger</code> should switch to a websocket.<br /><br />So, after each message, I log the message along with a timestamp:<pre class=prettyprint>class WebMessenger extends Messenger {<br />  // ...<br />  List _history = [];<br />  // ...<br />  void updateStatus() {<br />    comm.send(message);<br />    _log(message);<br />  }<br /><br />  void _log(message) {<br />    _history.add([new DateTime.now(), message]);<br />  }<br />  // ...<br />}</pre>Then, after logging I do a simple calculation of the frequency with which this user is updating. If it is too often or too slow, I switch <code>Communication</code> implementations:<pre class=prettyprint>class WebMessenger extends Messenger {<br />  // ...<br />  void updateStatus() {<br />    comm.send(message);<br />    _log(message);<br />    _maybeChangeCommunication();<br />  }<br />  // ...<br />  _maybeChangeCommunication() {<br />    if (_history.length < 3) return;<br /><br />    var last = _history.length - 1,<br />      dateOld = _history[last-2][0],<br />      dateNew = _history[last][0],<br />      diff = dateNew.difference(dateOld);<br /><br />    if (diff.inSeconds < 60) {<br />      if (comm is! WebSocketCommunication)<br />        comm = new WebSocketCommunication();<br />    }<br />    else {<br />      if (comm is! HttpCommunication)<br />        comm = new HttpCommunication();<br />    }<br />  }<br />}</pre>That does the trick. If I send the first 3 message updates out in quick succession, then <code>WebMessenger</code> upgrades the connection to the <code>WebSocketCommunication</code> implementation. The server sees the first three messages come in over HTTP, then the next few over websockets:<pre class=prettyprint>$ ./bin/server.dart<br />[HTTP] message=asdf+1<br />[HTTP] message=asdf+2<br />[HTTP] message=asdf+3<br />[WebSocket] message=asdf 4<br />[WebSocket] message=asdf 5<br />[WebSocket] message=asdf 6<br />[HTTP] message=asdf+7</pre><p>I then wait a minute between messages 5 and 6, after which I have crossed the lower threshold and am again in the <code>HttpCommunication</code> implementation. </p><p>That seems a nice example of when it make sense for the refined abstraction to have responsibility for choosing the implementationâ€”websockets come through again! I do think that some or all of the choice behavior could move into the abstraction itself. Whether that is a good idea depends on the variance in refined abstractions. If a mobile messenger wanted different thresholds or added a new implementation, then the choose-your-implementation behavior would need to continue to reside in the refined abstractions. But if the web and mobile (and other) refined abstractions could share the same choices, then the subclasses could be wonderfully brief. </p><p><i>Code for the bridge client and the backend server are <a href="https://github.com/eee-c/design-patterns-in-dart/tree/c47bed0962fcf3424abf646e0d969b0a5534dd0a/bridge">on the Design Patterns in Dart public repository</a>.</i></p><p><span style="color: #ccc">Day #81</span>  </p><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/the-bridge-pattern-with-websockets-and.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/factory-bridges-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/cyCEXFb3GTw" height="1" width="1" alt=""/>
