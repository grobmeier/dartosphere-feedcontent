---
title: 'Adding a Visitor Really is That Easy'
layout: post
published: '2014-07-07T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/pXw3J2bdmw8/adding-visitor-really-is-that-easy.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'double dispatch'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />I have felt the pain of adding new nodes and structure in the <a href="http://dartlang.org">Dart</a> version of the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a>, but I have yet to try the opposite. Tonight, I try adding a new Visitor in the hopes that the pattern really does make this easy.<br /><br />All indications are that this should be nearly trivial. The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> says the pattern “lets you define a new operation without changing the classes of the elements on which it operates.” I have no reason to doubt this. Still, I need to give it whirl for the sake of completeness in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>.<br /><br />The data structure remains a collection of work stuff (equipment and apps):<pre class=prettyprint><code>  var work_stuff = new InventoryCollection([<br />    mobile()..apps = [<br />      app('2048', price: 10.0),<br />      app('Pixel Dungeon', price: 7.0),<br />      app('Monument Valley', price: 4.0)<br />    ],<br />    tablet()..apps = [<br />      app('Angry Birds Tablet Platinum Edition', price: 1000.0)<br />    ],<br />    laptop()<br />  ]);</code></pre>All of the inventory in that data structure implement the same <code>Inventory</code> interface:<pre class=prettyprint>abstract class Inventory {<br />  String name;<br />  Inventory(this.name);<br /><br />  double netPrice;<br />  double discountPrice() => netPrice;<br /><br /><b>  void accept(vistor);</b><br />}</pre>For the purposes of the Visitor Pattern, the <code>accept()</code> method at the end is the important piece. For each type of inventory, the class defines this method such that it calls a corresponding method in the visitor. The <code>Laptop</code> class defines <code>accept()</code> such that it invokes <code>visitLaptop()</code> in the visitor:<pre class=prettyprint>class Laptop extends Equipment {<br />  Laptop(): super('Laptop');<br />  double netPrice = 1000.00;<br />  double discountPrice() => netPrice * .9;<br /><b>  void accept(visitor) { visitor.visitLaptop(this); }</b><br />}<br /></pre><code>Mobile</code>'s <code>accept()<code> calls <code>visitMobile()</code>. And so on.<br /><br />Since every node in the data structure will call the corresponding method in the visitor, the visitor can perform operations across the entire structure. All of this is already in place and I have a total price Visitor that accumulates the total price—arcane business rules and all:<pre class=prettyprint>class PricingVisitor extends InventoryVisitor {<br />  double _totalPrice = 0.00;<br /><br />  double get totalPrice => _totalPrice;<br /><br />  void visitMobile(i) { _totalPrice += i.netPrice; }<br />  void visitTablet(i) { _totalPrice += i.discountPrice(); }<br />  void visitLaptop(i) { _totalPrice += i.discountPrice(); }<br /><br />  void visitApp(i) { _totalPrice += 0.5 * i.discountPrice(); }<br />}</pre>The question before me is, is it really easy to add a new visitor?<br /><br />To answer that, I start at the top. I would like a visitor that count the number of apps across types of inventory. Regardless of whether the app is installed on a tablet or mobile, I would like to be able to ask:<pre class=prettyprint><code>  var counter = new TypeCountVisitor();<br />  work_stuff.accept(counter);<br />  print('I have ${counter.apps} apps!');</code></pre>And it turns out that the GoF really were telling the truth. I do not need to make a single change to the node structure to obtain this information. All I need is a <code>TypeCountVisitor</code> class that counts the individual types in a <code>Map</code>:<pre class=prettyprint>class TypeCountVisitor extends InventoryVisitor {<br />  Map&lt;String,int> _count = {<br />    'mobile': 0,<br />    'tablet': 0,<br />    'laptop': 0,<br />    'app': 0<br />  };<br /><br />  int get mobiles => _count['mobile'];<br />  void visitMobile(i) { _count['mobile']++; }<br /><br />  int get tablets => _count['tablet'];<br />  void visitTablet(i) { _count['tablet']++; }<br /><br />  int get laptops => _count['laptop'];<br />  void visitLaptop(i) { _count['laptop']++; }<br /><br /><b>  int get apps => _count['app'];<br />  void visitApp(i) { _count['app']++; }</b><br />}</pre>If I run that against my “work stuff”, I find that I currently have 4 apps as expected:<pre class=prettyprint>$ ./bin/cost.dart<br /><b>I have 4 apps!</b><br /></pre>Nice!<br /><br /><br /><br /><br /><span style="color: #ccc">Day #115</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/what-heck-is-double-dispatch-and-does.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/pXw3J2bdmw8" height="1" width="1"/>
