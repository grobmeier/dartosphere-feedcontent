---
title: 'Long vs Short Benchmarks (also, I''m a true idiot)'
layout: post
published: '2014-07-13T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/70BF2CsIRD0/long-vs-short-benchmarks-also-im-true.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />For the second day in a row, I have to come clean on a dumb mistake. Benchmarks have a particular knack for doing me in, it would seem. And, as hard as I might try to rationalize the numbers that do not fit my world view, eventually the numbers get me. Which is why I like them so darn much.<br /><br />This time around, it was <a href="https://plus.google.com/u/0/101539040928169035212/about">Lasse Reichstein Holst Nielsen</a> who pointed out a flaw in my numbers. Specifically, my exponentiation. While mucking with the number of times that my benchmarks get run, I tried one million times, or <code>1e+6</code>. Only that is not what I put in my code:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  // ...<br />  void run() {<br /><b>    for (var i=0; i&lt;10^6; i++) {</b><br />      visitor.totalPrice = 0.0;<br />      nodes.accept(visitor);<br />    }<br />  }<br />}</pre>As Lasse was kind enough to point out, the hat operator in <a href="http://dartlang.org">Dart</a> is “bitwise or.” So I was combining the bits in <code>1010</code> and <code>0110</code>, giving me <code>1110</code>… or 12. That's just slightly less than the ONE MILLION I was going for... Speaking of which, I was wondering why increasing that number to 10^20 didn't bring things to a grinding halt. Generally, running a loop 30 times does not do that. Sigh.<br /><br />I should have noticed that the numbers did not line up, but in my defense, benchmark_harness ensures that the code being executed runs for at least 2 seconds. It will run the code a thousand or a billion times if needed to ensure that the code is executed for that 2 seconds. So I assumed that the lack of significant increase was due to fewer iterations needed.<br /><br />Yup… I assumed.<br /><br />Anyhow, I <i>think</i> this is the last of my blinders involved in this bit of benchmarking, which tries different implementations of the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> for eventual use in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. Since I had already gotten useful data from the 12 iteration approach to benchmarking, I had even planned on moving on to other territory tonight. <br /><br />And then I thought, “what happens if I do run the code ONE MILLION times?” Well, the answer is that it takes too long for me to wait. So instead, I try ten thousand for each of my three implementation benchmarks. The “classic” implementation that I will likely use in the book gets a benchmark like:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark() :<br />    super(<br />      "Classic Visitor Pattern",<br />      emitter: const ProperPrecisionScoreEmitter()<br />    );<br /><br />  static void main() { new VisitorBenchmark().report(); }<br /><br />  void run() {<br /><b>    for (var i=0; i&lt;1e+5; i++) {</b><br />      visitor.totalPrice = 0.0;<br />      nodes.accept(visitor);<br />    }<br />  }<br />}</pre>This results in:<pre class=prettyprint>$ ./tool/benchmark.dart; \<br />    echo '--'; \<br />    ./tool/benchmark_single_dispatch_iteration.dart; \<br />    echo '--'; \<br />    ./tool/benchmark_visitor_traverse.dart<br />Classic Visitor Pattern (RunTime): 1.444e+7 µs.<br />Classic Visitor Pattern (RunTime): 1.447e+7 µs.<br />Classic Visitor Pattern (RunTime): 1.449e+7 µs.<br />--<br />Nodes iterate w/ single dispatch (RunTime): 1.509e+7 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1.507e+7 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1.509e+7 µs.<br />--<br />Visitor Traverses (RunTime): 1.121e+7 µs.<br />Visitor Traverses (RunTime): 1.113e+7 µs.<br />Visitor Traverses (RunTime): 1.121e+7 µs.</pre>What is interesting about these numbers is that they are almost the complete opposite of what I found last night. In this case, making the Visitor object responsible for traversing the data structure is the clear winner. Also as interesting is that hand-optimizing the code with a single-dispatch call is the loser. Last night, with only 12 stinking runs, I found:<pre class=prettyprint>/tool/benchmark.dart; \<br />    echo '--'; \<br />    ./tool/benchmark_single_dispatch_iteration.dart; \<br />    echo '--'; \<br />    ./tool/benchmark_visitor_traverse.dart<br />Classic Visitor Pattern (RunTime): 1176 µs.<br />Classic Visitor Pattern (RunTime): 1167 µs.<br />Classic Visitor Pattern (RunTime): 1136 µs.<br />--<br />Nodes iterate w/ single dispatch (RunTime): 1097 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1074 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1078 µs.<br />--<br />Visitor Traverses (RunTime): 1179 µs.<br />Visitor Traverses (RunTime): 1142 µs.<br />Visitor Traverses (RunTime): 1118 µs.<br /></pre>Obviously the numbers are much smaller, but the winner for smaller sample sizes is the single dispatch approach. These were not just 12 runs and that is it. The default benchmark_harness implementation runs the benchmark code 10 times and will do so for at least 2 seconds. There are even a few warm-up runs for good measure. In other words, those numbers are legitimate benchmarks.<br /><br />In terms of what to use in the book, I am not quite sure what to make of this. Clearly, the longer that code is executed (10+ seconds vs 2 seconds) gives the Dart VM more time to optimize calls. I do not have a good explanation for why making the visitor responsible for traversing the node structure wins—and maybe I do not need one.<br /><br />My takeaway is that it would behoove me to investigate alternate approaches for each pattern <i>and</i> to include discussions for limited use (~1000 calls) vs heavy usage (10k+ calls).<br /><br /><br /><span style="color: #ccc">Day #121</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/blurry-benchmarks.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/benchmarking-at-different-run-length.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/70BF2CsIRD0" height="1" width="1"/>
