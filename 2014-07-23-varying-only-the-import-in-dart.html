---
title: 'Varying Only the Import in Dart'
layout: post
published: '2014-07-23T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Ggd-l7hUjwQ/varying-only-import-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang

---

<div class=top-chain-links></div><br />Tonight, I explore a new kind of <a href="http://dartlang.org">Dart</a> refactoring: varying the <code>import</code> statement.<br /><br />This occurs in the benchmarking code for the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> as part of my research for the future <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. I have three different approaches that I would to compare. After refactoring and refactoring and refactoring, I am finely down to very slim scripts that only vary by the implementation code being imported (and the name of the benchmark):<pre class=prettyprint>$ diff -u tool/benchmark.dart tool/benchmark_single_dispatch_iteration.dart<br />--- tool/benchmark.dart 2014-07-23 23:11:55.933361972 -0400<br />+++ tool/benchmark_single_dispatch_iteration.dart       2014-07-23 23:12:45.545363182 -0400<br />@@ -2,12 +2,12 @@<br /> <br /> import 'package:dpid_benchmarking/pattern_benchmark.dart';<br /> <br /><b>-import 'package:visitor_code/visitor.dart';<br />+import 'package:visitor_code/alt/single_dispatch_iteration/visitor.dart';</b><br /> <br /> main(List&lt;String> args) {<br />   BenchmarkRunner.main(<br />     args,<br />-    "Classic Visitor Pattern",<br />+    "Nodes iterate w/ single dispatch",<br />     _setup,<br />     _run<br />   );</pre>The <code>BenchmarkRunner.main()</code> method signature is a little ugly, but aside from the minor quibble I feel pretty good about this. Except…<br /><br />There are two dozen lines of code that follow this that are exactly identical in each of the three benchmark scripts. The setup and the actual code that is executed is 100% duplicate between the three files. It looks something like:<pre class=prettyprint>var visitor, nodes;<br /><br />_setup() {<br /><b>  visitor = new PricingVisitor();</b><br /><br /><b>  nodes = new InventoryCollection([mobile(), tablet(), laptop()]);</b><br />  // Add more sub-nodes to complexify the structure...<br />}<br /><br />_run(loopSize) {<br />  // nodes used<br />  // visitor used<br />  // (nodes accept visitor a bunch of times)<br />}</pre>I am creating a closure over <code>visitor</code> and <code>nodes</code> so that they can be shared between the setup and benchmark runner when executed by <code>BenchmarkRunner</code>.<br /><br />What is important to me in this case is that the <code>PricingVisitor</code> and <code>InventoryCollection</code> classes <i>have the same name, but are defined differently by the three different imported packages in the three different scripts that I have</i>.<br /><br />This is almost certainly unique to benchmarking considerations, but still, how can I move this duplicated code out into a single file that can be shared? Dart parts will not work because the file containing the common setup and run code would have to be the main file and only one of the three implementations could be part of it. Conditional imports do not work in Dart.<br /><br />Unfortunately, I am more or less stumped on a good way to do this. Dart is not meant to used like this (I'm not sure any language is). That said, I can come up with <i>something</i> that works. I have to use the Factory Method pattern to create the visitor and the node structure (I also have to pull in makers for the nodes within the structure). In the end, the overhead does not seem to save much in the way of lines of code:<pre class=prettyprint>import '_setup.dart' as Setup;<br /><br />main(List&lt;String> args) {<br /><b>  Setup.visitorMaker = ()=> new PricingVisitor();<br />  Setup.inventoryCollectionMaker = (items) => new InventoryCollection(items);<br />  Setup.mobile = mobile;<br />  Setup.tablet = tablet;<br />  Setup.laptop = laptop;<br />  Setup.app = app;</b><br /><br />  BenchmarkRunner.main(<br />    args,<br />    "Classic Visitor Pattern",<br />    Setup.setup,<br />    Setup.run<br />  );<br />}<br /></pre>What I do gain is the ability to keep the test setup and running logic in one place: <code>_setup.dart</code>. And in there, I simply define top-level variables to support the <code>Setup.XXX</code> setters:<pre class=prettyprint>library visitor_setup;<br /><br /><b>var visitorMaker;<br />var inventoryCollectionMaker;<br />var mobile;<br />var tablet;<br />var laptop;<br />var app;</b><br /><br />var visitor, nodes;<br /><br />setup() {<br />  visitor = visitorMaker();<br />  // ...<br />}<br />// ...<br /></pre>I am not satisfied with that, but it does have the advantage of keeping the common logic in one place. At the risk of rationalizing this too much, I note that the 6 <code>Setup</code> assignments are only needed because I am using 4 node types to intentionally create complexity in the data structure being tested.<br /><br />I will leave this as “good enough” for the time being. Using this on other design patterns will ultimately decide if this approach is usable. So I will pick back up with that tomorrow.<br /><br /><br /><br /><span style="color: #ccc">Day #131</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/internal-dart-packages-for-organizing.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Ggd-l7hUjwQ" height="1" width="1"/>
