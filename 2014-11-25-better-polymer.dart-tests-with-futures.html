---
title: 'Better Polymer.dart Tests with Futures'
layout: post
published: '2014-11-25T23:59:00-05:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/ETOyczPNcNg/better-polymerdart-tests-with-futures.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - futures
    - polymer
    - testing

---

<div class=top-chain-links></div><br />I lamented <a href="https://www.dartlang.org/polymer-dart/">Polymer.dart</a>'s JavaScript-y callback nature yesterday. But I didn't do much about it. Ultimately I cannot do much until the library matures into more of a <a href="http://dartlang.org">Dart</a> library. The <a href="http://patternsinpolymer.com/">Patterns in Polymer</a> book needs to track the library, not my weakly held, strong opinions (and I do admit that it makes sense to track the JavaScript <a href="http://www.polymer-project.org/">Polymer</a> for now). <br /><br />That said, I do think it worth exploring Dart futures as a means for cleaning up my tests. <br /><br />Last night's test looks like:<pre class=prettyprint><code>    group('syncing &lt;input> values', (){<br />      var input;<br /><br />      setUp((){<br />        input = _container.append(createElement('&lt;input>'));<br />        syncInputFromAttr(input, _el, 'state');<br />        _el.model.firstHalfToppings.add('pepperoni');<br />      });<br /><br />      test('updates the input', (){<br />        _el.async(expectAsync((_){<br />          expect(<br />            input.value,<br />            startsWith('First Half: [pepperoni]')<br />          );<br />        }));<br />      });<br />    });</code></pre>For a small test, that is not too horrible. Problems would arise as the complexity of the Polymer element grows.<br /><br />The main problem with the above test is in the actual test:<pre class=prettyprint><code>      test('updates the input', (){<br />        _el.async(expectAsync((_){<br />          expect(<br />            input.value,<br />            startsWith('First Half: [pepperoni]')<br />          );<br />        }));<br />      });<br /></code></pre>The <code>expectAsync()</code> call in there is a nod to the asynchronous nature of Polymer and my attempt to account for it in my test. I need to wait for Polymer to invoke the supplied callback, which is what wrapping the callback in <code>expectAsync()</code> does. But it obscures the purpose of the test.<br /><br />The async nature of this particular test is not integral to the functionality. It is merely a necessary evil to ensure that the Polymer element has been updated. Instead, I would much prefer to write:<pre class=prettyprint><code>      test('updates the input', (){<br />        expect(<br />          input.value,<br />          startsWith('First Half: [pepperoni]')<br />        );<br />      });</code></pre>The intent of that test is much clearer.<br /><br />To make that work, I need a setup that blocks. I had forgotten that vanilla unittest in Dart supports this by of the <code>setUp()</code> block returns a Future:<br /><pre class=prettyprint><code>      setUp((){<br />        input = _container.append(createElement('&lt;input>'));<br />        syncInputFromAttr(input, _el, 'state');<br />        _el.model.firstHalfToppings.add('pepperoni');<br /><br /><b>       var completer = new Completer();<br />       _el.async(completer.complete);<br />       return completer.future;</b><br />      });</code></pre>I am none too fond of the completer dance that is necessary. My preference would be to use something along the lines of Ruby's <code>tap()</code>, which in Dart would look something like this:<pre class=prettyprint><code>        return new MyCompleter()<br />          ..tap((completer){ _el.async(completer.complete); })<br />          .future;</code></pre>Alas, Dart does not support <code>tap()</code> or an equivalent. Alas too that <code>Completer</code> is abstract, making it impossible to extend to add this functionality.<br /><br />When I use the <a href="https://code.google.com/p/selenium/wiki/PageObjects">Page Objects</a> testing pattern with my Polymer elements, I typically define a <code>flush()</code> method on the page object. The page object <code>flush()</code> can do the completer dance, making the code pretty nice. <br /><br />The closest that I can get without page objects is a <code>_flush()</code> test helper:<pre class=prettyprint>Future&lt;T> _flush(el) {<br />  var completer = new Completer();<br />  el.async(completer.complete);<br />  return completer.future;<br />}</pre>This leaves my setup as:<pre class=prettyprint><code>      setUp((){<br />        input = _container.append(createElement('<input>'));<br />        syncInputFromAttr(input, _el, 'state');<br />        _el.model.firstHalfToppings.add('pepperoni');<br /><br /><b>        return _flush(_el);</b><br />      });</code></pre>That is nice, but ugh, how I hate indirection in tests. <br /><br /><b>Update:</b> This is one <code>Future</code> method in Polymer: <code>onMutation()</code>. And it works, but there is something of an impedance mismatch as it requires a node argument. I can make the tests pass if I supply the Polymer element's shadow root as the argument:<pre class=prettyprint><code>      setUp((){<br />        input = _container.append(createElement('<input>'));<br />        syncInputFromAttr(input, _el, 'state');<br />        _el.model.firstHalfToppings.add('pepperoni');<br /><br /><b>        return _el.onMutation(_el.shadowRoot);</b><br />      });</code></pre>While that works, it adds undesirable complexity. Reading that in 6 months I would wonder why I was passing the <code>shadowRoot</code> propertyâ€”was that a requirement of my test? Of my code? Or was it (as is the case here) just something that made the test work, but has no particular value.<br /><br />I think I will stick with some variation of the completer dance for now. But it sure would be nice if the Polymer.dart folks would add a proper Future version of async.<br /><br /><br /><span style="color: #ccc">Day #5</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/11/testing-polymerdart-synchronization.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/ETOyczPNcNg" height="1" width="1"/>
