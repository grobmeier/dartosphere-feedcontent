---
title: 'Dart Delegation'
layout: post
published: '2016-01-06T21:48:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Ru3-1iNt7hg/dart-delegation.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - delegation
    - 'design patterns'

---

<div class=top-chain-links></div><br />Nearly done exploring the <a href="https://en.wikipedia.org/wiki/Adapter_pattern#Object_Adapter_pattern">adapter pattern</a>, I would like to take one more look at delegation in <a href="http://dartlang.org">Dart</a>. Delegation has come in handy the past few days as I have explored pluggable adapters, but it has been informal delegation. I am curious if there are more formal approaches available.<br /><br />The delegation that I have been using in in the constructor of my "universal remote robot" class:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  Ubot _ubot;<br />  UniversalRemoteRobot(robot) {<br />    if (robot is Robot) _ubot = new RobotAdapterToUbot(robot);<br />    else if (robot is Bot) _ubot = new BotAdapterToUbot(robot);<br />    else _ubot = new NullAdapterToUbot(robot);<br />  }<br />  // ...<br />}</pre>The <code>_ubot</code> private instance variable holds the delegated robot instance. Since this has been exploring adapters, the delegate points to the appropriate class that adapts a robot to the interface used in this universal remote control packages.<br /><br />I might clean up that constructor by moving it into a getter:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  var robot;<br />  UniversalRemoteRobot(this.robot);<br /><br />  Ubot get _ubot {<br />    if (robot is Robot) return new RobotAdapterToUbot(robot);<br />    if (robot is Bot)   return new BotAdapterToUbot(robot);<br />    return new NullAdapterToUbot(robot);<br />  }<br />  // ...</pre>That does eliminate an <code>else if</code>, which I always appreciate. Still, it is just a superficial change and does not really touch on delegation.<br /><br />What I am most curious about is what to do with calling methods on the delegated instance:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  // ...<br />  String get xyLocation => _ubot.xyLocation;<br /><br />  void moveForward()  { _ubot.moveForward(); }<br />  void moveBackward() { _ubot.moveBackward(); }<br />  void moveLeft()     { _ubot.moveLeft(); }<br />  void moveRight()    { _ubot.moveRight(); }<br />}</pre>There seems to be some repetition there. It seems like it might be time for some mirror fun. <br /><br />I import <code>dart:mirrors</code>, then delete the four <code>move*</code> methods. In there place, I declare an <code>InstanceMirror</code> getter and a <code>noSuchMethod()</code> method:<pre class=prettyprint>import 'dart:mirrors';<br /><br />class UniversalRemoteRobot implements Ubot {<br />  // ...<br /><br />  InstanceMirror get _botMirror => reflect(_ubot);<br /><br />  dynamic noSuchMethod(i) {<br />    return _botMirror.invoke(i.memberName, []).reflectee;<br />  }<br /><br />  String get xyLocation => _ubot.xyLocation;<br />}</pre>The <code>noSuchMethod()</code> is available on all Dart objects. It receives an invocation mirror instance describing the arguments that were passed to non-existent method. In this case, I know that my four methods do not accept arguments, so I can ignore the list of arguments. I do need to know the specific movement method that was called, which is stored in <code>memberName</code> of the invocation mirror.<br /><br />The last piece of the puzzle there is a mirror of the <code>_ubot</code> delegated adapter. The only way to call an arbitrary method on an object in Dart is through a mirror. So the <code>_botMirror</code> getter returns that mirror from the <code>reflect()</code> function in <code>dart:mirrors</code>. <br /><br />With that, I have an instance mirror of my adapter, and can invoke whichever movement method was sent to the <code>UniversalRemoteRobot</code> instance:<pre class=prettyprint><code>  universalRobot = new UniversalRemoteRobot(robot);<br />  print("Start moving the robot.");<br />  universalRobot<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward()<br />    ..moveForward();<br />  print("The robot is now at: ${universalRobot.xyLocation}.");</code></pre>And that works just fine, thank you:<pre class=prettyprint>$ ./bin/play_robot.dart<br />Start moving the robot.<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />  I am moving Direction.NORTH<br />The robot is now at: 0, 5.</pre>I still need to handle that <code>xyLocation</code> getter method that is sent to the delegate. This means a conditional in the <code>noSuchMethod()</code> declaration to handle getters:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  // ....<br />  dynamic noSuchMethod(i) {<br />    if (i.isGetter) return _botMirror.getField(i.memberName).reflectee;<br />    return _botMirror.invoke(i.memberName, []).reflectee;<br />  }<br />}</pre>With that, I have completely delegated the pluggable adapter methods from the delegator to appropriate adapater. That is nice, especially since it is only four lines of code, but... that is a dense 4 lines of code. Say, while I was looking through the Dart <code>InstanceMirror</code> documentation, I could not help but notice that there is a <code>delegate()</code> method. That could not possibly do exactly what I expect it to, could it?<br /><br />In fact, it does just that:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  // ...<br />  dynamic noSuchMethod(i) => reflect(_ubot).delegate(i);<br />}</pre>That is lovely. Simply lovely.<br /><br />With that, I can write the entire delegator class in my pluggable adapter pattern as:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  var robot;<br />  UniversalRemoteRobot(this.robot);<br /><br />  Ubot get _ubot {<br />    if (robot is Robot) return new RobotAdapterToUbot(robot);<br />    if (robot is Bot)   return new BotAdapterToUbot(robot);<br />    return new NullAdapterToUbot(robot);<br />  }<br /><br />   dynamic noSuchMethod(i) => reflect(_ubot).delegate(i);<br />}</pre>Making this even nicer is that, no matter what methods are added to the <code>Ubot</code> interface, this does not need to change in order to support it. I do not have to define new methods. I do not need any additional conditionals in <code>noSuchMethod()</code>. I like this very much.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/5a8d96b4825f9cdc6085">https://dartpad.dartlang.org/5a8d96b4825f9cdc6085</a>.</i><br /><br /><br /><span style="color: #ccc">Day #56</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/extending-er-implementing-er-replacing.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Ru3-1iNt7hg" height="1" width="1" alt=""/>
