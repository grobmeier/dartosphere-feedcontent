---
title: 'The Reactor Pattern in Dart'
layout: post
published: '2014-07-25T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/67wIba7sFJg/the-reactor-pattern-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'reactor pattern'

---

<div class=top-chain-links></div><br />I purposefully did not include the phrase “object oriented” in the title of <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. The reason, of course, was that I hope to explore others software design patterns in the book. Some of the patterns that most interest me have to do with concurrency—not because that is where the action is in <a href="http://dartlang.org">Dart</a>, but because I am so weak with them. <br /><br />Let me start by stating that I do not <i>really</i> understand the difference between the actor model, the reactor pattern, regular old events, or the observer pattern. It is not that I have no idea, but rather that I know that I lack the understanding to be able to teach them or their differences. This is why I hope to include them in the book.<br /><br />Part of the challenge before me is that Dart is built on many of these patterns. Normal operations under Dart occur in an event loop that (I believe) is the reactor pattern. Isolates are built on the actor model. Streams support publish and subscribe. And so forth. So how do I discuss these patterns when they are the building blocks of the language? I really have no good answer to that question, but I have an idea how I can start thinking about them.<br /><br />So tonight, I implement the Reactor Pattern as described by Douglas C. Schmidt in his <a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf">Reactor</a> paper. Since the reactor pattern is running underneath in Dart itself, this may be a little weird, but I'm going to try it anyhow.<br /><br />I start with the main dispatcher as:<pre class=prettyprint>class InitiationDispatcher {<br />  var events = {};<br /><br />  static final InitiationDispatcher _dispatcher =<br />    new InitiationDispatcher._internal();<br /><br />  factory InitiationDispatcher() {<br />    return _dispatcher;<br />  }<br /><br />  InitiationDispatcher._internal();<br /><br /><b>  registerHandler(eventHandler, eventType) {<br />    events.putIfAbsent(eventType, ()=> []);<br />    events[eventType].add(eventHandler);<br />  }</b><br /><br />  removeHandler(eventHandler, eventType) {}<br /><br />  handleEvents([int timeout=0]) {<br />    // ...?<br />  }<br />}</pre>Most of that is just setting up a singleton per the article. I will worry about <code>removeHandler()</code> another day. I am not quite sure how to handle events just yet, so I leave that open for a bit. I do know how to register a new handler—for a given type of event and corresponding handler object, I add the object to the list of handlers for that type. Adding objects instead of functions is different than the normal event listeners to which I am accustomed, but I roll with it here.<br /><br />Then the handle event class is a simple keyboard reader:<pre class=prettyprint>import 'dart:io';<br />import 'InitiationDispatcher.dart';<br /><br />class HandleKey {<br />  HandleKey(){<br />    new InitiationDispatcher().registerHandler(this, 'key');<br />  }<br /><br />  handleEvent(eventType) {<br />    if (eventType == 'key') {<br />      print('[handled] $handle');<br />    }<br />  }<br /><br />  get handle {<br />    return stdin.readLineSync();<br />  }<br />}</pre>As in the paper, I exploit the singleton nature of <code>InitiationDispatcher</code> to get the one instance and register this new keyboard handler when it is constructed. I am still struggling with the Dart equivalent for a “handle” from the paper. Here, I start with reading from STDIN. If nothing else, this will give me something with which to experiment.<br /><br />Finally main:<pre class=prettyprint>#!/usr/bin/env dart<br /><br />import 'package:reactor_code/InitiationDispatcher.dart';<br />import 'package:reactor_code/HandleKey.dart';<br /><br />main() {<br />  new HandleKey();<br /><br />  for(;;) {<br />    new InitiationDispatcher().handleEvents();<br />  }<br />}</pre>I create an instance of the <code>HandleKey</code> class (which registers itself with the reactor dispatcher). Then I enter into the infinite loop that tries to <code>handleEvents()</code>.<br /><br />And I remain stumped here on how to handle events in the reactor loop without stealing data from the actual handler—how can I see that there is stuff to be read from STDIN, but not actually read it? Not knowing what else to try, I define <code>handleEvents()</code> as:<pre class=prettyprint>class InitiationDispatcher {<br />  // ...<br /><b>  handleEvents([int timeout=0]) {<br />    var line = stdin.readLineSync();<br />    print('[handleEvents] $line');<br />    events['key'].forEach((h)=> h.handleEvent('key'));<br />  }</b><br />}</pre>The important part is that <code>handleEvents()</code> tells the appropriate handlers to do their things (the last line of the method). But actually waiting for an event blocks until a line is ready from STDIN—defeating the entire purpose of the Reactor Pattern. Still, for tracer bullet purposes, it works. If I type 1, 2, 3, 4, and so on, I get:<pre class=prettyprint>$ ./bin/reactor.dart<br />[handleEvents] 1<br />[handleEvent] 2<br />[handleEvents] 3<br />[handleEvent] 4<br />[handleEvents] 5<br />[handleEvent] 6</pre>The first event triggers the dispatcher. The second triggers the actual handlers.<br /><br />So I sort of have a Reactor Pattern in Dart. But it would be nicer to have one that did not block and that better mimics handles and select() from the paper. I do not necessarily need low-level I/O or networking access to accomplish this, but what I have now is insufficient. I will ruminate on that (or if someone has suggestions?) and pick back up tomorrow.<br /><br /><br /><span style="color: #ccc">Day #133</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/logarithmic-scales-for-when-winner-is.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/67wIba7sFJg" height="1" width="1"/>
