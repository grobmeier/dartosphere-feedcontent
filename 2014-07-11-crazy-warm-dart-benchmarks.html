---
title: 'Crazy Warm Dart Benchmarks'
layout: post
published: '2014-07-11T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/r8lU4eQUDXY/crazy-warm-dart-benchmarks.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />After last night, I am happy to have a new benchmark reporter that does not report 16 digits of precision when times vary after 3 digits:<pre class=prettyprint>$ ./tool/benchmark.dart; \<br />      echo '--'; \<br />        ./tool/benchmark_single_dispatch_iteration.dart; \<br />      echo '--'; \<br />        ./tool/benchmark_visitor_traverse.dart<br />Classic Visitor Pattern (RunTime): 1409 µs.<br />Classic Visitor Pattern (RunTime): 1375 µs.<br />Classic Visitor Pattern (RunTime): 1374 µs.<br />--<br />Nodes iterate w/ single dispatch (RunTime): 1311 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1276 µs.<br />Nodes iterate w/ single dispatch (RunTime): 1290 µs.<br />--<br />Visitor Traverses (RunTime): 1388 µs.<br />Visitor Traverses (RunTime): 1350 µs.<br />Visitor Traverses (RunTime): 1362 µs.</pre>But I am still not satisfied that I have a solid handle on benchmarking different approaches to patterns for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>.<br /><br />I can live with small deviations in reported times, but the numbers that I get now indicate that the “warm-up” time for my benchmarks is woefully insufficient. I currently have three variations of the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> that I am benchmarking. For each of the three, I run my benchmarks three times. And, for every group, the first run takes the longest while the second two runs are very close to each other.<br /><br />The idea of a warm-up run is not some brilliant insight on my part. It is baked right into Dart's <code>benchmark_harness</code> package:<pre class=prettyprint>part of benchmark_harness;<br /><br />class BenchmarkBase {<br />  // ...<br />  // Runs a short version of the benchmark. By default invokes [run] once.<br /><b>  void warmup() {<br />    run();<br />  }</b><br />  // ...<br />}</pre>One might be tempted to think the problem obvious: only running the benchmark <code>run()</code> method once is woefully inadequate.  Except that the <code>run()</code> method in each of my three benchmark variations runs the actual code ONE MILLION times:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark() :<br />    super(<br />      "Classic Visitor Pattern",<br />      emitter: const ProperPrecisionScoreEmitter()<br />    );<br /><br />  static void main() { new VisitorBenchmark().report(); }<br /><br /><b>  void run() {<br />    for (var i=0; i&lt;10^6; i++) {<br />      visitor.totalPrice = 0.0;<br />      nodes.accept(visitor);<br />    }<br />  }</b><br />}<br /></pre>OK. OK. It's more fun to say ONE MILLION than it is effective. But what might be effective?<br /><br />The <code>warmup()</code> method of <code>BenchmarkBase</code> seems like it might be fit my needs:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark() :<br />    super(<br />      "Classic Visitor Pattern",<br />      emitter: const ProperPrecisionScoreEmitter()<br />    );<br />  static void main() { new VisitorBenchmark().report(); }<br /><br />  void warmup() {<br />    for (var i=0; i&lt;10^20; i++) {<br />     visitor.totalPrice = 0.0;<br />      nodes.accept(visitor);<br />    }<br />  }<br /><br />  void run() { /* ... */  }<br />}</pre>But even at 10^20 iterations, this has little effect (the stinking Visitor Pattern is just too darn efficient). <br /><br />I need the warmup to run for even longer. For that, I think I'll override <code>BenchmarkBase</code>'s <code>measure()</code> method:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark() :<br />    super(<br />      "Classic Visitor Pattern",<br />      emitter: const ProperPrecisionScoreEmitter()<br />    );<br />  // ...<br />  double measure() {<br />    setup();<br />    // Warmup for at least 100ms. Discard result.<br />    measureFor(() { this.warmup(); }, 100);<br />    // Run the benchmark for at least 2000ms.<br />    double result = measureFor(() { this.exercise(); }, 2*1000);<br />    teardown();<br />    return result;<br />  }<br />}<br /></pre>That will not work as-is because the <code>measureFor()</code> method invoked by <code>measure()</code> is a static method of <code>BenchmarkBase</code>:<pre class=prettyprint>$ ./tool/benchmark.dart<br />Unhandled exception:<br />Class 'VisitorBenchmark' has no instance method 'measureFor'.<br /><br />NoSuchMethodError: method not found: 'measureFor'<br />Receiver: Instance of 'VisitorBenchmark'<br />Arguments: [Closure: () => dynamic, 10000]<br />#0      Object.noSuchMethod (dart:core-patch/object_patch.dart:45)<br />#1      VisitorBenchmark.measure (file:///home/chris/repos/design-patterns-in-dart/visitor/tool/benchmark.dart:44:15)<br />#2      BenchmarkBase.report (package:benchmark_harness/src/benchmark_base.dart:65:31)<br />#3      VisitorBenchmark.main (file:///home/chris/repos/design-patterns-in-dart/visitor/tool/benchmark.dart:35:53)<br />#4      main (file:///home/chris/repos/design-patterns-in-dart/visitor/tool/benchmark.dart:10:24)</pre>So I have to manually resolve it:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark() :<br />    super(<br />      "Classic Visitor Pattern",<br />      emitter: const ProperPrecisionScoreEmitter()<br />    );<br />  // ...<br />  double measure() {<br />    setup();<br />    <b>BenchmarkBase.measureFor(() { this.warmup(); }, 10*1000);</b><br />    // Run the benchmark for at least 2000ms.<br />    double result = BenchmarkBase.measureFor(() { this.exercise(); }, 2*1000);<br />    teardown();<br />    return result;<br />  }<br />}</pre>While I am at it, I call <code>BenchmarkBase.measureFor()</code> for 10 seconds worth of warm-up instead of the base 100ms. With that, I get more consistent number for each of my benchmark runs:<pre class=prettyprint>$ ./tool/benchmark.dart<br />Classic Visitor Pattern (RunTime): 204.5 µs.<br />Classic Visitor Pattern (RunTime): 203.7 µs.<br />Classic Visitor Pattern (RunTime): 203.7 µs.<br />$ ./tool/benchmark.dart<br />Classic Visitor Pattern (RunTime): 201.8 µs.<br />Classic Visitor Pattern (RunTime): 203.2 µs.<br />Classic Visitor Pattern (RunTime): 201.4 µs.</pre>That is all well and good, but it may be overkill. Even with the original numbers, the comparison between the different approaches would still be valid for the first run. Even though the numbers are elevated in the first run, they are consistently elevated. All that I need to determine which, if any, approaches should be discounted for performance reasons is a consistent comparison. And, for the different approaches to Visitor, the difference is so small that any would work just as well as the others.<br /><br />Still, it was good to dig into Dart's benchmark harness some more. I have a better handle on how it works—and how I might tailor it should I need to.<br /><br /><br /><span style="color: #ccc">Day #119</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/precision-vs-accuracy-in-benchmarking.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/blurry-benchmarks.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/r8lU4eQUDXY" height="1" width="1"/>
