---
title: 'On Second Thought, Extending Dart Generics'
layout: post
published: '2015-12-27T23:57:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/dnjDy6GVTiw/on-second-thought-extending-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - generics

---

<div class=top-chain-links></div><br />Extending  <a href="http://dartlang.org">Dart</a> generics was new to me. And, having slept on it, I don't think I am a fan.<br /><br />Following a suggestion last night, I briefly explored Dart generics as a way of limiting types in the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a>. Do not mistake me here, I love the suggestion itself.  As documentation, I think the generics suggestion works to a certain extent, though it was not obvious to me at first (perhaps it should have been so I'll let it slide for now). <br /><br />So what is the particular implementation that has me bugged? It is extending a generic as in:<pre class=prettyprint>class ExtendedGenericB&lt;T extends B> {<br />  T prop;<br />  ExtendedGenericB(this.prop);<br />}</pre>What this says is that my <code>ExtendedGenericB</code> class supports type annotation when instances are created. The <code>prop</code> instance variable must be of whatever type is supplied <i>and</i> it has to be a <code>B</code> class or one of <code>B's</code> subclasses.<br /><br />That is, if I have three classes, <code>A</code>, <code>B</code> which is a subclass of <code>A</code>, and <code>C</code> which is a subclass of <code>B</code>:<pre class=prettyprint>class A {}<br />class B extends A {}<br />class C extends B {}</pre>Then my extended generic declarations says that <code>prop</code>, which gets its type from the generic, must either a <code>B</code> or a <code>C</code> type. And at first blush that seems to be the case.<br /><br />If I declare an instance of <code>ExtendedGenericB</code> with type parameter of <code>A</code> (a superclass of the declared <code>B</code> upper bound for my generic):<pre class=prettyprint><code>  var a = new A();<br />  new ExtendedGenericB&lt;A>(a);</code></pre>Then I get a static type warning as expected:<pre class=prettyprint>[warning] 'A' does not extend 'B' </pre>For what it's worth, this is the relevant section (14. Generics) from <a href="https://www.dartlang.org/docs/spec/#h.dkzw3xyky3rs">the Dart spec</a>:<blockquote>A type parameter <i>T</i> may be suffixed with an <b>extends</b> clause that specifies the <i>upper bound</i> for <i>T</i>. If no <b>extends</b> clause is present, the upper bound is <code>Object</code>. It is a static type warning if a type parameter is a supertype of its upper bound. The bounds of type variables are a form of type annotation and have no effect on execution in production mode.</blockquote>So all seems well, right?<br /><br />Things start to get a little murkier if I change the type parameter on the instance from <code>A</code> to <code>B</code> or even <code>C</code>:<pre class=prettyprint><code>  // Why does this work?<br />  new ExtendedGenericB&lt;C>(a);<br /></code></pre>I get no warnings here even though I am specifying a type <code>C</code> for the instance's <code>prop</code> value while supplying an object of type <code>A</code>.<br /><br />The explanation for this is that Dart is not really statically typed. Rather its <a href="https://www.dartlang.org/articles/why-dart-types/">types are unsound</a>. That is, I could assign <code>C c = new A()</code> and would see no warnings. I understand why this is the case, though when I run into it in live code, I usually have to give it some thought.<br /><br />Things get really strange when setting the upper bound as a typedef, as I tried last night. If I declare <code>A</code> with a void-return-no-argument <code>call()</code> method:<pre class=prettyprint>class A {<br />  void call() {}<br />}</pre>Then I have created a <a href="https://www.dartlang.org/articles/emulating-functions/">function class</a>. That is, I could create an instance of <code>A</code>, as in <code>A a = new A();</code>, then call it like a function: <code>a()</code>. Since it is a void-return-no-argument function, I can describe it with a typedef:<pre class=prettyprint>typedef void Command();</pre>Where this gets really mind-bendy is when extending a generic with a typedef, which actually works:<pre class=prettyprint>class ExtendedGenericB&lt;T extends Command> {<br />  T prop;<br />  ExtendedGenericB(this.prop);<br />}</pre>Now I can create an <code>ExtendedGenericB</code> with a class or function:<pre class=prettyprint><code>  var a = new A();<br />  // Works because Dart is unsound:<br />  new ExtendedGenericB&lt;B>(a);<br /><br />  // Works because class upper limits to a typedef<br />  new ExtendedGenericB&lt;Command>((){ print('whoa!'); });</code></pre>I have to admit that this is pretty cool. But I still find it hard to follow. I have a better grasp on it now that I have noodled it through. I remain skeptical that I would use it in real life and even more so that I would remember what it meant coming back to it six months later. That said, it seems interesting enough to allow to percolate another day or two before dismissing it to fringe coding practices. <br /><br /><i>Play with it yourself on DartPad: <a href="https://dartpad.dartlang.org/5e8eba316adb2bf03a8b">https://dartpad.dartlang.org/5e8eba316adb2bf03a8b</a>.</i><br /><br /><br /><span style="color: #ccc">Day #46</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/typedef-and-dart-command-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/dnjDy6GVTiw" height="1" width="1" alt=""/>
