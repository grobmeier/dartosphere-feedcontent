---
title: 'Reflecting on Annotations'
layout: post
published: '2014-05-08T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/NbHij5_1ifM/reflecting-on-annotations.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - annotations
    - chain
    - dart
    - dartlang

---

<div class=top-chain-links></div><br />Last night's exploration of annotations in <a href="http://dartlang.org">Dart</a> piqued my curiosity over how <a href="https://github.com/angular/angular.dart">Angular.dart</a> uses annotations so effectively.<br /><br />To date, I have only used annotations <a href="http://japhr.blogspot.com/2013/01/i-love-dart-annotations.html">as glorified code comments</a>. But there is clearly great potential that I am overlooking. So I start with a simple <code>main.dart</code> file that contains a main entry point with an annotation:<pre class=prettyprint>@meta('This is main!')<br />main() {<br />  print('[main] Hello!');<br />}<br /></pre>Simple enough, when run from the command-line, it prints out:<pre class=prettyprint>$ dart main.dart <br />[main] Hello!</pre>It fails <code>dartanalyzer</code> analysis without defining that annotation:<pre class=prettyprint>$ dartanalyzer main.dart<br />Analyzing main.dart...<br /><b>[error] Annotation can be only constant variable or constant constructor invocation (/home/chris/repos/gists/reflecting_annotations/main.dart, line 5, col 1)</b><br />1 error found.</pre>So I define a simple “meta” annotation class:<pre class=prettyprint>/// Sweet meta data about a class (or thing)<br />///<br />///     @meta('Nice code')<br />///     class Bar { /* ... */}<br /><b>class meta {<br />  final String note;<br />  const meta(this.note);<br />}</b><br /></pre>That satisfies <code>dartanalyzer</code> while my code still runs as before.<br /><br />That's all well and good, but how do I get at that annotation data? For that, I am going to need to start with the <code>dart:mirrors</code> library:<pre class=prettyprint><b>import 'dart:mirrors';</b><br /><br />@meta('This is main!')<br />main() {<br />  print('[main] Hello!');<br />}</pre>Now I need to do something with those mirrors. I have to confess that I find this a non-obvious path from this point. I know that I need to start by reflecting on <code>main()</code>:<pre class=prettyprint><code>  var selfMirror = reflect(main);</code></pre>Reading through Angular.dart source, I know that I need to extract metadata, but it is not entirely clear to me how it does this. What is clear is that <code>metadata</code> is a property of <a href="https://api.dartlang.org/apidocs/channels/stable/dartdoc-viewer/dart-mirrors.DeclarationMirror#id_metadata">DeclarationMirror</a>. But <code>reflect()</code> is giving me a <code>ClosureMirror</code>, which does not have a <code>DeclarationMirror</code> property or method. After a bit of meandering, I find that <code>ClosureMirror</code> has a <code>function</code> property which just so happens to implement <code>DeclarationMirror</code>.<br /><br />I can get that meta data (for the <code>@meta</code> annotation which I would have named differently had I known the name of the getter) as a list of <code>InstanceMirror</code> objects. I access just the first and print it out:<pre class=prettyprint>import 'dart:mirrors';<br /><br />@meta('This is main!')<br />main() {<br />  print('[main] Hello!');<br /><br />  var selfMirror = (reflect(main) as ClosureMirror).function;<br />  var metaData = selfMirror.metadata;<br />  print('[main] Meta is: ${metaData[0]}.');<br />}</pre>Which gives me:<pre class=prettyprint>$ dartanalyzer main.dart; dart main.dart<br />Analyzing main.dart...<br />No issues found<br />[main] Hello!<br />[main] Meta is: InstanceMirror on Instance of 'meta'.<br /></pre>I try accessing the <code>note</code> field from my <code>meta</code> class:<pre class=prettyprint><code>  print('[main] Meta is: ${metaData[0].getField(#note)}.');</code></pre>That gets me the actual notation that I wanted, but I am still working with an object instead of the actual string note:<pre class=prettyprint>[main] Meta is: InstanceMirror on "This is main!".</pre>To get the <code>note</code> property, I access the <code>relfectee</code> property of the meta data (which is an <code>InstanceMirror</code>):<pre class=prettyprint>import 'dart:mirrors';<br /><br />@meta('This is main!')<br />main() {<br />  print('[main] Hello!');<br /><br />  var selfMirror = (reflect(main) as ClosureMirror).function;<br />  var metaData = selfMirror.metadata;<br /><b>  print('[main] Meta is: ${metaData[0].reflectee.note}');</b><br />}<br /></pre>That finally gets me access to the value that I wanted from the annotation:<pre class=prettyprint>$ dartanalyzer main.dart; dart main.dart<br />Analyzing main.dart...<br />No issues found<br />[main] Hello!<br />[main] Meta is: This is main!</pre>I probably have to work with this mirror stuff more to appreciate it. Right now, I am going from <code>ClosureMirror</code> to <code>MethodMirror</code> to <code>InstanceMirror</code> to “reflectee”—all of which seems like quite a journey. <br /><br />Thinking about it, I can understand the <code>InstanceMirror</code> / “reflectee” relationship. The former has to hold any number of different types of objects (reflectees) in a consistent API, but also allow direct access to the actual object. <br /><br />I also get the <code>MethodMirror</code> / <code>InstanceMirror</code> relationship. The meta data is made available as a list of these instance mirrors, which it can build via the mirror class definition.<br /><br />I am not sure that I fully understand the difference between <code>ClosureMirror</code> and <code>MethodMirror</code>. The latter, as a class that implements <code>DeclarationMirror</code>, would seem to have more to do with the language. The <code>ClosureMirror</code>, which implements <code>InstanceMirror</code> would seem to have more to do with the running of the code. I suppose I begin to understand the difference, but it feels like there are some bigger concepts that I would only fully grasp with more experience. Which I may try to get more of tomorrow.<br /><br /><br /><br /><span style="color: #ccc">Day #57</span>  <br /><br /><p class=bottom-chain-links><a href="japhr.blogspot.com/2014/05/dart-annotations-are-no-longer.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/05/reflecting-on-dart-classes-and-variables.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/NbHij5_1ifM" height="1" width="1"/>
