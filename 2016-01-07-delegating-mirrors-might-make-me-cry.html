---
title: 'Delegating Mirrors Might Make Me Cry'
layout: post
published: '2016-01-07T23:22:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/5U5r_cwCfSc/delegating-mirrors-might-make-me-cry.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />There is a point at which programmers should leave well enough alone. That point and I have long quarrels typically ending with me saying something that I regret and then driving around for hours until I have cooled down sufficiently to apologize.<br /><br />This is likely to be one of those situations.<br /><br />After last night, my delegating, pluggable adapter is beautiful in <a href="http://dartlang.org">Dart</a>:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  var robot;<br />  UniversalRemoteRobot(this.robot);<br /><br />  Ubot get _ubot {<br />    if (robot is Robot) return new RobotAdapterToUbot(robot);<br />    if (robot is Bot)   return new BotAdapterToUbot(robot);<br />    return new NullAdapterToUbot(robot);<br />  }<br /><br />   dynamic noSuchMethod(i) => reflect(_ubot).delegate(i);<br />}</pre>The constructor for the <code>UniversalRemoteRobot</code> class accepts an instance of some kind of robot and assigns it to the <code>this.robot</code> instance variable. The <code>noSuchMethodMethod()</code> method, which is available to any Dart object, delegates any unknown methods called on <code>UniversalRemoteRobot</code> objects to the appropriate adapter, as determined by the <code>_ubot</code> getter. <br /><br />The <code>delegate()</code> method, which comes from the <code>dart:mirrors</code> library, makes maintenance of this code quite nice. The <code>Ubot</code> interface currently support four movement methods as well as a position getter:<pre class=prettyprint>abstract class Ubot {<br />  String get xyLocation;<br />  void moveForward();<br />  void moveBackward();<br />  void moveLeft();<br />  void moveRight();<br />}</pre>Were that to change—if additional directions were added or cameras were supported—I would have to do nothing to my pluggable adapter. The <code>delegate()</code> would continue to merrily send those new actions to the appropriate adapter. I should be contented by this.<br /><br />But...<br /><br />Whenever a new kind of robot is supported, I need to define the appropriate <code>Ubot</code> adapter <i>and</i> remember to add the adapter to the <code>_ubot</code> delegating getter. That is not completely horrible, which is why I ought to leave this alone. <br /><br />That said, I can rationalize a concern for the size of the getter. Right now, I only support robots from two vendors in my universal remote control for robots code. What happens when I have dozens of robot vendors to support? A hundred line getter won't be too pretty then. Worse, it will obscure the main focus of this class, which is delegating to pluggable adapters.<br /><br />So I would like to dynamically choose the adapter. This is going to involve more mirrors, so I start by switching the <code>_ubot</code> getter to return a mirror instead of a regular instance:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  var robot;<br />  UniversalRemoteRobot(this.robot);<br /><br />  InstanceMirror get _ubot {<br />    if (robot is Robot) return reflect(new RobotAdapterToUbot(robot));<br />    if (robot is Bot)   return reflect(new BotAdapterToUbot(robot));<br />    return reflect(new NullAdapterToUbot(robot));<br />  }<br /><br />   dynamic noSuchMethod(i) => _ubot.delegate(i);<br />}</pre>This also allows the <code>noSuchMethod()</code> declaration to use the getter right away, instead of having to reflect first.<br /><br />Now for the fun stuff. To find the adapter class, I need a mirror on the current library. I cannot just say give-me-the-current-library, I have to reflect on an object in the current library (like <code>this</code>), find the class mirror via the <code>type</code> property, then ask for the <code>owner</code> (the library):<pre class=prettyprint><code>    LibraryMirror thisLibrary = reflect(this).type.owner;</code></pre>I can already feel a good cry coming on.<br /><br />I have been following the convention of naming the adapter classes &lt;Adaptee Name&gt;AdapterToUbot, so the adapter for the <code>Robot</code> class becomes <code>RobotAdapterToUbot</code>. Using that convention, I can determine the adapter class as:<pre class=prettyprint><code>    Symbol adapterClassName = new Symbol('${robot.runtimeType}AdapterToUbot');</code></pre>That's not too horrible. This next bit is.<br /><br />To find the class mirror for the adapter, I have to look it up in the map of all declarations in the current library:<pre class=prettyprint><code>    var adapterClass = thisLibrary.declarations[adapterClassName];</code></pre>With that class mirror for the adapter, I can get a new instance mirror with the <code>newInstance()</code> method:<pre class=prettyprint><code>    Symbol constructor = new Symbol('');<br />    return adapterClass.newInstance(constructor, [robot]);</code></pre>The empty constructor name is required so that <code>newInstance()</code> can also work with named constructors.<br /><br />Putting it all together, the delegating adapter getter now looks like:<pre class=prettyprint>class UniversalRemoteRobot implements Ubot {<br />  // ...<br />  InstanceMirror get _ubot {<br />    LibraryMirror thisLibrary = reflect(this).type.owner;<br /><br />    Symbol adapterClassName = new Symbol('${robot.runtimeType}AdapterToUbot');<br />    var adapterClass = thisLibrary.declarations[adapterClassName];<br /><br />    Symbol constructor = new Symbol('');<br />    return adapterClass.newInstance(constructor, [robot]);<br />  }<br />  // ...<br />}</pre>That works in the sense that the code runs and does what it is supposed to do. On some level, it also makes the code more maintainable, since I now only have to add a new &lt;Adaptee Name&gt;AdapterToUbot declaration. But this utterly fails to make the code more readable. My beautiful <code>UniversalRemoteRobot</code> class is now a mirrored mess. I do not want to even think how prefixed libraries might affect all of this.<br /><br />I may leave this exploration path alone. It seems possible. I can clean it up some by moving this code out into an explicit delegator class. But I doubt that I can clean it up to the point that I can include it <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> without confusing actual pattern discussion.<br /><br />So if you'll excuse me now, I need to drive around weeping for a while.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/08b74952148403a6c74d">https://dartpad.dartlang.org/08b74952148403a6c74d</a>.</i><br /><br /><br /><br /><span style="color: #ccc">Day #57</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/dart-delegation.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/5U5r_cwCfSc" height="1" width="1" alt=""/>
