---
title: 'Degenerate Abstractions'
layout: post
published: '2016-02-03T22:43:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/Pkk_Gmuuw0c/degenerate-abstractions.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'bridge pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - websockets

---

<div class=top-chain-links></div><br />What do you get when you remove all but one refined abstraction from the <a href="https://en.wikipedia.org/wiki/Bridge_pattern">bridge pattern</a>? I already looked into what happens when you <a href="http://japhr.blogspot.com/2016/01/degenerate-bridges.html">only need one implementor</a>. The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> even included a discussion about one implementor, terming it a "degenerate case." What about the opposite?<br /><br />The prime mover in the bridge pattern is given the seemingly vague name of "The Abstraction." There are two required characteristics for the abstraction. First, it needs to perform some action whose exact implementation can vary. Second, it needs to have subclasses—different specific types of the abstraction. These subclasses are called refined abstractions mostly because they had to call them something and "concrete abstraction" is a contradiction in terms.<br /><br />The idea is that client code can use different refined abstractions with different implementations. Maybe the client chooses which implementation to use. Maybe the refined abstraction chooses. It doesn't matter. Each refined abstraction should work with each action implementation. Furthermore developers should be able to make changes to the implementation without requiring corresponding changes to the refined abstractions and vice versa.<br /><br />When there is only one implementation, the Gang of Four book concludes that there is still value to the pattern. Even if only one implementation for the action is ever used, the separation of the implementation from abstraction still buys independent changes to each. So the same thing should be true of multiple implementations and a single abstraction, right?<br /><br />Let's take a look at the web example that I have been using. The backend communication has two implementations, one to send messages over websockets and the other to send messages over plain-old HTTP. In <a href="http://dartlang.org">Dart</a>, this looks like:<pre class=prettyprint>abstract class Communication {<br />  void send(String message);<br />}<br /><br />// Concrete Implementor 1<br />class HttpCommunication implements Communication {<br />  void send(message) {<br />    HttpRequest.postFormData('/status', {'message': message});<br />  }<br />}<br /><br />// Concrete Implementor 2<br />class WebSocketCommunication implements Communication {<br />  WebSocket _socket;<br />  WebSocketCommunication() { _startSocket(); }<br /><br />  _startSocket() async { /* ... */  }<br /><br />  void send(message) {<br />    _socket.send("message=$message");<br />  }<br />}</pre>My original <i>intent</i> (it's important that I use that specific word) is to have multiple <code>Messenger</code> refined abstractions will allow people to post status updates:<pre class=prettyprint>// Abstraction<br />abstract class Messenger {<br />  Communication comm;<br />  Messenger(this.comm);<br />  void updateStatus();<br />}</pre>In this thought experiment, I am coding the web version while another team is building a mobile <code>Messenger</code>. The <code>Messenger</code> interface tells both teams how to build our classes. We will be communicating with some form of <code>Communciation</code> and we need an <code>updateStatus()</code> method to post messages over those communication channels.<br /><br />But something happens. Just after we start, the company decides that it is web-only and fires the entire mobile team. Since I want to avoid premature generalization, I get rid of the <code>Messenger</code> interface and dump everything into <code>WebMessenger</code>:<pre class=prettyprint>// Degenerate Abstraction<br />class WebMessenger  {<br />  Communication comm;<br />  InputElement _messageElement;<br />  WebMessenger(this._messageElement) : comm = new HttpCommunication();<br /><br />  void updateStatus() {<br />    comm.send(message);<br />  }<br /><br />  String get message => _messageElement.value;<br />}<br /></pre>I still support the <code>Communication</code> implementor, defaulting to the <code>HttpCommunication</code> concrete implementation. I still support the <code>updateStatus()</code> method. I also have code specific to a web page, which grabs the message to post from an input element. But, despite the new web-specific code, the original intent is still the same. I want to be able to make changes to the communication implementation without affecting the <code>WebMessenger</code> abstraction. I still want to be able to assign different <code>Communication</code> objects, in this case at runtime when a different radio button is selected:<pre class=prettyprint><code>  queryAll('[name=implementor]').<br />    onChange.<br />    listen((e) {<br />      var input = e.target;<br />      if (!input.checked) return;<br /><br />      if (input.value == 'http')<br />        message.comm = new HttpCommunication();<br />      else<br />        message.comm = new WebSocketCommunication();<br />    });</code></pre>So the intent remains the same. And, maybe someday the company will come to its senses and rehire a mobile team. At that point, the abstraction interface can be pulled back out and I will have a true bridge. In the meantime, what do I have? <br /><br />This sure looks like a simple <a href="https://en.wikipedia.org/wiki/Strategy_pattern">strategy pattern</a> to me:<pre class=prettyprint>class WebMessenger  {<br />  Communication comm;<br />  // ...<br />  void updateStatus() {<br />    comm.send(message);<br />  }<br />  // ...<br />}</pre>In that sense, a <code>WebMessenger</code> <i>has a</i> <code>Communication</code> object. The specific implementation of <code>Communication</code> can vary depending on what strategy is chosen. So is it a strategy? <br /><br />I think the answer is that it remains a bridge because of the intent—intent is big in patterns. Even though it winds up looking exactly like a strategy, the structure was originally chosen to support a multiple abstraction structure. Plus, it could easily be refactored to get back to an interface that makes the pattern more explicit.<br /><br />What I find interesting, however, is what another developer might think should she come along 6 months from now. Without the interface, she should reasonably conclude that the intent is a simple strategy pattern. Under that assumption, she might very well make any number of subsequent design decisions that make it very hard to switch back to a bridge. So in that sense, who cares what the intent was? Unless the intent is made explicit in some form, it would seem that structure trumps intent. <br /><br />And so, my final answer is that a degenerate abstraction in the bridge pattern does not guarantee that the pattern remains a bridge. More often than not, a degenerate abstraction in the bridge pattern means that it is a bridge pattern no more. In its place is a strategy pattern, intent be damned.<br /><br /><br /><span style="color: #ccc">Day #84</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/in-which-i-quarrel-with-bridge-names.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/Pkk_Gmuuw0c" height="1" width="1" alt=""/>
