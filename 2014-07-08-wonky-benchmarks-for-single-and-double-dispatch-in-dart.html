---
title: 'Wonky Benchmarks for Single and Double Dispatch in Dart'
layout: post
published: '2014-07-08T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/5haSA5JYJOY/wonky-benchmarks-for-single-and-double.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'visitor pattern'

---

<div class=top-chain-links></div><br />I think I am nearly done with my exploration of the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> (at least the early research). I do not feel as though I have put nearly as much effort into it as I did the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method Pattern</a> though. So, at the risk of dragging this out too much...<br /><br />There are not many variations of the Visitor. One possible suggestion from the  <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> is to change the iterators used to move through composites in the node structure being processed. While reading this, I realized that my current iterator is using an inefficient double dispatch where a single dispatch is possible. This sounds like a nice chance to introduce benchmarks.<br /><br />The overall data structure remains an inventory of my work stuff:<pre class=prettyprint><code>  var work_stuff = new InventoryCollection([<br />    mobile()..apps = [<br />      app('2048', price: 10.0),<br />      app('Pixel Dungeon', price: 7.0),<br />      app('Monument Valley', price: 4.0)<br />    ],<br />    tablet()..apps = [<br />      app('Angry Birds Tablet Platinum Edition', price: 1000.0)<br />    ],<br />    laptop()<br />  ]);</code></pre>Making use of the Visitor Pattern, I can introduce a visitor to this data structure and perform all sorts of useful operations:<pre class=prettyprint><code>  var cost = new PricingVisitor();<br />  work_stuff.accept(cost);<br />  print('Cost of work stuff: ${cost.totalPrice}.');</code></pre>The unnecessary double dispatch occurs in the concrete nodes like <code>Mobile</code>:<pre class=prettyprint>class Mobile extends EquipmentWithApps {<br />  Mobile(): super('Mobile Phone');<br />  double netPrice = 350.00;<br />  void accept(visitor) {<br /><b>    apps.forEach((app) { app.accept(visitor); });</b><br />    visitor.visitMobile(this);<br />  }<br />}</pre>Even though I am iterating over a list of apps, I am still invoking the double dispatch <code>accept()</code> method. This is double dispatch because the ultimate definition of the code invoked by this call depends on two objects instead of the usual one. In this case, it depends on the type of the object on which <code>accept</code> is called and the type of visitor. But in this case, I know the type of <code>app</code> at compile-time: it is an <code>App</code> object. Furthermore, I know that the <code>accept()</code> method in <code>App</code> calls <code>visitApp()</code>:<pre class=prettyprint>class App extends Inventory {<br />  App(name): super(name);<br /><b>  void accept(visitor) { visitor.visitApp(this); }</b><br />}<br /></pre>Since the <code>apps</code> attribute in <code>Mobile</code> will only be comprised of <code>App</code> instances, I can eliminate the indirection and call <code>visitor.visitApp(app)</code> directly:<pre class=prettyprint>class Mobile extends EquipmentWithApps {<br />  Mobile(): super('Mobile Phone');<br />  double netPrice = 350.00;<br />  void accept(visitor) {<br /><b>    apps.forEach((app) { visitor.visitApp(app); });</b><br />    visitor.visitMobile(this);<br />  }<br />}</pre>So let's benchmark. I create a single dispatch version of my visitor which is identical to my original except that is uses single dispatch in its iterators:<pre class=prettyprint>$ diff -u lib/inventory*<br />--- lib/inventory.dart  2014-07-08 22:07:45.322210237 -0400<br />+++ lib/inventory_single_dispatch.dart  2014-07-08 23:44:20.826351606 -0400<br />@@ -1,4 +1,5 @@<br />-library inventory2; // iterators double dispatch<br />+library inventory1; // iterators single dispatch<br />+<br /> <br /> App app(name, {price: 0}) => new App(name)..netPrice = price;<br /> Mobile mobile([name]) => new Mobile()..name = name;<br />@@ -44,7 +45,7 @@<br />   Mobile(): super('Mobile Phone');<br />   double netPrice = 350.00;<br />   void accept(visitor) {<br /><b>-    apps.forEach((app) { app.accept(visitor); });<br />+    apps.forEach((app) { visitor.visitApp(app); });</b><br />     visitor.visitMobile(this);<br />   }<br /> }<br />@@ -53,7 +54,7 @@<br />   Tablet(): super('Tablet');<br />   double netPrice = 400.00;<br />   void accept(visitor) {<br /><b>-    apps.forEach((app) { app.accept(visitor); });<br />+    apps.forEach((app) { visitor.visitApp(app); });</b><br />     visitor.visitTablet(this);<br />   }<br /> }<br /></pre>Then I write my benchmark_harness code such that I import the single dispatch version as <code>i1</code> and the double dispatch version as <code>i2</code>:<pre class=prettyprint>import 'package:benchmark_harness/benchmark_harness.dart';<br /><br />import 'package:visitor_code/visitor.dart';<br /><b>import 'package:visitor_code/inventory_single_dispatch.dart' as i1;<br />import 'package:visitor_code/inventory.dart' as i2;</b></pre>I do not expect huge differences so I try to push the issue by adding a large number of apps to my test code:<pre class=prettyprint>class NodesSingleBenchmark extends BenchmarkBase {<br />  const NodesSingleBenchmark() : super("Nodes iterate w/ single dispatch ");<br />  static void main() { new NodesSingleBenchmark().report(); }<br /><br />  final Map o = {};<br /><br />  void setup() {<br />    o['visitor'] = new PricingVisitor();<br /><br /><b>    o['nodes'] = new i1.InventoryCollection([<br />      i1.mobile(), i1.tablet(), i1.laptop()<br />    ]);<br />    for (var i=0; i&lt;1000; i++) {<br />      o['nodes'].stuff[0].apps.add(i1.app('Mobile App $i', price: i));<br />    }<br />    for (var i=0; i&lt;100; i++) {<br />      o['nodes'].stuff[1].apps.add(i1.app('Tablet App $i', price: i));<br />    }</b><br />  }<br /><br />  get visitor => o['visitor'];<br />  get nodes => o['nodes'];<br /><br />  void run() {<br />    nodes.accept(visitor);<br />    // print('Cost of work stuff: ${visitor.totalPrice}.');<br />  }<br />}<br /></pre>My setup adds 1000 apps to the mobile in my inventory collection as well as 100 apps to the tablet. I duplicate this for my double dispatch import as well. With that, I run my benchmarks as:<pre class=prettyprint>main () {<br />  NodesSingleBenchmark.main();<br />  NodesDoubleBenchmark.main();<br />  print('--');<br />  NodesDoubleBenchmark.main();<br />  NodesSingleBenchmark.main();<br />}</pre>Running this, I find:<pre class=prettyprint>$ ./tool/benchmark.dart<br />Nodes iterate w/ single dispatch (RunTime): 112.0197154699227 us.<br />Nodes iterate w/ double dispatch (RunTime): 113.87576154415532 us.<br />--<br />Nodes iterate w/ double dispatch (RunTime): 112.19566924716706 us.<br />Nodes iterate w/ single dispatch (RunTime): 111.11111111111111 us.</pre>Well, I did not expect a huge difference, but I expected <i>some</i> difference.<br /><br />What is really odd is that, if I switch my single dispatch code back to the original double dispatch implementation <i>then</i> I do see a difference:<pre class=prettyprint>$ diff lib/inventory*  <br />1c1<br />< library inventory2; // iterators double dispatch<br />---<br />> library inventory1; // iterators single dispatch<br />$ ./tool/benchmark.dart<br /><b>Nodes iterate w/ single dispatch (RunTime): 121.52883271556176 us.</b><br />Nodes iterate w/ double dispatch (RunTime): 112.02599002968688 us.<br />--<br />Nodes iterate w/ double dispatch (RunTime): 111.08642523883582 us.<br /><b>Nodes iterate w/ single dispatch (RunTime): 120.12733497507358 us.</b></pre>The code should be identical, but is consistently 7% slower than the duplicate. And if I switch the order in which the benchmarks are invoked, then the results change as well. I know that I am doing something wrong, but for the life of me, I cannot figure this one out.<br /><br /><b>Update:</b> Eventually, I pull the two benchmarks out into separate benchmark scripts. With that, I find the results that I expect. When the iterators in both libraries are identical, I get (nearly) identical results from the benchmarks. When the implementations are different, I do find different numbers:<pre class=prettyprint>./tool/benchmark_for_double_dispatch.dart <br />Nodes iterate w/ double dispatch (RunTime): 120.14898474107893 us.<br />Nodes iterate w/ double dispatch (RunTime): 121.0800339024095 us.<br />$ ./tool/benchmark_for_<b>single</b>_dispatch.dart <br />Nodes iterate w/ <b>single</b> dispatch (RunTime): 111.11111111111111 us.<br />Nodes iterate w/ <b>single</b> dispatch (RunTime): 109.33143825507024 us.<br /></pre>I find this quite interestingâ€”and a little worrisome. It seems safe to say that keeping different Dart benchmark classes in separate code files is more than just a best practice. I wonder how all of this affects dart2js benchmarks. Something to try tomorrow.<br /><br /><br /><span style="color: #ccc">Day #116</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/adding-visitor-really-is-that-easy.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/benchmarking-dart2js-visitor.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/5haSA5JYJOY" height="1" width="1"/>
