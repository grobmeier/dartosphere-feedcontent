---
title: 'Simulating Select for a Dart Reactor'
layout: post
published: '2014-07-26T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/aUXck1j62VM/simulating-select-for-dart-reactor.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'reactor pattern'

---

<div class=top-chain-links></div><br />I still hope to build an illustrative implementation of the <a href="http://en.wikipedia.org/wiki/Reactor_pattern">Reactor Pattern</a> in <a href="http://dartlang.org">Dart</a>. The ultimate goal is to begin to understand the right abstraction level which <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> should approach concurrency patterns (or if it even should include them). Many concurrency patterns come baked into Dart (as does the Reactor Pattern), so it is very much an open question if I ought to cover them. Still, it is worth exploring…<br /><br />After last night, I have the dispatcher and event handler interfaces fairly well defined as:<pre class=prettyprint>abstract class Dispatcher {<br />  void handleEvents([int timeout=0]);<br />  void registerHandler(EventHandler);<br />  void removeHandler(EventHandler);<br />}<br /><br />abstract class EventHandler {<br />  void handleEvent(type);<br />  get handle;<br />}</pre>The <code>Dispatcher</code> class serves at the interface for the <code>InitiationDispatcher</code> in the <a href="http://www.cs.wustl.edu/~schmidt/PDF/reactor-siemens.pdf">original paper</a>. Similarly, <code>EventHandler</code> has the same structure as the interface in the paper.<br /><br />From there, things got a little more difficult for me—party because Dart is single threaded and already built on the Reactor Pattern but mostly because I still lack a deep understanding of the pattern. In the end, I was able to somewhat demonstrate the pattern with a STDIN <code>KeyHandler</code>:<pre class=prettyprint>main() {<br />  // Create (and register in constructor) event handler<br />  new HandleKey();<br /><br />  // Reactor loop...<br />  for(;;) {<br />    new InitiationDispatcher().handleEvents();<br />  }<br />}</pre>STDIN is a poor way to demonstrate a demultiplexing pattern since only one thing can be sent to it at a time. Also, the simple implementations of STDIN block in Dart, which rather defeats the purpose of the tight event loop. So let's see if I can come up with a more illustrative example.<br /><br />I start by defining <code>select()</code> as a Queue on which I can push “system events”:<pre class=prettyprint>class Select {<br />  static final Select _select = new Select._internal();<br />  factory Select()=> _select;<br />  Select._internal();<br /><br />  Queue<systemevent> queue = new Queue();<br /><br />  void add(String type) { queue.addLast(type); }<br />  SystemEvent fetch() {<br />    if (queue.isEmpty) return null;<br />    return queue.removeFirst();<br />  }<br />}<br /><br /><b>select()=> new Select();</b></pre>The <code>Select</code> class is a singleton, so whenever new stuff is pushed on there, it is pushed onto the same queue. Hopefully this will mimic the <code>system()</code> call built into Linux sufficiently for my purposes.<br /><br />The handles that are read from (and written to) after an OS select have an ID. I again try to mimic that:<pre class=prettyprint>class Handle {<br />  static int nextNumber = 1;<br />  static Map&lt;int,Handle> lookup = {};<br /><br />  int number;<br />  String type;<br />  var stream;<br />  Handle(this.type, this.stream){<br />    number = Handle.nextNumber++;<br />    Handle.lookup[number] = this;<br />  }<br />}</pre>Instead of storing the ID in the operating system, I am storing it in the class itself for later lookup.<br /><br />The other side of the equation is building an “acceptor” and “processor” pair. This is not strictly necessary for demonstrating the Reactor Pattern, but it follows the original paper closely and—hopefully—will help me better understand things.<br /><br />First up the acceptor, which accepts “word” connections:<pre class=prettyprint>class WordAcceptor implements EventHandler {<br />  WordAcceptor() {<br />    new InitiationDispatcher().registerHandler(this, 'word');<br />  }<br /><br />  void handleEvent(event) {<br />    if (event.type != 'word') return;<br />    new WordPrinter(event.handleId);<br />  }<br />  get handle;<br />}</pre>As with other reactor event handlers, it registers itself with the dispatcher and then handles events by create a processor instance—in this case a simple word printer that will print the message to STDOUT. Yes, I am going a long way simply to print things out...<br /><br />The process reads from simple streams:<pre class=prettyprint>class WordPrinter  {<br />  int handleId;<br />  Handle handle;<br /><br />  WordPrinter(this.handleId) {<br />    handle = Handle.lookup[handleId];<br />    read();<br />  }<br /><br /><b>  void read() {<br />    handle.stream.listen((word){<br />      print('[WordPrinter.read] $word');<br />    });<br />  }</b><br />}<br /></pre>Hopefully streams will serve as a nice stand-in for reading from low-level sockets.<br /><br />Finally, I change the reactor loop to listen for “word” connections and start up a message sender:<pre class=prettyprint>main() {<br />  _startRandomMessageSender();<br /><br />  // Create (and register in constructor) event handler<br />  new WordAcceptor();<br /><br />  // Reactor loop...<br />  for(;;) {<br />    new InitiationDispatcher().handleEvents();<br />  }<br />}</pre>But here, I am stumped. <br /><br /><br /><br /><span style="color: #ccc">Day #134</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/the-reactor-pattern-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/aUXck1j62VM" height="1" width="1"/>
