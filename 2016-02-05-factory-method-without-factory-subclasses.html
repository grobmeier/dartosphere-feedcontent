---
title: 'Factory Method without Factory Subclasses'
layout: post
published: '2016-02-05T22:33:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/P0KmCI0_S6o/factory-method-without-factory.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />I am already bored by the <a href="https://en.wikipedia.org/wiki/Factory_method_pattern">factory method pattern</a>. Time for <a href="http://dartlang.org">Dart</a> mirrors! I kid of course. About the bored, not the mirrors. I goes without saying that I'm going to add mirrors.<br /><br />The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> mentions two major varieties of the pattern: one that uses an abstract class, forcing subclasses to define the factory implementations, and the other in which the creator class provides a default factory implementation. I tried the the former last night, so tonight I try with a default implementation. <br /><br />For this example, I adopt the Delphi example on the Wikipedia page, which describes a game factory. For this example, two players want to play a series of games against each other. The creator for that might look like:<pre class=prettyprint>// Creator<br />class GameFactory {<br />  String playerOne, playerTwo;<br />  GameFactory(this.playerOne, this.playerTwo);<br />  String toString() => "*** $playerOne vs. $playerTwo ***";<br /><br />  // The factory method<br />  BoardGame createBoardGame([String game]) {<br />    if (game == 'Checkers') return new CheckersGame();<br />    if (game == 'Thermo Nuclear War') return new ThermoNuclearWar();<br />    return new ChessGame();<br />  }<br />}<br /></pre>The constructor requires the names of both players. Once they are ready to play a game, they might choose a game from a text based listing of games, passing the name to <code>createBoardGame()</code>. In this example, there are no subclasses for the creatorâ€”the <code>GameFactory</code> knows how to create all products. <br /><br />The "products" in this version of the pattern are different board games that can be played in the system. Each will need a list of pieces that can be played:<pre class=prettyprint>// Product<br />class BoardGame {<br />  List playerOnePieces = [];<br />  List playerTwoPieces = [];<br /><br />  String get winner => new Random().nextBool() ? <br />    "Player One" : "Player Two";<br />  String toString() =><br />    "  ${this.runtimeType}\n"<br />    "    Player One has: ${playerOnePieces.join(', ')}\n"<br />    "    Player Two has: ${playerTwoPieces.join(', ')}\n"<br />    "    Winner: $winner\n";<br />}</pre>So a chess game would look like:<pre class=prettyprint>class ChessGame extends BoardGame {<br />  List playerOnePieces = [<br />    '1 king', '1 queen', '2 rooks', '2 bishops', '2 knights', '8 pawns'<br />  ];<br />  List playerTwoPieces = [<br />    '1 king', '1 queen', '2 rooks', '2 bishops', '2 knights', '8 pawns'<br />  ];<br />}</pre>There is some redundancy there, but I will worry about that another time. For now, I have my single creator class and various product classes. Which means that I am ready for some client code.<br /><br />I start with the creator, which starts the game series between two players:<pre class=prettyprint><code>  var series = new GameFactory('Professor Falken', 'Joshua');<br />  print(series);</code></pre>Then they can play various games, choosing each from the text listing on the main menu:<pre class=prettyprint><code>  game = series.createBoardGame('Checkers');<br />  print(game);<br /><br />  game = series.createBoardGame('Thermo Nuclear War');<br />  print(game);<br /><br />  game = series.createBoardGame();<br />  print(game);</code></pre>Running this would result in something like the following output:<pre class=prettyprint>$ ./bin/board_game.dart<br />*** Professor Falken vs. Joshua ***<br />  CheckersGame<br />    Player One has: 12 pieces<br />    Player Two has: 12 pieces<br />    Winner: Player Two<br /><br />  ThermoNuclearWar<br />    Player One has: 1,000 warheads<br />    Player Two has: 1,000 warheads<br />    Winner: None<br /><br />  ChessGame<br />    Player One has: 1 king, 1 queen, 2 rooks, 2 bishops, 2 knights, 8 pawns<br />    Player Two has: 1 king, 1 queen, 2 rooks, 2 bishops, 2 knights, 8 pawns<br />    Winner: Player One<br /></pre>So there you go: a factory method pattern example in which the creator is a concrete class, provided a default product, and can supply all products. It does not feel terribly different from last night's example. In fact, it feels almost too simple to warrant the creator class. Except for the need to remember the two players' names, this could almost be done in client code.<br /><br />I am unsure if this is the example that I would like to use in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> as it is a tad simplistic. Then again, there are some opportunities for improving the code that may make it more illustrative. That's something for tomorrow. Plus mirrors!<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/0018524156ade602d043">https://dartpad.dartlang.org/0018524156ade602d043</a>.</i><br /><br /><br /><span style="color: #ccc">Day #86</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/factory-method-pattern-take-2.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/P0KmCI0_S6o" height="1" width="1" alt=""/>
