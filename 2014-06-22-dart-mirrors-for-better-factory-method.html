---
title: 'Dart Mirrors for Better Factory Method'
layout: post
published: '2014-06-22T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/bHBJerqBTaQ/dart-mirrors-for-better-factor-method.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Today I continue my exploration of the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method</a> for <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. The pattern is a simple enough pattern and I was able to find a ready example in some my own <a href="http://dartlang.org">Dart</a> code last night.<br /><br />Today I would like to explore the specific implementation of the creator class in the pattern. The canonical example from the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> is similar that that I used last night from <a href="https://github.com/eee-c/hipster-mvc">Hipster MVC</a>. The creator class is abstract, expecting the subclass to define the method that creates a <code>HipsterModel</code> instance:<pre class=prettyprint>abstract class HipsterCollection extends IterableBase {<br /><b>  HipsterModel modelMaker(attrs);</b><br />  String get url;<br />  // ...<br />}</pre>A example of concrete creator class comes from <a href="https://github.com/eee-c/dart-comics">Dart Comics</a>, which defines the factory method as:<pre class=prettyprint>class Comics extends HipsterCollection {<br /><b>  modelMaker(attrs) => new ComicBook(attrs);</b><br />  get url => '/comics';<br />}</pre>That is simple enough and a nice example of the pattern. It is especially nice that the example comes from a simpleton's MVC framework, which ought to be accessible for my intended audience. <br /><br />When I first created the Hipster MVC framework, Dart was still in its infancy and there was no way to store and use classes at run-time. The dynamic language part of me was more than a little disappointed, but the Factory Method pattern eased my concerns. A little.<br /><br />Since then, Dart has evolved quite a bit—to the point that is has a <code>dart:mirrors</code> package built into the core language library. Tonight, I would like to use that package to implement the Factory Method pattern using an alternate approach given by the Gang of Four—by storing the class information in the subclass and having the baseclass create new instances from that information.<br /><br />The concrete creator class then becomes something like:<pre class=prettyprint>class Comics extends HipsterCollection {<br />  // modelMaker(attrs) => new ComicBook(attrs);<br /><b>  Type get modelClass => ComicBook;</b><br />  get url => '/comics';<br />}</pre>I like that very much. Perhaps I am too much a dynamic language person at heart, but returning just the class feels better.<br /><br />There is a trade-off, especially in Dart. The resulting abstract creator gets a little more complicated. There is not much left that is abstract—just the concrete instance of <code>HipsterModel</code> that will be used to create instance in the collection. The added complexity comes in the form the no-longer-abstract <code>modelMaker()</code>, which has to obtain a class mirror of the type, and then use that to get an instance of the particular class:<pre class=prettyprint>import 'dart:mirrors';<br />// ...<br />abstract class HipsterCollection extends IterableBase {<br /><b>  Type get modelClass;<br />  HipsterModel modelMaker(attrs) {<br />    ClassMirror modelMirror = reflectClass(modelClass);<br />    return modelMirror.newInstance(const Symbol(''), [attrs]).reflectee;<br />  }</b><br />  String get url;<br />  // ...<br />}</pre>OK, that's not <i>too</i> horrible, but it still requires explanation whereas the abstract Factory Method approach did not.<br /><br />Before jumping into the explanation, there is still a little more cleanup possible. Now that the creator method is in the baseclass, the concrete class no longer needs getter methods. Instead, I can use plain-old instance variables for things like the <code>modelClass</code>:<pre class=prettyprint>class Comics extends HipsterCollection {<br /><b>  Type modelClass = ComicBook;</b><br />  String url = '/comics';<br />}</pre>The base constructor class then looks like:<pre class=prettyprint>abstract class HipsterCollection extends IterableBase {<br />  // ...<br />  Type modelClass;<br />  HipsterModel modelMaker(attrs) {<br />    ClassMirror modelMirror = reflectClass(modelClass);<br />    return modelMirror.newInstance(const Symbol(''), [attrs]).reflectee;<br />  }<br />  String url;<br />  // ...<br />}</pre>That helps, especially since this approach still has a messy <code>modelMaker()</code> factory method. This approach reflects on the current <code>modelClass</code>, which comes from a concrete subclass of <code>HipsterCollection</code> like <code>Comics</code>. In this case, it reflects on the <code>ComicBook</code> class to get a class mirror of that class. To get an instance from that mirror, I use the <code>newInstance()</code> method. That does not return a new instance, but rather an instance mirror. To get the actual instance, I go through the <code>reflectee</code> property.<br /><br />That explanation is relatively clean. The noise comes from the two arguments to the <code>newInstance()</code> method. The first is a symbol… of an empty string. The second is the attributes that will be used to create a <code>ComicBook</code> instance—but wrapped in a list. The second argument is a little easier to explain—it is simply the list of arguments supplied to a constructor. In this case, there is a single argument—the attributes of a <code>ComicBook</code>.<br /><br />More difficult to understand—but with the promise of something useful in the Factory Method pattern—is the first argument to <code>newInstance()</code>. The empty string <code>Symbol</code> is how we tell <code>newInstance()</code> to use the unnamed, default constructor for <code>ComicBook</code>—e.g. <code>new ComicBook({'title': 'Sandman', 'author': 'Neil Gaiman'})</code>. Given that we use this constructor by default, how might “other constructors” be useful in the context of Factory Method?<br /><br />One of the consequences and potential drawbacks of the Factory Method pattern is that it makes code evolution problematic. If the constructor signature needs to change at some point down the line, all of the concrete classes that rely on the current implementation would have to change as well. Or, if the concrete classes require a change, then any other code that relies on the current default constructor would have to change as well. I believe that Dart's named constructors will help with that—and I will explore them tomorrow.<br /><br /><br /><br /><span style="color: #ccc">Day #101</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/06/dart-factory-method-pattern.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/06/named-constructors-in-dart-factory.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/bHBJerqBTaQ" height="1" width="1"/>
