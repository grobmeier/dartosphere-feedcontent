---
title: 'Unboxing Packages: stack_trace'
layout: post
published: '2016-01-12T14:51:00-08:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/01/unboxing-packages-stacktrace.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: ''
tags:
    - 'Unboxing Packages'

---

<p><em>Editor's note: This is the first post in a new series by Natalie going in-depth on Dart packages and how they're used.</em></p> <p>If you’ve written any Dart code at all, you’ve definitely used tools that use the <a href="pub.dartlang.org/packages/stack_trace"><code>stack_trace</code> package</a>. It was originally written for use in pub, and the <code>test</code> package uses it for all the stack traces that tests generate. But you don’t just have to rely on other tools to use it for you—you can use it yourself!</p> <p>The package has three main use-cases, all of which are important and useful. Originally, it was just designed to make existing stack traces prettier and easier to read. A big part of that was parsing stack traces into a data structure, so its secondary purpose became programmatically manipulating stack traces. Then once <a href="https://api.dartlang.org/latest/dart-async/Zone-class.html">zones</a> were created, it added support for tracking stacks across asynchronous calls.</p> <h2 id="making-traces-pretty">Making Traces Pretty</h2> <p>Let’s face it: the Dart VM’s built-in stack traces aren’t nice to look at, and they don’t present information in a way that’s easy for humans to read. Let’s take a look:</p>   <pre class="prettyprint"><code>#0      Object.noSuchMethod (dart:core-patch:1884:25)<br />#1      Trace.terse.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/src/trace.dart:47:21)<br />#2      IterableMixinWorkaround.reduce (dart:collection:29:29)<br />#3      List.reduce (dart:core-patch:1247:42)<br />#4      Trace.terse (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/src/trace.dart:40:35)<br />#5      format (file:///usr/local/google-old/home/goog/dart/dart/pkg/stack_trace/lib/stack_trace.dart:24:28)<br />#6      main.&lt;anonymous closure&gt; (file:///usr/local/google-old/home/goog/dart/dart/test.dart:21:29)<br />#7      _CatchErrorFuture._sendError (dart:async:525:24)<br />#8      _FutureImpl._setErrorWithoutAsyncTrace (dart:async:393:26)<br />#9      _FutureImpl._setError (dart:async:378:31)<br />#10     _ThenFuture._sendValue (dart:async:490:16)<br />#11     _FutureImpl._handleValue.&lt;anonymous closure&gt; (dart:async:349:28)<br />#12     Timer.run.&lt;anonymous closure&gt; (dart:async:2402:21)<br />#13     Timer.Timer.&lt;anonymous closure&gt; (dart:async-patch:15:15)</code></pre> <p>Look at those numbers that don’t add any information. Look at all those lines of internal SDK calls that the user doesn’t care about. Look at those gargantuan absolute file: URLs where relative paths would do. Look how little alignment there is across lines. This is messy. And it’s even worse if you’re compiling to JavaScript; then you have to deal with a bunch of different messy formats!</p> <p>The initial motivation for the stack_trace package was just to print stack traces in a way Bob and I liked to read while we were writing Pub. And it made a huge difference just by aligning columns and making paths relative:</p> <pre class="prettyprint"><code>dart:core-patch 1884:25                     Object.noSuchMethod<br />pkg/stack_trace/lib/src/trace.dart 47:21    Trace.terse.&lt;fn&gt;<br />dart:collection 29:29                       IterableMixinWorkaround.reduce<br />dart:core-patch 1247:42                     List.reduce<br />pkg/stack_trace/lib/src/trace.dart 40:35    Trace.terse<br />pkg/stack_trace/lib/stack_trace.dart 24:28  format<br />test.dart 21:29                             main.&lt;fn&gt;<br />dart:async 525:24                           _CatchErrorFuture._sendError<br />dart:async 393:26                           _FutureImpl._setErrorWithoutAsyncTrace<br />dart:async 378:31                           _FutureImpl._setError<br />dart:async 490:16                           _ThenFuture._sendValue<br />dart:async 349:28                           _FutureImpl._handleValue.&lt;fn&gt;<br />dart:async 2402:21                          Timer.run.&lt;fn&gt;<br />dart:async-patch 15:15                      Timer.Timer.&lt;fn&gt;</code></pre> <p>Let’s take this opportunity to jump into some code. The <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Trace-class.html"><code>Trace</code></a> class is how the package represents a full stack trace. It can be parsed from any supported platform’s stack trace using <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Trace/Trace.parse.html"><code>new Trace.parse()</code></a>—<code>stack_trace</code> knows how to parse its own format, the Dart VM’s, and that of every browser Dart supports. If you know the platform you’re parsing for, you can also use platform-specific constructors like <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Trace/Trace.parseFirefox.html"><code>new Trace.parseFirefox()</code></a>. Once you have a <code>Trace</code>, all you need to do is call <code>toString()</code> to get the nice, clean stack format.</p>  <pre class="prettyprint prettyprinted" style=""><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">"package:stack_trace/stack_trace.dart"</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="com">// Throw an error so we have a stack trace to work with.</span><span class="pln"><br />  </span><span class="kwd">try</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">throw</span><span class="pln"> </span><span class="str">''</span><span class="pun">;</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"> </span><span class="kwd">catch</span><span class="pln"> </span><span class="pun">(</span><span class="pln">error</span><span class="pun">,</span><span class="pln"> stackTrace</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="com">// Parse the trace from the StackTrace object. This works on the VM and on</span><span class="pln"><br />    </span><span class="com">// any supported browser.</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> trace </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Trace</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">stackTrace</span><span class="pun">);</span><span class="pln"><br /><br />    </span><span class="com">// Print the stack trace in its pretty format.</span><span class="pln"><br />    </span><span class="kwd">print</span><span class="pun">(</span><span class="pln">trace</span><span class="pun">);</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>  <p>Once you have a <code>Trace</code>, there’s even more you can do to clean it up. Most of the time, users only care about the internal workings of packages that they’re actually responsible for—they don’t care that <code>List.reduce()</code> called <code>IterableMixinWorkaround.reduce()</code>, they just care that somehow <code>dart:core</code> got from <code>List.reduce()</code> to their callback.</p> <p>To address this, <code>stack_trace</code> has a notion of “folding” a <code>Trace</code>. This removes most of the stack frames that are considered irrelevant. It leaves only the ones immediately after relevant frames, since the user does care that their function called <code>List.reduce()</code> even if they don’t care what that called. Call <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Trace/foldFrames.html"><code>Trace.foldFrames()</code></a> to return a folded <code>Trace</code>, passing in a predicate that returns whether or not a line is relevant:</p> <pre class="prettyprint prettyprinted" style=""><code class="language-dart"><span class="com">// Fold all the core library frames and frames from the test package.</span><span class="pln"><br />trace </span><span class="pun">=</span><span class="pln"> trace</span><span class="pun">.</span><span class="pln">foldFrames</span><span class="pun">((</span><span class="pln">frame</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> frame</span><span class="pun">.</span><span class="pln">isCore </span><span class="pun">||</span><span class="pln"> frame</span><span class="pun">.</span><span class="kwd">package</span><span class="pln"> </span><span class="pun">==</span><span class="pln"> </span><span class="str">'test'</span><span class="pun">);</span></code></pre> <p>There’s also a built-in <code>Trace.terse</code> getter that folds together frames from the core libraries and the <code>stack_trace</code> package itself. It also does some bonus cleanup: it’ll clean up core library frames by getting rid of individual library names and line numbers, and it’ll remove the initial chunk of core frames that represent internal event loop junk. You can also get those bonuses by passing <code>terse: true</code> to <code>foldFrames()</code>.</p> <p>Here’s the terse version of the stack trace above:</p>   <pre class="prettyprint"><code>dart:core                                   Object.noSuchMethod<br />pkg/stack_trace/lib/src/trace.dart 47:21    Trace.terse.&lt;fn&gt;<br />dart:core                                   List.reduce<br />pkg/stack_trace/lib/src/trace.dart 40:35    Trace.terse<br />pkg/stack_trace/lib/stack_trace.dart 24:28  format<br />test.dart 21:29                             main.&lt;fn&gt;</code></pre> <p>Gorgeous! Removing all of that extra text lets the user focus only on their code and the code it calls.</p>   <h2 id="parsing-and-manipulating-traces">Parsing and Manipulating Traces</h2> <p>There’s more to stack traces than just printing them out nicely, though. A <code>Trace</code>, and the <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame-class.html"><code>Frame</code></a>s it contains, makes it possible to inspect all the data encoded in a stack trace. You can get at all the information that’s directly included in the original trace via getters like <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/uri.html"><code>Frame.uri</code></a>, <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/member.html"><code>Frame.member</code></a>, <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/line.html"><code>Frame.line</code></a>, and <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/column.html"><code>Frame.column</code></a>.</p> <p>There are also derived getters that build in some logic for extracting common information. <a href="https://www.dartdocs.org/documentation/stack_trace/1.5.1/stack_trace/Frame/package.html"><code>Frame.package</code></a>, for example, returns the name of the package for <code>package:</code> URI frames, and returns null for any other frame. <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/isCore.html"><code>Frame.isCore</code></a> is true for core library frames. <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/library.html"><code>Frame.library</code></a> is a more human-readable version of <code>Frame.uri</code>, and <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/location.html"><code>Frame.location</code></a> is a human-readable combination of the URI, line, and column.</p> <p>You can also create your own stack traces from scratch using the <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Frame/Frame.html"><code>new Frame()</code></a> and <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Trace/Trace.html"><code>new Trace()</code></a> constructors. This ability is put to good use by the <a href="https://pub.dartlang.org/packages/source_map_stack_trace"><code>source_map_stack_trace</code></a> package, which uses a source map produced by dart2js to convert a browser’s stack trace into one that has Dart files and line numbers. Here’s an excerpt of how it uses <code>stack_trace</code>:</p>   <pre class="prettyprint prettyprinted" style=""><code class="language-dart"><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Trace</span><span class="pun">(</span><span class="pln">trace</span><span class="pun">.</span><span class="pln">frames</span><span class="pun">.</span><span class="pln">map</span><span class="pun">((</span><span class="pln">frame</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="com">// ...</span><span class="pln"><br /><br />  </span><span class="kwd">return</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">Frame</span><span class="pun">(</span><span class="pln"><br />      </span><span class="typ">Uri</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">sourceUrl</span><span class="pun">),</span><span class="pln"><br />      span</span><span class="pun">.</span><span class="pln">start</span><span class="pun">.</span><span class="pln">line </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"><br />      span</span><span class="pun">.</span><span class="pln">start</span><span class="pun">.</span><span class="pln">column </span><span class="pun">+</span><span class="pln"> </span><span class="lit">1</span><span class="pun">,</span><span class="pln"><br />      minified<br />          </span><span class="pun">?</span><span class="pln"> </span><span class="pun">(</span><span class="pln">span</span><span class="pun">.</span><span class="pln">isIdentifier </span><span class="pun">?</span><span class="pln"> span</span><span class="pun">.</span><span class="pln">text </span><span class="pun">:</span><span class="pln"> frame</span><span class="pun">.</span><span class="pln">member</span><span class="pun">)</span><span class="pln"><br />          </span><span class="pun">:</span><span class="pln"> _prettifyMember</span><span class="pun">(</span><span class="pln">frame</span><span class="pun">.</span><span class="pln">member</span><span class="pun">));</span><span class="pln"><br /></span><span class="pun">}).</span><span class="kwd">where</span><span class="pun">((</span><span class="pln">frame</span><span class="pun">)</span><span class="pln"> </span><span class="pun">=&gt;</span><span class="pln"> frame </span><span class="pun">!=</span><span class="pln"> </span><span class="kwd">null</span><span class="pun">));</span></code></pre>    <h2 id="asynchronous-stack-chains">Asynchronous Stack Chains</h2> <p>Writing asynchronous code is tough. Lots of stuff is happening in disconnected bursts without strong guarantees about ordering, and it can be really hard to figure out what’s happening where and why. You may have to think in four dimensions to understand your program flow in its entirely, but at least the stack_trace package can help you out with the <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Chain-class.html"><code>Chain</code></a> class.</p> <p>Whether you’re running on the Dart VM or on a browser, the implementation’s notion of a stack isn’t all that useful in heavily-asynchronous code. It just includes frames from somewhere inside the DOM or <code>dart:async</code> to your callback, without any further context. In order to know what’s really going on, you’d need to know what the stack was when the callback was registered. And if it was registered in another callback, you’d need the stack before that, and so on.</p> <p>That’s what a stack chain describes: a list of stack traces that, together, shows how you got from <code>main()</code> to wherever the stack was captured. And as you’d expect, a <code>Chain</code> object simply contains a list of <code>Traces</code>. The real magic is in how you get these chains: The <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Chain/capture.html"><code>Chain.capture()</code></a> static method.</p>  <pre class="prettyprint prettyprinted" style=""><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">'package:stack_trace/stack_trace.dart'</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="kwd">void</span><span class="pln"> main</span><span class="pun">()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">Chain</span><span class="pun">.</span><span class="pln">capture</span><span class="pun">(()</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="com">// Your program goes here.</span><span class="pln"><br />  </span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>That’s the easiest way to use <code>Chain.capture()</code>: just wrap it around your entire program. Any errors that cause your program to exit will have their entire stack chains printed. Here’s an example of what that looks like (with <a href="https://www.dartdocs.org/documentation/stack_trace/1.5.1/stack_trace/Chain/terse.html"><code>Chain.terse</code></a> called, of course):</p>   <pre class="prettyprint"><code>test.dart 17:3       runAsync<br />test.dart 13:28      scheduleAsync.&lt;fn&gt;<br />===== asynchronous gap ===========================<br />dart:async           _Future.then<br />test.dart 13:12      scheduleAsync<br />test.dart 7:18       main.&lt;fn&gt;<br />package:stack_trace  Chain.capture<br />test.dart 6:16       main</code></pre> <p>That “asynchronous gap” is where one stack trace ends and the next begins. Here’s how you read it: <code>main()</code> called a bunch of stuff that eventually terminated in a call to <code>Future.then()</code>. Then once that future fired, it ran the callback in <code>scheduleAsync()</code> that called <code>runAsync()</code>. If the future had fired synchronously, the stack would look the same, just without the gap.</p> <p>I called this “magic” earlier, but it’s actually possible to understand how it works. It’s based on Dart’s notion of zones, which you can read about in detail <a href="https://www.dartlang.org/articles/zones/">elsewhere</a>. For our purposes, you just need to know that a custom zone lets us add extra behavior to async stuff, and that it’s active in its callback, any callbacks its callback registers, and so forth. Let’s call the zone <code>Chain.capture()</code> creates the capture zone.</p> <p>The capture zone keeps track of a tree of stack traces. Each callback is associated with a particular node on that tree, and when that callback runs, the zone remembers its node. If the current callback registers a new callback, a new node—containing the current stack trace—is added as a child of the current node and associated with the new callback. And when an error occurs, we just add its stack trace to the current node’s stack chain to get a <code>Chain</code> object, which we associate with the trace that produced it.</p> <p>This scheme lets us provide two important APIs. Because we have a chain associated with every trace, we can get the chain for a specific trace with <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Chain/Chain.forTrace.html"><code>new Chain.forTrace()</code></a> constructor. This returns a full chain for any stack trace created in the capture zone, and for consistency it will even wrap stack traces in a <code>Chain</code> outside the zone (although it won’t provide any extra information).</p> <p>Also, because we always know the current node in the tree of traces, we can get the current stack chain with <a href="https://www.dartdocs.org/documentation/stack_trace/latest/stack_trace/Chain/Chain.current.html"><code>new Chain.current()</code></a>. This is useful for simple tasks like printing the current chain while debugging, but it also lets packages like <a href="https://pub.dartlang.org/packages/scheduled_test"><code>scheduled_test</code></a> store stack chains for use in future debugging. To suit the latter use case, you can pass in a number of frames to cut off from the bottom so users don’t see the library’s capturing function in their nice pristine stacks.</p> <p>Since the stack chain capture zone stores a node for every registered callback, you might be thinking that it’s pretty performance-intensive. In practice, it’s less of a drag than it seems like it would be—partly because it’s set up so that nodes that can’t possibly be used are garbage-collected—but it’s definitely not something you want to leave on in production. That’s why <code>Chain.capture()</code> has a <code>when</code> parameter: just pass in false when you’re running in production mode, and all capturing is disabled.</p>   <h2 id="trace-your-stacks">Trace Your Stacks</h2> <p>Whether you go off and build a powerful stack trace processor or just start wrapping your <code>main()</code>s in <code>Chain.capture()</code>, you should be using <code>stack_trace</code>. No matter how good of a programmer someone might be, errors do happen, and stack traces are the most straightforward tool we have for understanding what’s going on. You’ll have to work with them one way or another—do yourself a favor and do it in comfort and style.</p>
