---
title: 'A Naming Convention for Dart Isolate Ports'
layout: post
published: '2016-01-18T22:28:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/yeJj9m2bb7c/a-naming-convention-for-dart-isolate.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - isolates
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />I still can't <a href="https://api.dartlang.org/1.13.2/dart-isolate/dart-isolate-library.html">isolate</a>. Well, I can create isolate workers in <a href="http://dartlang.org">Dart</a>, but they feel incredibly awkward to use to support programming discussions. I may give up on them, but I'd like at least one more shot at them.<br /><br />On the face of it, communication between the main entry point and a worker is fairly simple:<br /><br /><a href="http://4.bp.blogspot.com/-R2QONhUI4-A/Vp3CyJ8c9rI/AAAAAAABDoI/0ZNUY4FVUjg/s1600/isolate_ports.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-R2QONhUI4-A/Vp3CyJ8c9rI/AAAAAAABDoI/0ZNUY4FVUjg/s640/isolate_ports.png" width=570 /></a><br /><br />Main sends messages from its send-port to the receive-port in the worker. The worker uses its own send-port to send messages to the receive-port back in main. Simple, right? Yes and no.<br /><br />From the above diagram, you might think that main's receive-port is created last:<ol><li>first you need a send-port to send to the worker</li><li>second, the worker needs a receive port to listen for those messages</li><li>third, the worker needs a send-port to send back to main</li><li>last, main needs the receive port to listen for messages from worker</li></ol>In reality, Dart receive-ports are created first. A send-port is just a property of the receive-port. As a property of a receive-port, the send-port is already linked for communication, the challenge is then to get main's receive-port send-port to the worker and vice-versa. <br /><br /><blockquote>Side-note: sentences like the last one are probably why I will not be able to use isolates in discussions like remote proxy patterns. It makes sense if you noodle it through, but readers should expend cognitive load on the main discussion, not the apparatus for the discussion. Anyway, onward... <br /></blockquote><br />To create an isolate worker, the main entry point first creates its receive-port (with associated send-port). It then spawns the worker sending along the associated send-port at the same time:<br /><br /><a href="http://4.bp.blogspot.com/-xlLigj41uno/Vp3IbkFUIiI/AAAAAAABDos/ZHNM0-TgZFo/s1600/isolate_creating_worker.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-xlLigj41uno/Vp3IbkFUIiI/AAAAAAABDos/ZHNM0-TgZFo/s640/isolate_creating_worker.png" width=570 /></a><br /><br />At this point, the worker can send all the messages it likes back to the main worker, but main has no way to communicate back to worker. In many cases this is just fine. In many of the examples that I want to use, however, this is insufficient. To allow main to communicate with worker, worker has to create its own receive-port and supply the associated send-port back to main. There is only one way to do so—back through main's send-port:<br /><br /><a href="http://3.bp.blogspot.com/-iaHSPTfqXNo/Vp3IbrttduI/AAAAAAABDoo/tupkv31_cus/s1600/isolate_create_bidirectional.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-iaHSPTfqXNo/Vp3IbrttduI/AAAAAAABDoo/tupkv31_cus/s640/isolate_create_bidirectional.png" width=570 /></a><br /><br />All of this makes perfect sense. I understand the tradeoffs involved. I understand how to set it up. I cannot think of better names than "ports" for these beasties. But the end result is that I have to send a send-port over a send-port in order to establish worker's receive-port. And all I really want is to discuss the proxy pattern, darn it.<br /><br />I am unsure how to proceed at this point. It seems like a higher level library is in order, but then I have a library just for teaching purposes. Maybe that is what I will wind up doing in the end. First though, I am going to experiment with a worker-centric naming convention to see if it helps the actual code.<br /><br />So, in worker, I will refer to the send-port (which comes from main) as "worker-out." Back in main, that same send-port will be associated with "main-in":<br /><br /><a href="http://3.bp.blogspot.com/-xu-m_lwUIzE/Vp3CyHgvahI/AAAAAAABDoM/VqWq-G780mo/s1600/isolate_ports_alt_names.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-xu-m_lwUIzE/Vp3CyHgvahI/AAAAAAABDoM/VqWq-G780mo/s640/isolate_ports_alt_names.png" width=570 /></a><br /><br />To make that happen, I start in <code>main()</code> by creating my <code>mainIn</code> receive-port, then sending its <code>sendPort</code> to <code>worker()</code> when it is spawned:<pre class=prettyprint>main() async {<br />  var mainIn = new ReceivePort();<br />  await Isolate.spawn(worker, mainIn.sendPort);<br />  // ...<br />}</pre>(I am using the <a href="https://www.dartlang.org/articles/await-async/">async / await</a> syntactic sugar for Dart futures here)<br /><br />So far, so good. I have a good handle on what <code>mainIn</code> is. Previously, I had called that <code>receivePort</code> or just <code>r</code>—by the time I was looking inside worker, I was easily confused. Hopefully this naming convention will serve me better.<br /><br />Then, down in the <code>worker()</code> that is being spawned, I accept main's <code>mainIn.sendPort</code>, assigning it locally as <code>workerOut</code>:<pre class=prettyprint>worker(SendPort workerOut) {<br />  // ...<br />}</pre>At the risk of being redundant, from main's perspective, this is <code>mainIn.sendPort</code>. From worker's perspective, that same thing is <code>workerOut</code>. I think that works. <br /><br />Now I need a <code>workerIn</code>, which is a receive-port and I need to send it back to main:<pre class=prettyprint>worker(SendPort workerOut) {<br />  var workerIn = new ReceivePort();<br />  workerOut.send(workerIn.sendPort);<br />  // ...<br />}</pre>Lastly, back in main, I need to accept that first message and assign it as <code>mainOut</code>. I cannot just ask <code>mainIn</code> for the first message because that has the side-effect of closing the stream and all of this bi-directional communication setup would be for naught. Instead, I convert <code>mainIn</code> from a receive-port to a broadcast stream using the <code>asBroadcastStream()</code> method:<pre class=prettyprint>main() async {<br />  var mainIn = new ReceivePort();<br />  await Isolate.spawn(worker, mainIn.sendPort);<br /><br />  var inStream = mainIn.asBroadcastStream();<br />  SendPort mainOut = await inStream.first;<br />  // ...<br />}</pre>With that, I can still listen to <code>inStream</code> for additional communication—even after I have <code>mainOut</code>. Conceptually, this winds up looking something like:<br /><br /><a href="http://1.bp.blogspot.com/-sXhVNy9ekIU/Vp3CyMXXz0I/AAAAAAABDoQ/LFynSblc-SQ/s1600/isolates_as_broadcast_streams.png" imageanchor="1" ><img border="0" src="http://1.bp.blogspot.com/-sXhVNy9ekIU/Vp3CyMXXz0I/AAAAAAABDoQ/LFynSblc-SQ/s640/isolates_as_broadcast_streams.png" width=570 /></a><br /><br />I think I am OK with that. Renaming the ports after the context seems to help clear up most of my confusion. I will likely adopt this approach in future isolate code. That said, I remain unconvinced that this is clear enough for something like <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. I may try my hand at a high-level, simple library. I believe that I have already searched for one, but I may also check to see if any existing libraries might suit my needs.<br /><br />Grist for tomorrow...<br /><br /><br /><span style="color: #ccc">Day #68</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/proxies-dont-always-need-to-know.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/faking-dart-isolates-for-proxy-pattern.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/yeJj9m2bb7c" height="1" width="1" alt=""/>
