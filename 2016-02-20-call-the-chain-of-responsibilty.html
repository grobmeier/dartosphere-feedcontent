---
title: 'Call the Chain of Responsibilty'
layout: post
published: '2016-02-20T21:44:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/wiZvy9S2v2g/call-chain-of-responsibilty.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - 'chain of responsibility pattern'
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Design patterns are pretty boring. Experimenting with design patterns? That's where the fun is!<br /><br />While messing about with spreadsheet formatting objects (e.g. date, text, numeric), it occurred to me that there might be a <a href="http://dartlang.org">Dartier</a> (cooler) solution than what I am currently using:<pre class=prettyprint>abstract class CellFormatter {<br />  CellFormatter nextHandler;<br /><br />  void processRequest(Event e) {<br />    if (handleRequest(e)) return;<br />    if (nextHandler == null) return;<br /><br />    nextHandler.processRequest(e);<br />  }<br /><br />  // Subclasses handle requests as needed<br />  bool _handleRequest(Event e) => false;<br />  // ...<br />}</pre>In this handler, I am both implementing and connecting the successors. The <code>nextHandler</code> property points to the next object in the chain. The <code>processRequest()</code> method is responsible for sending requests to that next object when the current object opts against handling the request (e.g. when a number formatter sees text in a cell). <br /><br />There is nothing wrong with this approach, but I have a nagging dislike for the naming convention that I have here. One method is called <code>processRequest()</code> and the other is <code>_handleRequest()</code>. "Process" and "handle" both have similar meanings so it takes a little extra noodling here to understand what is happening. Since <code>processRequest()</code> is public, that is a good indication that it is the public interface to the chain. Less obvious is that <code>processRequest()</code> is responsible for connecting to the successor whereas the <code>_handleRequest()</code> is meant solely for subclasses to actually handle the request.<br /><br />The main problem here is the dual nature of <code>processRequest()</code>. To the outside world, it is… processing the request, so it is well-named in that respect. Actually looking at the code, however, it serves the different purpose of linking successors. And naming <code>_handleRequest()</code> as I have only adds to the confusion. This is not horrible, but I can do better.<br /><br />Perhaps renaming <code>processRequest()</code> as just <code>process()</code> will help. To the outside world, it retains a similar connotation. Inside the code, it seems more distinct from <code>_handleRequest()</code>. Or maybe…<br /><br />I can rename it as <code>call()</code>.<br /><br />The beautiful thing about a method named <code>call()</code> in Dart is that automatically makes the current class into a function. That means that I can continue sending the request to the chain successor as with <code>nextHandler.call(e)</code> or I can treat <code>nextHandler</code> as a function itself, <code>nextHandler(e)</code>:<pre class=prettyprint>abstract class CellFormatter {<br />  CellFormatter nextHandler;<br /><br />  void call(Event e) {<br />    if (_handleRequest(e)) return;<br />    if (nextHandler == null) return;<br /><br />    nextHandler(e);<br />  }<br />  // ...<br />}</pre>And, since the <code>call()</code> happens to have the correct signature for event listeners, I can supply the first object in the chain directly to the on-change listener:<pre class=prettyprint><code>  var textFormat = new TextFormatter();<br />  var dateFormat = new DateFormatter(textFormat);<br />  var numberFormat = new NumberFormatter(dateFormat);<br /><br />  container.onChange.listen(numberFormat);</code></pre><i>That</i> reads much better—and it wasn't horrible to begin with! When the container sees a change event, it number formats the appropriate cell. The class code is similarly clear: when called, it either handles the request or calls the next successor. Wonderful!<br /><br />I had thought about moving on from last night's "good enough" chain of responsibility. I am certainly glad I opted to linger a bit longer, this was a nice win. I do wonder if this is the gods' way of telling me to linger more often. Or maybe to <code>call()</code> more often. I'm sure one of those is the moral of this story.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/f5bbc86a28002987741c">https://dartpad.dartlang.org/f5bbc86a28002987741c</a>.</i><br /><br /><br /><span style="color: #ccc">Day #101</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/consequences-of-chain-of-responsibility.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/02/a-facade-for-chain-of-responsibility.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/wiZvy9S2v2g" height="1" width="1" alt=""/>
