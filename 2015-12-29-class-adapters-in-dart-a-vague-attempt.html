---
title: 'Class Adapters in Dart: A Vague Attempt'
layout: post
published: '2015-12-29T22:37:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/7woTJweveRg/class-adapters-in-dart-vague-attempt.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - 'adapter pattern'
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />Time to pick another pattern to explore in <a href="http://dartlang.org">Dart</a>. Up today, the <a href="https://en.wikipedia.org/wiki/Adapter_pattern">adapter pattern</a>, a nice structural pattern as a change of pace from the behavioral ones that I have been exploring. <br /><br />This is unique among the pattern in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> in that it has both class and object implementations described in the book. I should start with the object implementation because I think I understand how to implement it already. But where's the fun in that?<br /><br />I am going to stick with abstract class names to get started. The <code>Adaptee</code> is the class that needs to be adapted to support an alternate interface. It would typically exist in a separate library since I could change it if it existed in a library that I could alter. Let's start with:<pre class=prettyprint>library adaptee;<br /><br />class Adaptee {<br />  void specificRequest() {<br />    print("[Adaptee] A specific request.");<br />  }<br />}</pre>Next, I have the interface that I need to support in the form of a <code>Target</code> class:<pre class=prettyprint>library adapter;<br /><br />import 'adaptee.dart';<br /><br />class Target {<br />  void request() {<br />    print("[Target] A request.");<br />  }<br />}</pre>Presumably, I have a bunch of classes in this library that implement this interface. Now I need an adapter class that implements this interface, but still allows access to the methods in <code>Adaptee</code>. The class adapter approach used in the Gang of Four book uses multiple inheritance: public for the target interface and private for the adaptee interface. Dart does not support multiple inheritance (public or private). It supports multiple interface implementations, but that does not give me access to methods in both the target and adaptee. <br /><br />I could try mixins—extending (subclassing) the target and mixing in the adaptee:<pre class=prettyprint>class Adapter extends Target with Adaptee {<br />  void request() {<br />    print("[Adapter] doing stuff..");<br />    specificRequest();<br />  }<br />}</pre>That works... to a point. If I create an instance of the adapter in client code then access the <code>request()</code> method from the target:<pre class=prettyprint>main() {<br />  var adapter = new Adapter();<br />  adapter.request();<br />}</pre>Then I get my desired output—the adapter <code>request()</code> method executes and then invokes <code>specificRequest()</code> from the adaptee:<pre class=prettyprint>$ ./bin/adapt.dart<br />[Adapter] doing stuff..<br />[Adaptee] A specific request.</pre>There are two problems with this approach. First the adaptee's methods are now available publicly on the adapter:<pre class=prettyprint>main() {<br />  var adapter = new Adapter();<br />  adapter.request();<br />  // Can access adaptee methods from client code:<br />  adapter.specificRequest();<br />}</pre>Which results in:<pre class=prettyprint>$ ./bin/adapt.dart<br />[Adapter] doing stuff..<br />[Adaptee] A specific request.<br />[Adaptee] A specific request.</pre>The second problem is more serious. This will only work if the adaptee does not declare a constructor. If it does:<pre class=prettyprint>class Adaptee {<br />  Adaptee() { print("Adaptee!"); }<br />  void specificRequest() {<br />    print("[Adaptee] A specific request.");<br />  }<br />}</pre>Then I get a warning:<pre class=prettyprint>[error] The class 'Adaptee' cannot be used as a mixin because it declares a constructor</pre>Worse, I get runtime error:<pre class=prettyprint>$ ./bin/adapt.dart                                  <br />'package:adapter_code/adapter.dart': error: line 9 pos 35: mixin class 'Adaptee' must not have constructors<br /><br />class Adapter extends Target with Adaptee {<br />                                  ^</pre>In other words, this will not fly in all but extremely limited circumstances. <br /><br />In the end, the best approach that I can think of is to implement the target interface and subclass the adaptee:<pre class=prettyprint>class Adapter extends Adaptee implements Target {<br />  void request() {<br />    print("[Adapter] doing stuff..");<br />    specificRequest();<br />  }<br />}</pre>This is not ideal since the adaptee's <code>specificRequest()</code> is still public on the adapter class. If I really, really needed a class adapter, this might serve in a pinch.<br /><br />That said, it seems like an object adapter is the only real option in Dart, so I will get to that tomorrow.<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/ee43829831bffb807350">https://dartpad.dartlang.org/ee43829831bffb807350</a>.</i><br /><br /><br /><span style="color: #ccc">Day #48</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/undoable-undo-commands-and-singularity.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/7woTJweveRg" height="1" width="1" alt=""/>
