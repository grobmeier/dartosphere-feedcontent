---
title: 'TDD a Polymer (Dart) Form Element '
layout: post
published: '2014-11-27T23:59:00-05:00'
feed: 'japh(r) by Chris Strom'
link: //feedproxy.google.com/~r/JaphrByChrisStrom/~3/V3ydLTkekmw/tdd-polymer-dart-form-element.html
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - polymer
    - tdd
    - testing

---

<div class=top-chain-links></div><br />After last night, I am leaning toward being bad. Well, not too bad, but I have given up on trying to implement custom <a href="http://www.polymer-project.org/">Polymer</a> form elements the right way. Instead I begin to think the best approach is to break encapsulation of Polymer elements so that they can inject hidden <code>&lt;input></code> elements into the containing document containing the necessary data.<br /><br />I am not entirely sure how this is going to work in practice, but I think I can describe some of the functionality as:<pre class=prettyprint><code>  var _el, _form, _container;<br />  group("&lt;x-pizza>", (){<br />    setUp((){ /* ... */ });<br />    group('acts like &lt;input>', (){<br /><b>      test('value property is updated when internal state changes', (){});<br />      test('value attribute is updated when internal state changes', (){});<br />      test('containing form includes input with supplied name attribute', (){});</b><br /><br />      test('setting the value property updates the value attribute', (){});<br />      test('setting the name property updates the name attribute', (){});<br />    });<br />  });</code></pre>Most of those come for free from Polymer. In the <code>&lt;input></code> group, I setup as follows:<pre class=prettyprint><code>    group('acts like &lt;input>', (){<br />      setUp((){<br />        _el.name = 'my_field_name';<br />        _el.model.firstHalfToppings.add('pepperoni');<br /><br />        var completer = new Completer();<br />        _el.async(completer.complete);<br />        return completer.future;<br />      });<br />      // Tests here...<br />    });</code></pre>This setup is mostly from last night. It sets the name of the "input" and updates the internal state such that my <code>&lt;x-pizza></code> element has pepperoni on the first half. The completer dance around Polymer's <code>async()</code> ensures that the following tests will not run until Polymer has updated the internal state of my custom element. <br /><br />The first two tests just work™:<pre class=prettyprint><code>  var _el, _form, _container;<br />  group("&lt;x-pizza>", (){<br />    setUp((){ /* ... */ });<br />    group('acts like &lt;input>', (){<br /><b>      test('value property is updated when internal state changes', (){<br />        expect(<br />          _el.value,<br />          startsWith('First Half: [pepperoni]')<br />        );<br />      });<br />      test('value attribute is updated when internal state changes', (){<br />        expect(<br />          _el.getAttribute('value'),<br />          startsWith('First Half: [pepperoni]')<br />        );<br />      });</b><br />      // More tests...<br />    });<br />  });</code></pre>There is not much test driven development in this case. All that <code>&lt;x-pizza></code> needs is published, reflectable properties:<pre class=prettyprint>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br /><b>  @PublishedProperty(reflect: true)<br />  String name;<br /><br />  @PublishedProperty(reflect: true)<br />  String value;</b><br /><br />  updatePizzaState([_]) {<br />    value = 'First Half: ${model.firstHalfToppings}\n'<br />      'Second Half: ${model.secondHalfToppings}\n'<br />      'Whole: ${model.wholeToppings}';<br />    // ...<br />  }<br />  // ...<br />}<br /></pre>The next test is a little trickier mostly because Dart lacks the normal <code>elements</code> property on <code>&lt;form></code> elements. So instead of iterating across all form elements, I have to hack an approximation for it:<pre class=prettyprint><code>  var _el, _form, _container;<br />  group("&lt;x-pizza>", (){<br />    setUp((){ /* ... */ });<br />    group('acts like &lt;input>', (){<br />      setUp((){<br /><b>        _el.name = 'my_field_name';</b><br />        // ...<br />      });<br />      // ...<br /><b>      test('containing form includes input with supplied name attribute', (){<br />        var inputNames = _form.<br />          children.<br />          where((i)=> i.tagName == 'INPUT').<br />          map((i)=> i.name);<br />        expect(inputNames, contains('my_field_name'));<br />      });</b><br />    });<br />  });</code></pre>Happily the test turns out to be the hardest part of this because updating the <code>&lt;input></code> that is injected into the light DOM is as easy as updating the element from last night when attributes change:<pre class=prettyprint><code>@CustomTag('x-pizza')<br />class XPizza extends PolymerElement {<br />  // ...<br />  Element lightInput;<br />  // ...<br /><b>  void attributeChanged(String name, String oldValue, String newValue) {<br />    if (name == 'name') {<br />      lightInput.name = newValue;<br />    }</b><br />  }<br />  // ...<br />}</code></pre>With that, I have my <code>&lt;x-pizza></code> Polymer element approximating the behavior of a native form element. I am likely overlooking an edge case or two—ah, who I am kidding? This is HTML so I am certainly missing at least a score of edge cases. Still, as proofs of concepts go, this seems reasonable to me. I can create custom Polymer elements that will work as expected with native <code>&lt;form></code> elements. I should double check that this works in JavaScript (where I'll have access to <code>form.elements</code>). That aside this is definitely promising. <br /><br /><br /><span style="color: #ccc">Day #7</span><br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/11/native-form-inputs-with-polymer.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/11/extracting-polymer-behaviors-from.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="//feeds.feedburner.com/~r/JaphrByChrisStrom/~4/V3ydLTkekmw" height="1" width="1" alt=""/>
