---
title: 'Remote Proxy Pattern and Dart Isolates'
layout: post
published: '2016-01-11T23:57:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/FIOrdB4lzBw/remote-proxy-pattern-and-dart-isolates.html'
author:
    name: Anonymous
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/00135361916531185929'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - isolates
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />It seemed like a good idea at the time.<br /><br />I would like to experiment with remote proxy implementations of the <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> in <a href="http://dartlang.org">Dart</a>. You know what might work for that? Dart <a href="https://api.dartlang.org/1.13.2/dart-isolate/dart-isolate-library.html">isolates</a>. Well, probably not, but it seems like a good idea...<br /><br />I start by simplifying the <code>Car</code> class, which will serve as the real subject in the pattern, to just an <code>automobile</code> that can drive, stop, and report state:<pre class=prettyprint>// Real Subject<br />class Car implements Automobile {<br />  String state = 'idle';<br />  void drive() { state = 'driving'; }<br />  void stop()  { state = 'idle'; }<br />}<br /></pre>The proxy subject will then be tasked with communicating with the real subject across isolates. I am unsure exactly how that is going to work, but the proxy subject will need a <code>SendPort</code>, at the very least, to request the real car update itself. So I start with:<pre class=prettyprint>// Proxy Subject<br />class ProxyCar implements Automobile {<br />  SendPort _s;<br />  String _state = "???";<br /><br />  String get state => _state;<br />  void drive() { _s.send(#drive); }<br />  void stop() { _s.send(#stop); }<br />}</pre>Where the <code>SendPort</code> comes from and how the <code>_state</code> private instance variable gets updated are questions that I will try to answer in a bit.<br /><br />First, I want to establish the other isolate to which the main thread will talk. Like all isolates, I need to accept a <code>SendPort</code> through which it can send information back to the main thread. And I am pretty sure that I need for the main thread to be able to send information to the isolate, so the first thing I do is create a <code>ReceivePort</code> that I can send back:<pre class=prettyprint>other(SendPort s) {<br />  var r = new ReceivePort();<br />  s.send(r.sendPort);<br /><br />  // Will establish real car here...<br />}</pre>OK, back in the main thread, I do the usual isolate dance. I create a <code>ReceivePort</code> so that I can sent its <code>sendPort</code> property into the spawned <code>other()</code> isolate:<pre class=prettyprint>main() {<br />  ProxyCar car;<br /><br />  var r = new ReceivePort();<br /><br />  Isolate.<br />    spawn(other, r.sendPort).<br /><br />    // Wait for isolate to be ready, then return first message, which is send<br />    // port back to the isolate<br />    then((_) => r.first).<br /><br />    // Create proxy car with receive stream and isolate send port<br />    then((s) { /** Create proxy car here... **/ }).<br /><br />    // Will drive and report state here...<br />}</pre>After spawning the isolate, I wait for the returned <code>Future</code> to complete, indicating that the isolate is ready. Then, I return the first message sent back from <code>other()</code>, which is the <code>SendPort</code> through which I can send messages from <code>main()</code> to <code>other()</code>. <br /><br />Here, I note a problem. If I read the <code>first</code> property, then the receive port's stream is closed. That will cause problems as the <code>ProxyCar</code> tries to receive messages from the receive port. So instead, I convert the <code>ReceivePort</code> to a broadcast stream:<pre class=prettyprint>main() {<br />  ProxyCar car;<br /><br />  var r = new ReceivePort();<br />  var receiveStream = r.asBroadcastStream();<br /><br />  Isolate.<br />    spawn(other, r.sendPort).<br /><br />    // Wait for isolate to be ready, then return first message, which is send<br />    // port back to the isolate<br />    then((_) => receiveStream.first).<br /><br />    // Create proxy car with receive stream and isolate send port<br />    then((s) { car = new ProxyCar(receiveStream, s); }).<br /><br />    // Will drive and report state here...<br />}</pre>With that, I think I see a first pass implementation for the proxy car—it needs a stream on which to listen for messages from the real car and a send port through which messages can be sent to the real car. Something like this should work:<pre class=prettyprint>// Proxy Subject<br />class ProxyCar implements Automobile {<br />  SendPort _s;<br />  var _r;<br />  String _state = "???";<br /><br />  ProxyCar(this._r, this._s) {<br />    _r.listen((message) {<br />      print("[ProxyCar] $message");<br />      _state = message;<br />    });<br />  }<br />  // state, drive, stop declared already...<br />}</pre>The only messages that will come through that <code>ReceivePort</code> stream will (for now) be state updates, so I assign them to the <code>_state</code> instance variable. The rest is already in place—the already declared <code>state</code>, <code>stop()</code>, and <code>start()</code> methods will send messages through the <code>SendPort</code> supplied to the constructor.<br /><br />So the rest of the main thread becomes:<pre class=prettyprint><code>  Isolate.<br />    spawn(other, r.sendPort).<br /><br />    // Wait for isolate to be ready, then return first message, which is send<br />    // port back to the isolate<br />    then((_) => receiveStream.first).<br /><br />    // Create proxy car with receive stream and isolate send port<br />    then((s) { car = new ProxyCar(receiveStream, s); }).<br /><br />    // Drive proxy car, then wait for state message<br />    then((_) { car.drive(); }).<br />    then((_) => receiveStream.first).<br /><br />    // Proxy car state is ready, so print<br />    then((_) { print("Car is ${car.state}"); }).<br /><br />    // Stop proxy car, then wait for state message<br />    then((_) { car.stop(); }).<br />    then((_) => receiveStream.first).<br /><br />    // Proxy car state is ready, so print<br />    then((_) { print("Car is ${car.state}"); });</code></pre>Last, I need the real subject to work with the opposite send and receive ports. I will follow the same constructor signature, even though a broadcast stream is not necessary in the other isolate. That will make the creation of the real car look like:<pre class=prettyprint>other(SendPort s) {<br />  var r = new ReceivePort();<br />  s.send(r.sendPort);<br /><br />  var receiveStream = r.asBroadcastStream();<br />  new Car(receiveStream, s);<br />}</pre>And the real class needs to establish a listener for drive and stop messages from the proxy:<pre class=prettyprint>class Car implements Automobile {<br />  SendPort _s;<br />  var _r;<br />  Car(this._r, this._s) {<br />    _r.listen((message) {<br />      print(message);<br />      if (message == #drive) drive();<br />      if (message == #stop)  stop();<br />      _s.send(state);<br />    });<br />  }<br /><br />  String state = 'idle';<br />  void drive() { state = 'driving'; }<br />  void stop()  { state = 'idle'; }<br />}</pre>Phew! That was a lot harder than I expected. There is almost certainly some cleanup that I can perform. Perhaps the car classes can create their own <code>ReceivePort</code> instances. A little <code>Future</code> improvement is in order. Still, the code works:<pre class=prettyprint>$ ./bin/drive.dart                        <br />Symbol("drive")<br />[ProxyCar] driving<br />Car is driving<br />Symbol("stop")<br />[ProxyCar] idle<br />Car is idle</pre>The real subject receives the <code>#drive</code> symbol. Then the proxy subject receives a message that the real subject is driving. Then the output of the current state from the proxy is that the car is driving.<br /><br />I suppose I should have known that isolate code would get messy like this. Hopefully I can clean it up tomorrow.<br /><br /><br /><span style="color: #ccc">Day #61</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/dart-doesnotunderstand-proxies.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/FIOrdB4lzBw" height="1" width="1" alt=""/>
