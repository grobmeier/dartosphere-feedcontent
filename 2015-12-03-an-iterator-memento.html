---
title: 'An Iterator Memento'
layout: post
published: '2015-12-03T23:12:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/4HUdgVW9RC0/an-iterator-memento.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - iterator
    - memento

---

<div class=top-chain-links></div><br />I can't see any good reason to try this... So of course I'll try it anyway.<br /><br />The <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> includes a <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a> iterator inspired by <a href="https://en.wikipedia.org/wiki/Dylan_(programming_language)">Dylan</a>. <a href="http://dartlang.org">Dart</a> supports iterators natively, so there is no need for adapting this approach, but what the hey?<br /><br />I start with the memento. In this implementation, the memento is the iteration state. For illustration purposes, this state will be a simple counter:<pre class=prettyprint>class IterationState {<br />  int index = 0;<br />  void increment() { index++; }<br />}</pre>This example might benefit from a more complex state, but I'll start simply to get things working.<br /><br />Pulling almost directly from the Gang of Four book, I declare the iterator collection as:<pre class=prettyprint>class SongCollection {<br />  List _list = [];<br /><br />  SongCollection();<br /><br />  IterationState createInitialState() => new IterationState();<br />  void next(IterationState state) { state.increment(); }<br />  bool isDone(IterationState state) => state.index >= _list.length;<br />  Song currentItem(IterationState state) => _list[state.index];<br /><br />  void add(Song s) { _list.add(s); }<br />}</pre>The private <code>_list</code> is appended via the <code>add()</code> method. Everything else in there works with the memento.<br /><br />I continue to use the same <code>Song</code> class from the past couple of days:<br /><pre class=prettyprint>class Song {<br />  String title, album;<br />  Song(this.title, this.album);<br />  void play() {<br />    print("Playing ${toString()}");<br />  }<br />  String toString() => "$title // $album";<br />}<br /></pre>Instances of this object will be added to the <code>SongCollection</code> iterator so that each be played. Hopefully that will do it for the setup.<br /><br />In the caretaker context, I create the collection and add a choice selection of great songs:<pre class=prettyprint><code>  var collection = new SongCollection();<br />  collection<br />    ..add(new Song('The Lady is a Tramp', 'The Velvet Frog: The Very Best of Mel Tormé'))<br />    ..add(new Song('New York, New York Medley', 'A Vintage Year'))<br />    ..add(new Song('Blue Moon', 'The Velvet Frog: The Very Best of Mel Tormé'))<br />    ..add(new Song('\'Round Midnight', 'Tormé'));</code></pre>Next, I grab a reference to the initial collection state (also know as the memento):<pre class=prettyprint><code>  var state = collection.createInitialState();</code></pre>With that, I am able to iterate over the collection:<pre class=prettyprint><code>  while (!collection.isDone(state)) {<br />    collection.currentItem(state).play();<br />    collection.next(state);<br />  }</code></pre>And that works as expected. Each song is played in the order in which is was added to the collection:<pre class=prettyprint>$ ./bin/play_melvie.dart<br />Playing The Lady is a Tramp // The Velvet Frog: The Very Best of Mel Tormé<br />Playing New York, New York Medley // A Vintage Year<br />Playing Blue Moon // The Velvet Frog: The Very Best of Mel Tormé<br />Playing 'Round Midnight // Tormé</pre>On the face of it, there is little benefit to this approach. The <code>forEach()</code> of a Dart <code>List</code> could accomplish much the same behavior with no additional classes. That said, as the Gang of Four book mentions, it would be possible for multiple state mementos to work on the same collection (e.g. if multiple fans wanted to listen to the Velvet Fog at their convenience). Additionally, the internals of the state are not exposed to the caretaker—only the <code>SongCollection</code> has access to it, preserving encapsulation. This is not of much benefit when the state is a tracking integer, but more complex state mementos would certainly benefit from this approach.<br /><br />In the end, this was a fun exercise. But I'll probably stick with <code>forEach()</code> all the same.<br /><br /><i>Play with this code on DartPad: <a href="https://dartpad.dartlang.org/d5e3ffb470d140142e36">https://dartpad.dartlang.org/d5e3ffb470d140142e36</a>.</i><br /><br /><br /><span style="color: #ccc">Day #22</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/incremental-mementos.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/4HUdgVW9RC0" height="1" width="1" alt=""/>
