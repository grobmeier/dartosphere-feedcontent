---
title: 'Await Async Code Cleanup in Dart'
layout: post
published: '2016-01-12T22:10:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/iQ8nrE_O8aE/await-async-code-cleanup-in-dart.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - async
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - isolates
    - 'proxy pattern'

---

<div class=top-chain-links></div><br />My remote <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> solution in <a href="http://dartlang.org">Dart</a> got a little off the rails last night. It worked, but the interface changed from a synchronous real subject to an asynchronous proxy subject. Worse, the code was a heap o' Futures.<br /><br />I do not think there is anything I can do about the asynchronous proxy API—that is simply the nature of remote calls. I do think I can adapt the synchronous interface to an asynchronous interface, then proxy the asynchronous interface. I will investigate that tomorrow. First, I want to clean up the <code>Future</code> heap:<pre class=prettyprint><code>  Isolate.<br />    spawn(other, r.sendPort).<br />    then((_) => receiveStream.first).<br />    then((s) { car = new ProxyCar(receiveStream, s); }).<br />    then((_) { car.drive(); }).<br />    then((_) => receiveStream.first).<br />    then((_) { print("Car is ${car.state}"); }).<br />    then((_) { car.stop(); }).<br />    then((_) => receiveStream.first).<br />    then((_) { print("Car is ${car.state}"); });</code></pre>That makes sense if you noodle it through—at least I could rationalize it yesterday. But it is ugly to read, hence ugly to maintain. At first glance what stands out is that some <code>then()</code> methods return values and one accepts a value returned from the previous future. It is not clear why—at least not without noodling. And all the while that noodling is taking place, I would not be thinking about the actual business value of the code, which resided in the <code>ProxyCar</code> object which is manipulating a real car in another isolate.<br /><br />So, as the esteemed <a href="https://plus.google.com/u/0/+KasperLund">Kasper Lund</a> suggested (challenged? cajoled?) in last night's <a href="http://japhr.blogspot.com/2016/01/remote-proxy-pattern-and-dart-isolates.html#comments">comments</a>, I ought to make use of Dart's <code>async</code> / <code>await</code> functions.<br /><br />I start by marking the main entry point of my script as <code>async</code>:<pre class=prettyprint>main() async {<br />  // ...<br />}</pre>As the name suggests, this indicates that the code inside is asynchronous. More specifically, it says that some code will return futures—futures that would otherwise need to be chained to ensure that they run in the expected order.  The first future is returned from the isolate spawned to perform independent, real car work. Above, I waited for it to be ready with a <code>then()</code>. Now I can <code>await</code> it:<pre class=prettyprint><code>main() async {<br />  var r = new ReceivePort();<br />  await Isolate.spawn(other, r.sendPort);<br />  // ...<br />}</code></pre>Since this <code>main()</code> function is marked <code>async</code> no other code in here will run until <code>Isolate.spawn()</code>'s future completes. Exactly as with the <code>then()</code>, but without the mess.<br /><br />Next up is one of the mysterious return value futures. Previously, I waited for the first message to come back from the isolate with <code>then((_) => receiveStream.first)</code>. That first message was the isolate sending a <code>SendPort</code> back to the <code>main()</code> execution worker so that code in <code>main()</code> can send messages back to the isolate. The hash-rocket return value returns the message so that the next future completes with its value. <br /><br />Thus, the following two lines get a <code>SendPort</code> from the isolate to enable communication into the isolate and gives it to the <code>ProxyCar</code>:<pre class=prettyprint><code>    // ...<br />    then((_) => receiveStream.first).<br />    then((s) { car = new ProxyCar(receiveStream, s); }).<br />    // ...</code></pre>This is hard to explain. It is hard to read. It is going to cause problems as the code evolves. <br /><br />All I want is a <code>SendPort</code> from the isolate. With <code>await</code>, this is written:<pre class=prettyprint><code>  SendPort s = await receiveStream.first;</code></pre>Once the value is ready, assign it to the local <code>s</code> variable. Easy-peasy! Then on the next line I create my proxy car just as if this were procedural code:<pre class=prettyprint><code>  car = new ProxyCar(receiveStream, s);</code></pre>That is much easier to read.<br /><br />I can then drive my car (which proxies a drive request to the real car in its isolated worker environment):<pre class=prettyprint><code>  car.drive();</code></pre>No awaiting is needed for either of these as I am just sending messages. The only reason it was needed in the future heap was because everything else was in that mess. Thanks to <code>async</code> and <code>await</code>, that mess is gone.<br /><br />Things are not completely rosy, however. Even <code>await</code> is not going to convert that <code>drive()</code> method into a synchronous call. The interface implemented by both the real <code>Car</code> and the <code>ProxyCar</code> expects <code>drive()</code> to return <code>void</code>:<pre class=prettyprint>abstract class Automobile {<br />  String get state;<br />  void drive();<br />  void stop();<br />}</pre>So the <code>drive()</code> is going to send a message, then allow execution to continue right on to the next statement without waiting for the real car to start driving or to update the proxy car's state. Printing the car's state right away would result in believing the car is stopped:<pre class=prettyprint><code>  car.drive();<br />  print("Car is ${car.state}");<br />  // State hasn't had a chance to update and would report "idle"</code></pre>With the current interface, I cannot await <code>drive()</code>—I need a <code>Future</code>. So, temporarily, I reach under the <code>ProxyCar</code> covers and <code>await</code> a message (a state update from the real car) to its <code>receiveStream</code>:<pre class=prettyprint><code>  car.drive();<br />  await receiveStream.first;<br /><br />  // Proxy car state is ready, so print<br />  print("Car is ${car.state}");</code></pre>As I mentioned earlier, I will pick back up tomorrow converting the proxied interface into an asynchronous version of the current synchronous interface. For now I note that, even with the reaching-under-the-covers (which I was doing in the future-heap code anyway), my remote proxy code is already far more readable:<pre class=prettyprint>main() async {<br />  var r = new ReceivePort();<br />  var receiveStream = r.asBroadcastStream();<br /><br />  await Isolate.spawn(other, r.sendPort);<br /><br />  SendPort s = await receiveStream.first;<br /><br />  ProxyCar car = new ProxyCar(receiveStream, s);<br /><br />  car.drive();<br />  await receiveStream.first;<br /><br />  print("Car is ${car.state}");<br /><br />  car.stop();<br />  await receiveStream.first;<br /><br />  print("Car is ${await car.state}");<br />}</pre>That lovely win makes for a fine stopping point tonight. More async adapters tomorrow!<br /><br /><br /><span style="color: #ccc">Day #62</span>  <br /><br /><p class=bottom-chain-links><a href="">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/iQ8nrE_O8aE" height="1" width="1" alt=""/>
