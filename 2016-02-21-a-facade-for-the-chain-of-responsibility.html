---
title: 'A Facade for the Chain of Responsibility'
layout: post
published: '2016-02-21T19:45:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/tOvoJ28YGOE/a-facade-for-chain-of-responsibility.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - 'chain of responsibility pattern'
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />How much should the client know about the implementation of the <a href="https://en.wikipedia.org/wiki/Chain-of-responsibility_pattern">chain of responsibility pattern</a>? I have reworked my spreadsheet cell formatting example to the point that I am quite satisfied with the code organization and how it responds:<br /><br /><a href="https://2.bp.blogspot.com/-xW0dugB6ru8/VsoGhTiGB7I/AAAAAAABEMY/7byOJceqD-0/s1600/03-no_text_formatter_after.png" imageanchor="1" ><img border="0" src="https://2.bp.blogspot.com/-xW0dugB6ru8/VsoGhTiGB7I/AAAAAAABEMY/7byOJceqD-0/s640/03-no_text_formatter_after.png" width=570 /></a><br /><br />What leaves me slightly less satisfied is how much the <a href="http://dartlang.org">Dart</a> constructing code needs to know about the underlying implementation. Currently, I have it constructing the individual links in the chain <i>and</i> assigning those links:<pre class=prettyprint><code>  var textFormat = new TextFormatter();<br />  var dateFormat = new DateFormatter(textFormat);<br />  var numberFormat = new NumberFormatter(dateFormat);</code></pre>I do not think it too horrible that the constructing code needs to know about the individual formatters—especially since it needs to know how to remove some of them in response to checkbox changes. What bugs me here is the same thing that has bugged me about other examples that I have built—the requirement that the constructing code know which link is first, which link has to be constructed first, and with which links each can and should link. <br /><br />That is, the text-formatter is the default link, so it needs to be last in the chain, but it has to be constructed first so that the second-to-last link can point to it. It is also not a good idea to remove the text-formatter (even though I have a checkbox in the UI) because it is the default cell formatter. Lastly, I find it awkward to tell the on-change listener to number-format cells when establishing the request handler:<pre class=prettyprint><code>  container.onChange.listen(numberFormat);</code></pre>Even though it looks like I am asking for number formatting, I am really asking for something in the cell formatting chain to handle the request—number format just happens to be the first.<br /><br />In some (most?) implementations of the chain of responsibility this might actually be OK or desired organization. In this case, I think a facade wants to be in front of this complexity. So I define <code>CellFormatter</code> such that it declares the individual link components:<pre class=prettyprint>class CellFormatter {<br />  var _numberFormat = new NumberFormatter();<br />  var _dateFormat = new DateFormatter();<br />  var _textFormat = new TextFormatter();<br /><br />  var first;<br />  // ...<br />}</pre>I also declare a pointer to the first cell-formatting object so that I know where to start requests and can easily update it. In the constructor, I then establish the links in the chain and initially set <code>first</code>:<pre class=prettyprint>class CellFormatter {<br />  // ...<br />  CellFormatter() {<br />    _numberFormat.nextHandler = _dateFormat;<br />    _dateFormat.nextHandler = _textFormat;<br />    first = _numberFormat;<br />  }<br />  // ...<br />}</pre>The <code>call()</code> method is then simple enough—I send the event request onto the <code>call()</code> method of the first link in the chain:<pre class=prettyprint>class CellFormatter {<br />  // ...<br />  void call(Event e) { first.call(e); }<br />  // ...<br />}</pre>And, as mentioned, it is easy to manipulate the chain with methods like <code>ignore()</code> and <code>obey()</code>. A simple implementation for the number formatter could be:<pre class=prettyprint>class CellFormatter {<br />  // ...<br />  void ignore(String format) {<br />    if (format == 'number') first = _dateFormat;<br />    // ...<br />  }<br />  void obey(String format) {<br />    if (format == 'number') first = _numberFormat;<br />    // ...<br />  }<br />}</pre>I feel more comfortable putting this knowledge in a class than I would in the main code. At least for this example, this seems like too much maintenance to mingle with other code.<br /><br />This does lead to some significant improvements in the main code. Obviously, it is much simpler to instantiate one object instead of three (and to omit the linking):<pre class=prettyprint><code>  var cellFormat = new CellFormatter();</code></pre>I also get the benefit of an easier to read (and hence easier to maintain) assignment of the cell-formatter:<pre class=prettyprint><code>  container.onChange.listen(cellFormat);</code></pre>This one-liner reads nicely and has low cognitive requirements: when the spreadsheet container sees changes, it cell-formats the source elements. No worry about the chain or the first element in the chain. Formatting is done by the cell formatter. Simple!<br /><br />(see last night's post for why <code>cellFormat</code> behave like a function here)<br /><br />The nicest win in this approach may be in the code that ignores/obeys formatters. Previously, when ignoring the number formatter, I had to obtain a subscription from the initial listener so that I could then cancel it and start a new listener with the second link in the chain:<pre class=prettyprint><code><br />  var subscription= container.onChange.listen(numberFormat);<br /><br />  query('#no-numbers').onChange.listen((e){<br />    var el = e.target;<br />    if (el.checked) {<br />      subscription.cancel();<br />      subscription = c.stream.listen(dateFormat);<br />    }<br />    // ...<br />  });</code></pre>Now that <code>CellFormatter</code> internally maintains a reference to the <code>first</code> item in the chain, I no longer need to worry about the stream subscription sending to the wrong first element. The resulting code is mercifully free from subscription code, only obeying or ignoring links as requested:<pre class=prettyprint><code><br />  container.onChange.listen(cellFormat);<br /><br />  query('#no-numbers').onChange.listen((e){<br />    var el = e.target;<br />    if (el.checked) {<br />      cellFormat.ignore('number');<br />    }<br />    // ...<br />  });</code></pre>That seems a nice improvement.<br /><br />Overall, I am very happy with the improvement in the code as a results of this approach. I have yet to examine it in depth, but I believe this is likely a facade pattern as it hides some of the underlying complexity of the chain of responsibility from the calling context. Regardless of what it is called, I very much like it!<br /><br />This seems a nice stopping point for my research into the chain of responsibility. Up next, who knows?<br /><br /><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/adf7e28a00eba10491e9">https://dartpad.dartlang.org/adf7e28a00eba10491e9</a>.</i><br /><br /><br /><span style="color: #ccc">Day #102</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/02/call-chain-of-responsibilty.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/tOvoJ28YGOE" height="1" width="1" alt=""/>
