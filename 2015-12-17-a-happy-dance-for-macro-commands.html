---
title: 'A Happy Dance for Macro Commands'
layout: post
published: '2015-12-17T23:20:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/1Rg0FTZGDCA/a-happy-dance-for-macro-commands.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I continue my exploration of the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> in <a href="http://dartlang.org">Dart</a> by examining macro commands. Macro commands are composites of other commands, which is one of the nice things about commands: that they can be combined.<br /><br />I have a <code>Robot</code> class that moves in one of four cardinal directions defined in an enum:<pre class=prettyprint>enum Direction { NORTH, SOUTH, EAST, WEST }</pre>Commands encapsulate movement in one of those directions along with the receiver of the command, the robot:<pre class=prettyprint>var moveNorth = new MoveNorthCommand(robot);</pre>My button invoker class then links buttons with the appropriate command:<pre class=prettyprint>var btnUp = new Button("Up", moveNorth);</pre>Which can be pressed to initial movement:<pre class=prettyprint>btnUp.press();</pre>This all works thanks to the command pattern.<br /><br />Today, I want to introduce the happy dance button. Its command will also link the robot to a command:<pre class=prettyprint>var danceHappy = new DanceHappyCommand(robot);</pre>And a button will invoke this command when pressed:<pre class=prettyprint>var btnHappyDance = new Button("Happy Dance", danceHappy);</pre>To make things interesting, I will make the happy dance a series of random steps. So I import <code>dart:math</code> and seed a random number generator:<pre class=prettyprint>import 'dart:math';<br /><br />enum Direction { NORTH, SOUTH, EAST, WEST }<br /><br />final rand = new Random(3);</pre>With that, I am ready to dance. Using the raw enum is actually easier to implement than a macro command:<pre class=prettyprint>class DanceHappyCommand implements Command {<br />  Robot robot;<br />  DanceHappyCommand(this.robot);<br />  void call() {<br />    for (var i=0; i&lt;8; i++) {<br />      robot.move(Direction.values[rand.nextInt(4)]);<br />    }<br />  }<br />}</pre>But, since I am exploring macro commands, I switch to conditionally invoking the appropriate command instead:<pre class=prettyprint>class DanceHappyCommand implements Command {<br />  Robot robot;<br />  DanceHappyCommand(this.robot);<br />  void call() {<br />    for (var i=0; i&lt;8; i++) {<br />      int r = rand.nextInt(4);<br />      if (r==0) new MoveNorthCommand(robot).call();<br />      if (r==1) new MoveSouthCommand(robot).call();<br />      if (r==2) new MoveEastCommand(robot).call();<br />      if (r==3) new MoveWestCommand(robot).call();<br />    }<br />  }<br />}</pre>With that, I can move back to my client code to instruct the robot to happy dance:<pre class=prettyprint>btnHappyDance.press();<br />print("\nRobot is now at: ${robot.location}");</pre>Which results in:<pre class=prettyprint>$ ./bin/play_robot.dart<br />[pressed] Happy Dance<br />  I am moving Direction.WEST<br />  I am moving Direction.WEST<br />  I am moving Direction.EAST<br />  I am moving Direction.WEST<br />  I am moving Direction.WEST<br />  I am moving Direction.NORTH<br />  I am moving Direction.SOUTH<br />  I am moving Direction.NORTH<br /><br />Robot is now at: -3, 1</pre>Yay! I am doing a happy dance of my ownâ€”that was fairly easy to do. But...<br /><br />What about undoing that command? This is the command pattern, so I could rewind each command in the macro by invoking their respective <code>undo()</code> method. Instead, I think I will use this as an opportunity to record receiver state in an effort to return to that state as quickly as possible.<br /><br />So, when the happy dance command is invoked, I make a note of the current <code>x</code> and <code>y</code> positions:<pre class=prettyprint>class DanceHappyCommand implements Command {<br />  Robot robot;<br />  int _prevX, _prevY;<br />  DanceHappyCommand(this.robot);<br />  void call() {<br />    _prevX = robot.x;<br />    _prevY = robot.y;<br />    for (var i=0; i<8; i++) {<br />      // 8 random moves here...<br />    }<br />  }<br />}</pre>Using that information in an <code>undo()</code> method means that I can get back to the original starting point as quickly as possible:<pre class=prettyprint>class DanceHappyCommand implements Command {<br />  Robot robot;<br />  int _prevX, _prevY;<br />  DanceHappyCommand(this.robot);<br />  void call() {<br />     // ...<br />  }<br />  void undo() {<br />    var dir;<br /><br />    dir = robot.x > _prevX ? Direction.WEST : Direction.EAST;<br />    while (robot.x != _prevX) {<br />      robot.move(dir);<br />    }<br /><br />    dir = robot.y > _prevY ? Direction.SOUTH : Direction.NORTH;<br />    while (robot.y != _prevY) {<br />      robot.move(dir);<br />    }<br />  }<br />}<br /></pre>With that, I can instruct the client code to undo a happy dance:<pre class=prettyprint><code>  btnHappyDance.press();<br />  print("\nRobot is now at: ${robot.location}");<br />  print("--\n");<br /><br />  btnUndo.press();<br />  print("\nRobot is now at: ${robot.location}");</code></pre>Which results in a happy dance and a quick return back to my starting position:<pre class=prettyprint>$ ./bin/play_robot.dart<br />[pressed] Happy Dance<br />  I am moving Direction.WEST<br />  I am moving Direction.WEST<br />  I am moving Direction.EAST<br />  I am moving Direction.WEST<br />  I am moving Direction.WEST<br />  I am moving Direction.NORTH<br />  I am moving Direction.SOUTH<br />  I am moving Direction.NORTH<br /><br />Robot is now at: -3, 1<br />--<br /><br />[pressed] Undo<br />Undoing Instance of 'DanceHappyCommand'<br />  I am moving Direction.EAST<br />  I am moving Direction.EAST<br />  I am moving Direction.EAST<br />  I am moving Direction.SOUTH<br /><br />Robot is now at: 0, 0</pre>Although I might implement both <code>call()</code> and <code>undo()</code> differently in real life, these are still reasonable approaches. They have the added benefit of serving as nice talking points for the command pattern when I discuss it in <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>, so I will call it a night here.  <p><i>Play with the code on DartPad: <a href="https://dartpad.dartlang.org/d1d60100f33d62f40b58">https://dartpad.dartlang.org/d1d60100f33d62f40b58</a>.</i></p><span style="color: #ccc">Day #36</span>    <p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/command-history.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/1Rg0FTZGDCA" height="1" width="1" alt=""/>
