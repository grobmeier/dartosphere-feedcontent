---
title: 'Constant Constructors and Benchmark Scoring'
layout: post
published: '2014-07-15T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/j54AzTBOlQk/constant-constructors-and-benchmark.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I really appreciated the graph from last night's benchmarking post:<br /><br /><a href="http://1.bp.blogspot.com/-wgijZEHljXo/U8SzfFP-vcI/AAAAAAAAdOQ/iCQgLprw1TM/s1600/image+(2).png" imageanchor="1" ><img border="0" src="http://1.bp.blogspot.com/-wgijZEHljXo/U8SzfFP-vcI/AAAAAAAAdOQ/iCQgLprw1TM/s640/image+(2).png" /></a><br /><br />It makes it much more obvious where things change than just looking at a table of numbers:<br /><br /><table border=1><tr style="border-bottom: 1px solid black"><th>Loop Size</th><th>Classic</th><th>Nodes Traverse (single dispatch)</th><th>Visitor Traverses</th></tr><tr><td>10</td><td>131.6</td><td>122.7</td><td>121.4</td></tr><tr><td>100</td><td>125.9</td><td>113.6</td><td>120.15</td></tr><tr><td>1000</td><td>123.8</td><td>122.8</td><td>120.65</td></tr><tr><td>10000</td><td>157.0</td><td>153.25</td><td>120.45</td></tr><tr><td>100000</td><td>158.05</td><td>154.65</td><td>121.05</td></tr></table><br />Building the actual graph was a pain. If there is pain involved, it is quite likely that I am not going to make use of what I just described as very useful. So, before moving on to other learning territory, let's see if I ease the pain.<br /><br />The pain involved manually copying CSV benchmarks of three different implementations of the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> in <a href="http://dartlang.org">Dart</a>. The benchmarking code is available in the <code>tool</code> subdirectory of the publicly available <a href="https://github.com/eee-c/design-patterns-in-dart/tree/master/visitor">visitor book code</a> for the forthcoming <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> (last night's SHA1 was <a href="https://github.com/eee-c/design-patterns-in-dart/tree/14dea8561ae52706e04b50f7e13904d96457946d/visitor">14dea8561a</a>).<br /><br />To make the graph, I pasted the CSV into Google Docs spreadsheets, which is where the work (and pain) really started. The pain involved:<ol><li>adding a column dividing the time by the number of loops</li><li>adding another sheet that averaged the numbers in different runs to create the table above</li><li>generating the graph with the correct labels and headers</li></ol>Step #1 should be easy—I probably should have done that myself in the Dart benchmarking code. That I did not are the hazards of plowing ahead in a solution without thinking.<br /><br />Step #2 was particularly hard because I had to manually edit the range of cells to be averaged <i>and</i> the cell that identified the number of loops. Copying and pasting always got the wrong column and or row. In a 5×3 table, that is 15 edits of 3 values. There is no way I am doing that again by hand.<br /><br />Step #3 may very well need to remain in Google spreadsheets. I know of no Dart packages that can manipulate Google Sheets (really?) nor are there any Dart packages that I can find that can manually build pretty graphs in PNG form. I am <i>more</i> than happy to be corrected on either point!<br /><br />Anyhow, let's see what I can do about steps #1 and #2. Ugh... strike that. Let's see what I can do about the “easy” #1. In theory, #1 ought to be easy—all I need to do is get the <code>loopSize</code> from my benchmark's <code>main()</code> entry point down to the benchmark class:<pre class=prettyprint>main (List<string> args) {<br />  // Determine loopSize from command-line args...<br /><br />  _setup();<br />  for (var i=0; i<&lt;numberOfRuns; i++) {<br /><b>    VisitorBenchmark.main();</b><br />  }<br />}</pre>If <code>VisitorBenchmark</code> knows the <code>loopSize</code> it can emit a score that includes the actual run time of the benchmark divided by <code>loopSize</code>:<pre class=prettyprint>class LoopScorer implements ScoreEmitter {<br />  const LoopScorer(this.numLoops);<br /><br />  void emit(String testName, double value) {<br />    print(<br />      '$testName (RunTime in µs), '<br />      '${value.toStringAsPrecision(4)}, '<br />      '${numLoops}, '<br />      '${(value/numLoops).toStringAsPrecision(4)}'<br />    );<br />  }<br />}</pre>Ah, my old friend <a href="http://japhr.blogspot.com/2012/12/dart-constant-constructors.html">constant constructors</a>. Wait, not “friend” in this case—the loopSize is coming in from the command-line so there is no way that it will ever be a compile time constant. So there is no way to create a constant scorer.<br /><br />So I do something bad instead: storing the score in a global and make the loop responsible for printing the results:<pre class=prettyprint><b>double lastScore;</b><br />class GloballyPersistingScoreEmitter implements ScoreEmitter {<br />  const GloballyPersistingScoreEmitter();<br />  void emit(String testName, double value) {<br /><b>    lastScore = value;</b><br />  }<br />}</pre>The benchmark then needs to use this scorer:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark() :<br />    super(NAME, emitter: <b>const GloballyPersistingScoreEmitter()</b>);<br />  // ...<br />}</pre>And finally, my loop reports the results:<pre class=prettyprint>main (List<string> args) {<br />  // ...<br />  for (var i=0; i&lt;numberOfRuns; i++) {<br />    VisitorBenchmark.main();<br /><b>    print(<br />      '${NAME} (RunTime in µs), '<br />      '${lastScore.toStringAsPrecision(4)}, '<br />      '${loopSize}, '<br />      '${(lastScore/loopSize).toStringAsPrecision(4)}'<br />    );</b><br />  }<br />}</pre>The results are a nice set of CSV values for inclusion in a spreadsheet:<pre class=prettyprint>$ ./tool/benchmark.dart<br />Classic Visitor Pattern (RunTime in µs), 1205, 10, 120.5<br />Classic Visitor Pattern (RunTime in µs), 1213, 10, 121.3<br />Classic Visitor Pattern (RunTime in µs), 1192, 10, 119.2</pre>I can understand why benchmarks rely on compile-time constants like the benchmarker and scorer. No matter how many times I create a new instance, no new memory is consumed. In other words, the benchmark harness will not be responsible for triggering garbage collection. At the same time, it sure makes reporting anything more than the simplest information a pain.<br /><br /><b>Update:</b> I do not need the scoring emitter after all. I can get away with returning the results of <code>measure()</code> directly from <code>main()</code> in my benchmark class:<pre class=prettyprint>class VisitorBenchmark extends BenchmarkBase {<br />  const VisitorBenchmark(): super(NAME);<br /><b>  static double main()=> new VisitorBenchmark().measure();</b><br />  // ...<br />}</pre>Since I am no longer calling the benchmarker's <code>report()</code> method, the score emitter is not invoked. The script's main entry point can then report to its heart's content using this return value:<pre class=prettyprint><code>  // ...<br />  for (var i=0; i&lt;numberOfRuns; i++) {<br /><b>    double score = VisitorBenchmark.main();</b><br />    print(<br />      '${NAME} (RunTime in µs), '<br />      '${score.toStringAsPrecision(4)}, '<br />      '${loopSize}, '<br />      '${(score/loopSize).toStringAsPrecision(4)}'<br />    );<br />  }<br />  // ...</code></pre>And no global values.<br /><br /><br /><span style="color: #ccc">Day #</span>  <p class=bottom-chain-links><a href="">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/j54AzTBOlQk" height="1" width="1"/>
