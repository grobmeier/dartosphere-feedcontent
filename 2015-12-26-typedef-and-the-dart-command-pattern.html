---
title: 'Typedef and the Dart Command Pattern'
layout: post
published: '2015-12-26T23:58:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/cbRaWYmrcTE/typedef-and-dart-command-pattern.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - command
    - dart
    - dartlang
    - 'design patterns'

---

<div class=top-chain-links></div><br />I fancied myself done with the <a href="https://en.wikipedia.org/wiki/Command_pattern">command pattern</a> in <a href="http://dartlang.org">Dart</a>. <a href="https://plus.google.com/+AndersHolmgren1">Anders Holmgren</a> had other ideas. <a href="http://japhr.blogspot.com/2015/12/subclass-just-to-support-one-method.html#comments">In the comments</a> on last night's "final" command pattern article, he had a number of insightful suggestions that I have yet to consider. <br /><br />So consider I do, tonight.<br /><br />First up, I had not been constraining my function or object commands. Just about everywhere I use commands, I allow it to be a generic <code>Function</code>:<pre class=prettyprint>class Button {<br />  String name;<br />  Function command;<br />  Button(this.name, this.command);<br /><br />  void press() {<br />    print("[pressed] $name");<br />    command.call();<br />    History.add(command);<br />  }<br />}</pre>It should be noted here that any class that supports a <code>call()</code> method is a <code>Function</code>. So <code>command</code> here can be a function or function-like object.<br /><br />As can be seen in the <code>press()</code> method, the function or object never takes any arguments. Furthermore, it never returns a value, so its return type should be void. Although the following <code>Button</code> would result in a run-time error, the Dart analyzer thinks that it is perfectly OK:<pre class=prettyprint>new Button("Test", (String arg) => "$arg $arg $arg");</pre>The anonymous function should neither accept an argument nor should it return a value as it does with the hash rocket symbol.<br /><br />Thankfully, Aders has me covered here. I should declare a <code>typedef</code> that describes my command interfaces:<pre class=prettyprint>typedef void _Command();</pre>Anything with a type of <code>_Command</code> will now be required by the analyzer to return nothing and accept no arguments.<br /><br />I replace all <code>Function</code> types with <code>_Command</code>, including in my <code>Button</code> invoker:<pre class=prettyprint>class Button {<br />  String name;<br />  _Command command;<br />  Button(this.name, this.command);<br /><br />  void press() { /* ... */ }<br />}</pre>Now the analyzer complains about my "Test" button:<pre class=prettyprint>[warning] The argument type '(String) → String' cannot be assigned to the parameter type '_Command'</pre>So typedefs are a great suggestion.<br /><br />What I would like to do next is replace the <code>Function</code> in the <code>Command</code> class declaration:<pre class=prettyprint>abstract class Command implements Function {<br />  void call();<br />}</pre>I would like to explicitly tie my <code>Command</code> class with the void-no-argument <code>_Command</code> typedef:<pre class=prettyprint>abstract class Command implements _Command {<br />  void call();<br />}</pre>That will not work however because:<pre class=prettyprint>[error] Classes can only implement other classes</pre>I am not entirely out of luck, however. Even though there is no way to explicitly tie <code>Command</code> to my typdef, it is already implicitly associated. Any function-like thing that accepts no arguments and returns <code>void</code> is a <code>_Command</code> typedef. Thus:<pre class=prettyprint>abstract class Command implements Function { /* ... */ }<br />abstract class UndoableCommand implements Command { /* ... */ }<br />class MoveNorthCommand implements UndoableCommand {<br />  // ...<br />  void call() { robot.move(Direction.NORTH); }<br />}<br /><br />main() {<br />  // ...<br />  var moveNorth = new MoveNorthCommand(robot);<br />  print("MoveNorthCommand is a _Command: ${moveNorth is _Command}");<br />}<br /></pre>Results in:<pre class=prettyprint>MoveNorthCommand is a _Command: true</pre>So Dart already knows that anything implementing <code>Command</code>—or even declaring a void-no-arg <code>call()—is a <code>_Command</code>. <br /><br />In other words, there is no way to explicitly constrain a function class to a typedef interface... other than using a clever trick that Anders uses in the <code>UndoCommand</code> declaration. Even though I cannot extend or implement a typedef in a class declaration, I <i>can</i> extend a type in a generic:<pre class=prettyprint>abstract class UndoableCommand&lt;T extends _Command> implements Command {<br />  void call();<br />  T get undoCommand;<br />}</pre>The type of <code>undoCommand</code> is now restricted (upper-limitted?) to be a no-arg-void-return <code>_Command</code>. I remain unsure about that, however as it seems a bit obscure. <br /><br /><br /><br /><br /><span style="color: #ccc">Day #45</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/12/subclass-just-to-support-one-method.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/cbRaWYmrcTE" height="1" width="1" alt=""/>
