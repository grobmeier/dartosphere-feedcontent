---
title: 'Rethinking Introductions to Event Streams'
layout: post
published: '2014-05-12T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/ZHBthnGp39A/rethinking-introductions-to-event.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang

---

<div class=top-chain-links></div><br />While working through the errata in <a href="http://dart4hipsters.com/">Dart for Hipsters</a>, it has become pretty apparent that chapter 6, which introduces MVC in <a href="http://dartlang.org">Dart</a>, is not doing its job effectively. <br /><br />In my defense, that is the front-line chapter that repeatedly saw the most updates as Dart moved through various event-based approaches to mouse and keyboard interactions before ultimately settling on a stream-based approach. I had thought I did a fair job of pulling the chapter through the various versions of Dart, but reading it through fresh eyes—especially with the errata feedback—it is clear that the narrative is not as effective as it should be.<br /><br />I still like the overall approach, but I would like to see if I can cut some cruft from the specific implementation. Tonight, I hope to drop at least one import statement from the code in that chapter:<pre class=prettyprint><b>import 'dart:html';<br />import 'dart:async';<br />import 'dart:collection';<br />import 'dart:convert';</b><br />main() {<br />  // ...<br />}</pre>This is relatively early on in the book, so the fewer the libraries, the fewer the concepts being introduced and the less discussion required to support the main narrative. Unfortunately, I am a bit of luck here. I need <code>dart:html</code> to gain access to DOM manipulation as well as to the <code>HttpRequest</code> class. Likewise, I need <code>dart:convert</code> to parse and stringify JSON data for a REST-like backend. That leaves me with <code>dart:async</code> and <code>dart:collection</code>.<br /><br />The <code>dart:collection</code> library is an interesting option for chapter removal. It is there is make collections of MVC models easier to implement. That is nice, but it comes at the expense of addition background discussion of iterables. I can argue for retaining this in that MVC, by its nature, has a collection in it, so <code>dart:collection</code> probably will not look (at first) like a new concept to readers. So I table the removal of <code>dart:collection</code> for future investigation.<br /><br />That leaves <code>dart:async</code>. I <i>think</i> that is mostly in there to support event-based discussion. Unfortunately I think this discussion is causing more trouble than it is worth—especially since the implementation is so similar to that of the stream-based implementation in a later chapter. So let's see what happens if I remove <code>dart:async</code> from the code...<br /><br />Dang, it. When I do that, I get errors from the view, which is listening for events on the stream so that it knows when to update itself:<pre class=prettyprint>class ComicsView {<br />  // ...<br />  ComicsView({this.el, this.collection}) {<br />    if (collection == null) return;<br /><b>    collection.onLoad.listen((event) => render());<br />    collection.onAdd.listen((event) => render());</b><br />  }<br />  // ...<br />}</pre>Hrm... it seems like it might be really hard to implement MVC without some kind of events. In the <code>main()</code> entry point, I create a collection which can then broadcast its changes to the view (and any other interested parties) when things change internally:<pre class=prettyprint>main() {<br />  var my_comics_collection = new ComicsCollection();<br />  new ComicsView(<br />    el: document.query('#comics-list'),<br />    collection: my_comics_collection<br />  );<br />  my_comics_collection.fetch();<br />  // ...<br />}</pre>Possibly the simplest conceptual approach would be a series of callbacks (I know, I know), but I am unsure how I could implement that in the above. If I define a local callback to be passed to <code>ComicsCollection</code>, how can it update the comics view when it is yet to be defined?<br /><br />Ah, this is Dart, so lazy evaluation ought to serve nicely:<pre class=prettyprint>main() {<br />  var comics_view, my_comics_collection;<br /><br /><b>  my_comics_collection = new ComicsCollection(<br />    onLoad: ()=> comics_view.render()<br />  );</b><br />  comics_view = new ComicsView(<br />    el: document.query('#comics-list'),<br />    collection: my_comics_collection<br />  );<br />  my_comics_collection.fetch();<br />  // ...<br />}</pre>By the time <code>ComicsCollection</code> does load, the <code>comics_view</code> will no longer be <code>null</code> and should respond to the <code>render()</code> method.<br /><br />That will work, but does it suit the narrative? The only way to find out is to work through the remaining stream-based code and convert it to the equivalent callback-hell version. That is hardly ideal Dart code, but, if this approach suits the MVC chapter, it will certainly make the stream chapter that much more valuable.<br /><br /><br /><span style="color: #ccc">Day #61</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/05/webgl-in-chrome-36-linux-is-not-working.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/05/thankfully-acceptance-tests.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/ZHBthnGp39A" height="1" width="1"/>
