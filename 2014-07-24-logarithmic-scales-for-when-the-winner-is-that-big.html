---
title: 'Logarithmic Scales: For When the Winner is That Big'
layout: post
published: '2014-07-24T23:59:00-04:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/95Z9j0dn3ks/logarithmic-scales-for-when-winner-is.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - benchmarking
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'factory method pattern'

---

<div class=top-chain-links></div><br />Up tonight: whatever breaks when I try my all-encompassing, <a href="http://designpatternsindart.com/">Design Patterns in Dart</a> benchmarking suite on a different pattern. I have been building it out on code for the <a href="http://en.wikipedia.org/wiki/Visitor_pattern">Visitor Pattern</a> and I think it is finally ready (more or less). So let's see what happens when I pull it back into the code for the <a href="http://en.wikipedia.org/wiki/Factory_method_pattern">Factory Method Pattern</a>.<br /><br /><i>Note:</i> the code is located at <a href="https://github.com/eee-c/design-patterns-in-dart">https://github.com/eee-c/design-patterns-in-dart</a>. The current HEAD points to <a href="https://github.com/eee-c/design-patterns-in-dart/commit/bec37fd41e9641338cfc227c8c04426e4f1ff253">bec37fd41e</a>.<br /><br />What I found in the Visitor Pattern code was that the benchmark numbers were dependent on the number of times that a particular pattern was run through a loop. This could be specific to patterns that work on node structures like then Visitor Pattern. But for all I know, different approaches like storing a list of Factories in a <code>Map</code> might also be influenced by the number of times through a loop. There is only one way to find out…<br /><br />I start with a little code re-organization. I think I have settled on storing the preferred solution directly in the <code>lib</code> directory of the particular pattern being explored while alternatives go in <code>lib/alt</code>. After that, I create a separate benchmark script for each approach in the <code>tool</code> directory:<pre class=prettyprint>$ tree tool<br />tool<br />├── benchmark.sh<br /><b>├── benchmark.dart<br />├── benchmark_map_of_factories.dart<br />├── benchmark_mirrors.dart</b><br />└── packages -> ../packages</pre>I also create a mostly-configuration <code>benchmark.sh</code> Bash script file that pulls in common code to run each of those Dart scripts. And it all works pretty brilliantly. Except for the 2 errors per script that cause each benchmark to crash:<pre class=prettyprint>Unhandled exception:<br />FileSystemException: Cannot open file, path = '/home/chris/repos/design-patterns-in-dart/factory_method/tool/packages/args/args.dart' (OS Error: No s)<br />#0      _rootHandleUncaughtError.&lt;anonymous closure>.<anonymous closure> (dart:async/zone.dart:713)<br />...</pre>The solution is fairly simple, though it does expose yet another gap in my thinking—this time regarding <a href="http://pub.dartlang.org/">Dart Pub</a> packages. Before moving the benchmarking code into a common package location, it was a development dependency for the Visitor Pattern code:<pre class=prettyprint>name: visitor_code<br />dev_dependencies:<br /><b>  args: any</b><br />  benchmark_harness: any</pre>That is no longer needed directly by the pattern code—the common benchmarking code parses command-line arguments now. Only it is clearly not being pulled into this factory method “application.” The factory method application depends on the common <code>dpid_benchmarking</code> package:<pre class=prettyprint>name: factory_method_code<br />dependencies:<br />  browser: any<br /><b>dev_dependencies:<br />  dpid_benchmarking:<br />    path: ../packages/benchmarking</b></pre>And <code>dpid_benchmarking</code> does depend on <code>args</code>:<pre class=prettyprint>name: dpid_benchmarking<br />dev_dependencies:<br /><b>  args: any</b><br />  benchmark_harness: any</pre>So why doesn't <code>args</code> get pulled into the application as well?<br /><br />The answer is simple, really. It is a development dependency of <code>dpid_benchmarking</code>. In other words, it will get installed when used by other applications or packages (like my factory method code). As a development dependency, it is only installed when working directly with the package—when developing it in isolation.<br /><br />This is not <i>completely</i> obvious. I had not given this much thought, but I realize now that I expected this package's development dependencies to be installed by my application's development dependencies. Somewhere in the back of my mind I was expecting the development dependency on <code>dpid_benchmarking</code> to pull in <code>dpid_benchmarking</code>'s development dependencies as well. <br /><br />Now that I have exposed this flawed thinking, I acknowledge that it was erroneous. Development dependencies are for single package development only. Hopefully I will remember that.<br /><br />That issue aside, everything else just works. I get nice graphs that seem to prove that the number of times that a Factory Method implementation is used has no impact on its performance:<br /><br /><a href="http://4.bp.blogspot.com/-DSrhEiLraLw/U9HQM9ma65I/AAAAAAAAddc/qrJEG-YkXFg/s1600/benchmark.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-DSrhEiLraLw/U9HQM9ma65I/AAAAAAAAddc/qrJEG-YkXFg/s400/benchmark.png" /></a><br /><br />It may be a little hard to see, but there is a number associated with the “classic” subclass implementation of the Factory Method pattern—it is just really small compared to the other two approaches. For this, I tell <a href="http://www.gnuplot.info/">gnuplot</a> to plot the y axis logarithmically:<pre class=prettyprint>set style data histogram<br />set style histogram clustered<br />set style fill solid border<br />set xtics rotate out<br />set key tmargin<br />set xlabel "Loop Size"<br />set ylabel "µs per run"<br /><br /><b>set logscale y</b><br /><br />plot for [COL=2:4] filename using COL:xticlabels(1) title columnheader<br /></pre>That gives me:<br /><br /><a href="http://3.bp.blogspot.com/-SdJIkCs7edA/U9HU6XTzg6I/AAAAAAAAddo/dz1Qcqj9ZE0/s1600/benchmark.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-SdJIkCs7edA/U9HU6XTzg6I/AAAAAAAAddo/dz1Qcqj9ZE0/s400/benchmark.png" /></a><br /><br />Any way that you look at it, the class subclass approach is the clear performance winner. There may be some maintainability wins for the other approaches, but they would have to be significant to warrant using them over the subclass approach. Even when compiled to JavaScript:<br /><br /><a href="http://3.bp.blogspot.com/-o54Bb21yJDY/U9HVk9QQMzI/AAAAAAAAddw/ikVtQqTLaig/s1600/benchmark_js.png" imageanchor="1" ><img border="0" src="http://3.bp.blogspot.com/-o54Bb21yJDY/U9HVk9QQMzI/AAAAAAAAddw/ikVtQqTLaig/s400/benchmark_js.png" /></a><br /><br />I think that will close out my initial research into object oriented design patterns for the book. I may investigate some concurrency patterns tomorrow. Or it may be time to switch back to <a href="http://patternsinpolymer.com">Patterns in Polymer</a>.<br /><br /><br /><span style="color: #ccc">Day #132</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2014/07/varying-only-import-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2013/11/new-chain-patterns-in-polymer.html">My Chain</a> | <a href="http://japhr.blogspot.com/2014/07/the-reactor-pattern-in-dart.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/95Z9j0dn3ks" height="1" width="1"/>
