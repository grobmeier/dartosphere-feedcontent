---
title: 'Dart Has Friend Class Baked In'
layout: post
published: '2015-12-01T22:01:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/AP6tjsbmdBY/dart-has-friend-class-baked-in.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'friend class'
    - memento

---

<div class=top-chain-links></div><br />The great thing about blogging every day is that I'm guaranteed to make an idiot out of myself. There is just no way around it. There are some days (sometimes even several days in succession) when a obvious solution just isn't obvious. And it's very liberating to accept that and just move forward with learning.<br /><br />Actually, it's still completely embarrassing, but I'll stick with the first story.<br /><br />Today's embarrassment comes in the form <a href="https://en.wikipedia.org/wiki/Friend_class">friend classes</a> in <a href="http://dartlang.org">Dart</a>. I continue to explore the <a href="https://en.wikipedia.org/wiki/Memento_pattern">memento pattern</a> for the forthcoming <a href="http://designpatternsindart.com/">Design Patterns in Dart</a>. The implementation section in the <a href="http://en.wikipedia.org/wiki/Design_Patterns">Gang of Four book</a> suggests that, to preserve encapsulation, the memento should expose its properties only to the originating class of the pattern, but not to anything else. <br /><br />Specifically, the caretaker that saves memento objects should not itself be able to access the properties of the memento. Since the memento represents a previous internal state, the caretaker should not be looking under the covers, so to speak. If it needs to know anything, it should ask the originating class. In the Gang of Four book, this is achieved via friend classes.<br /><br />For the past two nights, I have struggled to bend Dart to my will in achieving this friend class behavior. Instead, as the esteemed <a href="https://plus.google.com/+JamesHurford">James Hurford</a> pointed out in <a href="http://japhr.blogspot.com/2015/11/runtime-narrow-interfaces-in-dart.html#comments">last night's comments</a>, Dart's libraries simply work this way.<br /><br />Private variables in Dart are private to a library, not a class. So if I make the properties of my memento object private, nothing outside of the library (like the caretaker from the pattern) can access them. But the originator class in the same library should still be able to access them.<br /><br />The originating class with which I have been experimenting is the <code>VelvetFogMachine</code>, which plays wonderful selections of the great crooner's catalog. The <code>nowPlaying</code> getter method is used to generate the <code>Playing</code> memento objects:<pre class=prettyprint>class VelvetFogMachine {<br />  Song currentSong;<br />  double currentTime;<br />  // ...<br /><br />  // Create a memento of the current state<br />  Playing get nowPlaying => new Playing(currentSong, time);<br />  // ...<br />}</pre>Following James' suggestion, I should make the properties of <code>Playing</code> private (leading underscore variables are private in Dart):<pre class=prettyprint>// The Memento<br />class Playing {<br />  Song _song;<br />  double _time;<br />  Playing(this._song, this._time);<br />}</pre>Next, I ensure that both of these classes exist in the <code>velvet_fog_machine</code> library:<pre class=prettyprint>library velvet_fog_machine;<br />// The "Originator"<br />class VelvetFogMachine { /* ... */ }<br />// The Memento<br />class Playing { /* ... */ }</pre>With that, the <code>VelvetFogMachine</code> should have access to <code>Playing</code>'s <code>_song</code> and <code>_time</code> private variables when restoring a previous memento:<pre class=prettyprint>class VelvetFogMachine {<br />  // ...<br />  // Restore from memento<br />  void backTo(Playing p) {<br />    print("  *** Whoa! This was a good one, let's hear it again :) ***");<br />    _play(p._song, p._time);<br />  }<br />}</pre>And that actually works right away. Well, I shouldn't say "actually." I really should have remembered that this is how private variables work, but this is so much simpler than any of the craziness that I had been trying the previous two nights.<br /><br />Back in the caretaker code—and outside the <code>velvet_fog_machine</code> library—I can play songs, store mementos, and restore mementos:<pre class=prettyprint><code>  import 'package:memento_code/velvet_fog_machine.dart';<br />  // ...<br />  List&lt;Playing> replayer = [];<br /><br />  var scatMan = new VelvetFogMachine();<br />  // ...<br />  scatMan.play(<br />      'New York, New York Medley',<br />      'A Vintage Year'<br />  );<br />  replayer.add(scatMan.nowPlaying);<br /><br />  scatMan.play(<br />      'The Lady is a Tramp',<br />      'The Velvet Frog: The Very Best of Mel Tormé'<br />  );<br /><br />  // The New York, New York Medley with George Shearing really is wonderful<br />  scatMan.backTo(replayer.last);</code></pre>Running this from the command line produces the usual <code>play()</code> messages <i>and</i> verifies that the <code>backTo()</code> method was able to access the memento's private properties:<pre class=prettyprint>./bin/play_melvie.dart<br />Playing Blue Moon // The Velvet Frog: The Very Best of Mel Tormé @ 0.00<br />Playing 'Round Midnight // Tormé @ 0.00<br />Playing It Don't Mean A Thing (If It Ain't Got That Swing) // Best Of/ 20th Century @ 0.00<br />Playing New York, New York Medley // A Vintage Year @ 0.00<br />Playing The Lady is a Tramp // The Velvet Frog: The Very Best of Mel Tormé @ 0.00<br />  *** Whoa! This was a good one, let's hear it again :) ***<br />Playing New York, New York Medley // A Vintage Year @ 1.28</pre>Best of all, if I try to access the private variables from the caretaker:<pre class=prettyprint><code>    print("Caretaker says last remembered song is: ${replayer.last._song}");</code></pre>Then I get no-such-method errors and <code>dartanalyzer</code> complains:<pre class=prettyprint>[warning] The getter '_song' is not defined for the class 'Playing' (/home/chris/repos/design-patterns-in-dart/memento/bin/play_melvie.dart, line 40, col 68)</pre>This is exactly the "friend class" behavior that I wanted. <br /><br />So the moral of the story is that it takes two days of trying dumb stuff on the internet before a kind soul takes pity on you and points you in the right direction. No wait, the moral of the story is that if you want friend classes in Dart, keep them in the same library. Thanks James!<br /><br /><br /><span style="color: #ccc">Day #20</span>  <br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2015/11/runtime-narrow-interfaces-in-dart.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <span style="color: #ccc">next&rsaquo;</span> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/AP6tjsbmdBY" height="1" width="1" alt=""/>
