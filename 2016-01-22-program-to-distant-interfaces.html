---
title: 'Program to Distant Interfaces'
layout: post
published: '2016-01-22T23:23:00-08:00'
feed: 'japh(r) by Chris Strom'
link: 'http://feedproxy.google.com/~r/JaphrByChrisStrom/~3/3vgB0Ku5StA/program-to-distant-interfaces.html'
author:
    name: 'Chris Strom'
    email: noreply@blogger.com
    url: 'https://plus.google.com/117928918793969810642'
tags:
    - chain
    - dart
    - dartlang
    - 'design patterns'
    - 'proxy pattern'
    - websockets

---

<div class=top-chain-links></div><br />For the most part I am content to create <a href="http://dartlang.org">Dart</a> examples that run in the SDK. Command-line scripts feel lighter than their browser-based counterparts (and are certainly lighter than their JavaScript compiled counterparts). Plus, I can usually convert my scripts to run on <a href="http://dartpad.dartlang.org">DartPad</a>. But I feel compelled to try my remote <a href="https://en.wikipedia.org/wiki/Proxy_pattern">proxy pattern</a> websocket implementation in the browserâ€”not because I fear something going wrong. Rather, I am curious to explore coding to an interface in two different locations.<br /><br />I create a simple <code>web/index.html</code> page to hold a remote proxy car instance. As UIs go, this barely qualifies as bare minimum: <br /><br /><a href="http://4.bp.blogspot.com/-s1Wd_qrkHvo/VqMkClNDtFI/AAAAAAABDp8/yDFTbKT_im4/s1600/01-drive_stop.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-s1Wd_qrkHvo/VqMkClNDtFI/AAAAAAABDp8/yDFTbKT_im4/s640/01-drive_stop.png" width=570 /></a><br /><br />Still, it should be sufficient to test things out.<br /><br />Surprisingly (at least to me) things go amiss here. I had forgotten that the <code>WebSocket</code> class in the <code>dart:html</code> library differs from the one that I had been using in <code>dart:io</code>. The former conforms to the standard browser websocket interface where the latter is a standard <code>Stream</code> implementation. <br /><br />Aside from the annoyance of two different interfaces for the same object, there are some practical differences for which I have to account. In the <code>drive.dart</code> script pulled into the web page via <code>&lt;script></code> tag, I have to add a <code>Completer</code> to await the websocket being ready for use:<pre class=prettyprint>import 'dart:async' show Completer;<br />import 'dart:html' show WebSocket, document, query;<br /><br />import 'package:proxy_code/web_car.dart';<br /><br />main() async {<br />  var socket = new WebSocket('ws://localhost:4040/ws');<br /><br />  var _c = new Completer();<br />  socket.onOpen.listen((_){ _c.complete(); });<br />  await _c.future;<br /><br />  // Create proxy car with send/receive streams<br />  ProxyCar car = new ProxyCar(socket);<br />  // ...<br />}</pre>The <code>web_car.dart</code> file with the web remote proxy implementation also needs to change slightly, listening to the <code>onMessage</code> property instead of directly to the socket:<pre class=prettyprint>class ProxyCar implements AsyncAuto {<br />  // ...<br />  ProxyCar(this._socket) {<br />    _socket.onMessage.listen((e) {<br />      _state = e.data;<br />    });<br />  }<br />  // ...<br />}</pre>But once those minor differences are sorted out, everything just works. Darn it.<br /><br />I hook up the buttons in the page to event listeners in the Dart script:<pre class=prettyprint><code>  document.query('#drive').onClick.listen((_) async {<br />    print('Drive');<br />    await car.drive();<br />    updateState(car.state);<br />  });</code></pre>Clicking the button tells the proxy car to drive, which then results in an update to the state from the websocket. The result of this is included in the <code>&lt;pre></code> tag below the buttons:<br /><br /><a href="http://4.bp.blogspot.com/-POOLqimZZQM/VqMmsExx2LI/AAAAAAABDqI/bEkQ-9fqst4/s1600/02-drivign.png" imageanchor="1" ><img border="0" src="http://4.bp.blogspot.com/-POOLqimZZQM/VqMmsExx2LI/AAAAAAABDqI/bEkQ-9fqst4/s640/02-drivign.png" width=570 /></a><br /><br />And, indeed, the web socket server from the other night is seeing these messages and passing them along to the real car:<pre class=prettyprint>$ ./bin/server.dart<br />[AsyncCar] received: stop<br />[AsyncCar] received: drive<br /></pre>In the sum total of things, that is a good thing. I was able to take my command-line remote proxy package and use it in the browser with only minor changes. I hadn't counted on those minor changes between websocket implementations. And I had expected that I would need to move the common interface out into a separate file that could be imported into both <code>dart:io</code> and <code>dart:html</code> libraries. That turned out not be necessary--thanks to Dart's beautiful libraries and creating the websockets in the client instead of the libraries.<br /><br />Since libraries work so well in this case, I have no doubt that they will work when the common subject interface is pulled out into its own file. I do it anyway, creating <code>interface.dart</code> with:<pre class=prettyprint>library car;<br /><br />import 'dart:async' show Future;<br /><br />// Subject<br />abstract class AsyncAuto implements Automobile {<br />  String get state;<br />  Future drive();<br />  Future stop();<br />}<br /></pre>I then import that into both <code>real_car.dart</code> and <code>web_car.dart</code>:<pre class=prettyprint>library car;<br /><br />import 'dart:async' show Future, Stream;<br />import 'dart:html' show WebSocket;<br /><br />import 'interface.dart';<br /><br />// Proxy Subject<br />class ProxyCar implements AsyncAuto {<br />  // ...<br />}</pre>That makes the type analyzer happy and positions me well should I ever decide to create the specific websockets implementations in the <code>dart:html</code> and <code>dart:io</code> libraries. In other words, no matter how I decide I want to code those implementations, I have easy access to the interface to program against.<br /><br /><br /><span style="color: #ccc">Day #72</span>  <br /><br /><br /><p class=bottom-chain-links><a href="http://japhr.blogspot.com/2016/01/full-duplex-streams.html">&lsaquo;prev</a> | <a href="http://japhr.blogspot.com/2015/11/design-patterns-in-dart.html">My Chain</a> | <a href="http://japhr.blogspot.com/2016/01/a-closer-look-at-proxy-annotation-in.html">next&rsaquo;</a> </p><script>var b_links = document.getElementsByClassName('bottom-chain-links'),      t_links = document.getElementsByClassName('top-chain-links');  if (b_links.length == 1 && t_links.length == 1) {   t_links[0].innerHTML = b_links[0].innerHTML; } </script><img src="http://feeds.feedburner.com/~r/JaphrByChrisStrom/~4/3vgB0Ku5StA" height="1" width="1" alt=""/>
