---
title: 'Unboxing Packages: string_scanner'
layout: post
published: '2016-03-01T13:56:00-08:00'
feed: 'Dart News & Updates'
link: 'http://news.dartlang.org/2016/02/unboxing-packages-stringscanner.html'
author:
    name: 'Natalie Weizenbaum'
    email: noreply@blogger.com
    url: 'http://www.blogger.com/profile/17561686962317321958'
tags:
    - 'Unboxing Packages'

---

<p>Parsing is tricky. There’s the high-level question of what parsing system you use—a <a href="https://en.wikipedia.org/wiki/Comparison_of_parser_generators">parser generator</a>? A handwritten <a href="https://en.wikipedia.org/wiki/Recursive_descent_parser">recursive descent</a>? <a href="https://en.wikipedia.org/wiki/Parser_combinator">Parser combinators</a>?—but there’s also the issue of how you move through text and track the information you need to track. That’s what the <a href="pub.dartlang.org/packages/string_scanner"><code>string_scanner</code></a> package is for.</p>   <h2 id="the-core-api">The Core API</h2> <p>The package exposes one main class, <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner-class.html"><code>StringScanner</code></a>, as well as a few subclasses we’ll get to later. This scanner moves through a string, consuming text that matches patterns and giving the user information about it. Here are the most important parts of the API:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">class</span><span class="pln"> </span><span class="typ">StringScanner</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="typ">Match</span><span class="pln"> </span><span class="kwd">get</span><span class="pln"> lastMatch</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">int</span><span class="pln"> position</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="typ">StringScanner</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> </span><span class="kwd">string</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="kwd">bool</span><span class="pln"> scan</span><span class="pun">(</span><span class="typ">Pattern</span><span class="pln"> pattern</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">bool</span><span class="pln"> matches</span><span class="pun">(</span><span class="typ">Pattern</span><span class="pln"> pattern</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">void</span><span class="pln"> expect</span><span class="pun">(</span><span class="typ">Pattern</span><span class="pln"> pattern</span><span class="pun">,</span><span class="pln"> </span><span class="pun">{</span><span class="typ">String</span><span class="pln"> name</span><span class="pun">});</span><span class="pln"><br /></span><span class="pun">}</span></code></pre> <p>Let’s walk through this, starting with <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/position.html"><code>position</code></a>. This returns the scanners zero-based character position in the source string. The scanner always matches immediately after this position, and it updates the position as it consumes text. You can also set the position if you need to jump back (or forward) while parsing.</p> <p>The most important method is <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/scan.html"><code>scan()</code></a>; after all, it’s right there in the name of the class. It takes a <a href="https://api.dartlang.org/0.1.4+1/dart-core/Pattern-class.html"><code>Pattern</code></a>, which in practice means a <code>String</code> or a <code>RegExp</code>, and tries to consume text that matches that pattern. If the text immediately after current position matches, it returns <code>true</code>; otherwise, it returns <code>false</code>.</p> <p>The scanner is for <em>parsing</em>, though, not just validating that a string is in the right format. You need to be able to get information out of it. That’s what the <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/lastMatch.html"><code>lastMatch</code></a> getter is for. If the last call to <code>scan()</code> (or <code>matches()</code> or <code>expect()</code>) was successful, it contains <a href="https://api.dartlang.org/1.14.2/dart-core/Match-class.html">the data for that match</a>. This, along with the current position, are the only state that the scanner maintains.</p> <p>The <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/matches.html"><code>matches()</code></a> method is just like <code>scan()</code>, except that it doesn’t consume any text. It just returns whether the pattern matches without changing the position at all. This is sometimes used to detect boundaries between different constructs.</p> <p>Finally, <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/expect.html"><code>expect()</code></a> works like <code>scan()</code> but <em>requires</em> that the pattern matches. If it doesn’t, it throws a <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScannerException-class.html"><code>StringScannerException</code></a> which indicates that parsing failed. By default this exception includes the pattern that was being used, but the <code>name</code> parameter can be used to provide a more human-readable name for the missing token.</p> <p>Here’s a simple number parser using these methods:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">'dart:math'</span><span class="pln"> </span><span class="kwd">as</span><span class="pln"> math</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="kwd">import</span><span class="pln"> </span><span class="str">'package:string_scanner/string_scanner.dart'</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="com">// It's often a good idea to store regular expressions in variables so they only</span><span class="pln"><br /></span><span class="com">// need to be compiled once.</span><span class="pln"><br /></span><span class="kwd">final</span><span class="pln"> _digits </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">RegExp</span><span class="pun">(</span><span class="str">"[0-9]+"</span><span class="pun">);</span><span class="pln"><br /><br />num parseNum</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> text</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> scanner </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StringScanner</span><span class="pun">(</span><span class="pln">text</span><span class="pun">);</span><span class="pln"><br /><br />  </span><span class="com">// Don't require a whole component so that ".123" works.</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> whole </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br />  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="pln">scanner</span><span class="pun">.</span><span class="pln">scan</span><span class="pun">(</span><span class="pln">_digits</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    whole </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="pln">scanner</span><span class="pun">.</span><span class="pln">lastMatch</span><span class="pun">[</span><span class="lit">0</span><span class="pun">]);</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /><br />  </span><span class="com">// If there's no dot, exit immediately.</span><span class="pln"><br />  </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">scanner</span><span class="pun">.</span><span class="pln">scan</span><span class="pun">(</span><span class="str">"."</span><span class="pun">))</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="com">// I'll get to this later on.</span><span class="pln"><br />    scanner</span><span class="pun">.</span><span class="pln">expectDone</span><span class="pun">();</span><span class="pln"><br />    </span><span class="kwd">return</span><span class="pln"> whole</span><span class="pun">;</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /><br />  </span><span class="com">// If there is a dot, there must be trailing digits.</span><span class="pln"><br />  scanner</span><span class="pun">.</span><span class="pln">expect</span><span class="pun">(</span><span class="pln">_digits</span><span class="pun">,</span><span class="pln"> name</span><span class="pun">:</span><span class="pln"> </span><span class="str">"0 through 9"</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> </span><span class="kwd">decimal</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> scanner</span><span class="pun">.</span><span class="pln">lastMatch</span><span class="pun">[</span><span class="lit">0</span><span class="pun">];</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> result </span><span class="pun">=</span><span class="pln"> whole </span><span class="pun">+</span><span class="pln"> </span><span class="kwd">int</span><span class="pun">.</span><span class="pln">parse</span><span class="pun">(</span><span class="kwd">decimal</span><span class="pun">)</span><span class="pln"> </span><span class="pun">*</span><span class="pln"> math</span><span class="pun">.</span><span class="pln">pow</span><span class="pun">(</span><span class="lit">10</span><span class="pun">,</span><span class="pln"> </span><span class="pun">-</span><span class="kwd">decimal</span><span class="pun">.</span><span class="pln">length</span><span class="pun">);</span><span class="pln"><br /><br />  scanner</span><span class="pun">.</span><span class="pln">expectDone</span><span class="pun">();</span><span class="pln"><br />  </span><span class="kwd">return</span><span class="pln"> result</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h2 id="character-based-parsing">Character-Based Parsing</h2> <p>Some things you want to parse don’t work all that well with strings or regular expressions. You might need to make decisions based on every character individually. To make this possible, the scanner also supports going character-by-character. Like Dart’s strings themselves, it works in terms of UTF-16 code units.<a href="#fn:1" id="fnref:1" title="See footnote" class="footnote">1</a> </p><p>The <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/readChar.html"><code>readChar()</code></a> method consumes and returns a single character. It moves the current position forward by one. It returns the characters as integers, which is generally more efficient than single-character strings. I recommend using the constants defined in the <a href="https://pub.dartlang.org/packages/charcode"><code>charcode</code></a> package when dealing with these integers.</p> <p>The <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/peekChar.html"><code>peekChar()</code></a> function is also useful when doing character-based parsing. <code>peekChar()</code> is to <code>readChar()</code> as <code>matches()</code> is to <code>scan()</code>. It returns the same information—the next character—but it doesn’t move the position at all. In addition, <code>peekChar()</code> takes an optional <code>offset</code> parameter that allows you to peek at a character after (or even before) the current position.</p> <p>These two functions do different things if the scanner is at the end of the text. <code>readChar()</code> will throw an error, complaining that it expected more input. <code>peekChar()</code>, on the other hand, will just return <code>null</code>. </p> <p>Here’s a character-based integer parser:</p>   <pre class="prettyprint prettyprinted"><code class="language-dart"><span class="kwd">import</span><span class="pln"> </span><span class="str">'package:charcode/ascii.dart'</span><span class="pun">;</span><span class="pln"><br /><br /></span><span class="kwd">import</span><span class="pln"> </span><span class="str">'package:string_scanner/string_scanner.dart'</span><span class="pun">;</span><span class="pln"><br /><br />num parseInt</span><span class="pun">(</span><span class="typ">String</span><span class="pln"> text</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> scanner </span><span class="pun">=</span><span class="pln"> </span><span class="kwd">new</span><span class="pln"> </span><span class="typ">StringScanner</span><span class="pun">(</span><span class="pln">text</span><span class="pun">);</span><span class="pln"><br />  </span><span class="kwd">var</span><span class="pln"> value </span><span class="pun">=</span><span class="pln"> </span><span class="lit">0</span><span class="pun">;</span><span class="pln"><br /><br />  </span><span class="com">// The isDone getter indicates whether the scanner is at the end of the text.</span><span class="pln"><br />  </span><span class="kwd">while</span><span class="pln"> </span><span class="pun">(!</span><span class="pln">scanner</span><span class="pun">.</span><span class="pln">isDone</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />    </span><span class="kwd">var</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">=</span><span class="pln"> scanner</span><span class="pun">.</span><span class="pln">readChar</span><span class="pun">();</span><span class="pln"><br /><br />    </span><span class="com">// The $0 and $9 constants are defined in the charcode package.</span><span class="pln"><br />    </span><span class="kwd">if</span><span class="pln"> </span><span class="pun">(</span><span class="kwd">char</span><span class="pln"> </span><span class="pun">&lt;</span><span class="pln"> $0 </span><span class="pun">||</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">&gt;</span><span class="pln"> $9</span><span class="pun">)</span><span class="pln"> </span><span class="pun">{</span><span class="pln"><br />      </span><span class="com">// I'll talk about error() in the next section.</span><span class="pln"><br />      scanner</span><span class="pun">.</span><span class="pln">error</span><span class="pun">(</span><span class="str">"Invalid character."</span><span class="pun">,</span><span class="pln"> position</span><span class="pun">:</span><span class="pln"> scanner</span><span class="pun">.</span><span class="pln">position </span><span class="pun">-</span><span class="pln"> </span><span class="lit">1</span><span class="pun">);</span><span class="pln"><br />    </span><span class="pun">}</span><span class="pln"><br /><br />    value </span><span class="pun">*=</span><span class="pln"> </span><span class="lit">10</span><span class="pun">;</span><span class="pln"><br />    value </span><span class="pun">+=</span><span class="pln"> </span><span class="kwd">char</span><span class="pln"> </span><span class="pun">-</span><span class="pln"> $0</span><span class="pun">;</span><span class="pln"><br />  </span><span class="pun">}</span><span class="pln"><br /><br />  </span><span class="kwd">return</span><span class="pln"> value</span><span class="pun">;</span><span class="pln"><br /></span><span class="pun">}</span></code></pre>   <h2 id="emitting-errors">Emitting Errors</h2> <p>I’ve already talked about <code>expect()</code>, which is the most common way to emit errors when using a scanner. But it’s not the only way. What if your character-based parser runs into an error? What if you only discover that a token is invalid after you’ve already parsed it? What if the source has extra junk at the end after you’ve finished parsing?</p> <p>The most flexible error-emitting method is <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/error.html"><code>error()</code></a>. It can emit an error associated with any chunk of the text at all—all you need to do is pass in <code>position</code> and <code>length</code> parameters. Most of the time you just need the <code>match</code> parameter, which takes a <code>Match</code> object that was returned by <code>lastMatch</code> earlier on. Or you can choose not to pass in any location information at all, and it will default to associating the error with <code>lastMatch</code> (or the current position if <code>lastMatch</code> is <code>null</code>).</p> <p>If you’re wondering what it means for an error to be “associated with” a match, I encourage you to read <a href="http://news.dartlang.org/2016/02/one-of-best-aspects-of-package.html">my article about <code>source_span</code></a>. <code>StringScannerException</code> inherits from <a href="https://www.dartdocs.org/documentation/source_span/0.1.4+1/source_span/SourceSpanFormatException-class.html"><code>SourceSpanFormatException</code></a>, so it uses a source span to indicate where the error occurred in the text.</p> <p>Source spans can have <a href="https://www.dartdocs.org/documentation/source_span/0.1.4+1/source_span/SourceSpan/sourceUrl.html"><code>sourceUrl</code></a>s associated with them, which help the user know where the errors were caused. If you want your parse errors to have file information, you can pass in an optional <code>sourceUrl</code> parameter (which can be a <code>String</code> or a <code>Uri</code>) to <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/StringScanner.html"><code>new StringScanner()</code></a>.</p> <p>There’s one other error-emitting function, called <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/StringScanner/expectDone.html"><code>expectDone()</code></a>. It’s pretty single-purpose, but it’s useful all the same. If the scanner isn’t at the end of the text, it emits an error; otherwise, it does nothing. This is really useful when you’re parsing a single value and you want to ensure there’s no extra characters in the string after it.</p>   <h2 id="tracking-line-information">Tracking Line Information</h2> <p>Some scanners, like the ones in the examples above, are just used for parsing small chunks of text without any larger context. But others involve parsing an entire file, in which case line and column numbers are often very important. The default <code>StringScanner</code> doesn’t track this information, but it has a <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/LineScanner-class.html"><code>LineScanner</code></a> subclass that does.</p> <p><code>LineScanner</code> defines <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/LineScanner/line.html"><code>line</code></a> and <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/LineScanner/column.html"><code>column</code></a> getters that return the (zero-based) line and column at the current position. These fields are kept up-to-date as the scanner consumes additional text, so that accessing them is always fast.</p> <p>There’s also a special way of changing position with a <code>LineScanner</code>. You can use the <code>position</code> setter like you would with a plain <code>StringScanner</code>, but it’s less efficient since it needs to calculate the new line and column. If you know in advance that you might need to jump back to the current position, you should use the <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/LineScanner/state.html"><code>state</code></a> property instead.</p> <p>This property returns a <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/LineScannerState-class.html"><code>LineScannerState</code></a> object, which stores the line, column, and position information for the scanner. Once you have this object, you can pass it back to <code>state=</code> to restore that exact state in the line scanner much more efficiently than setting the position.</p>   <h2 id="scanning-with-source-spans">Scanning With Source Spans</h2> <p>There’s one more subclass I want to talk about, and it’s the one that provides the most value. It’s <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/SpanScanner-class.html"><code>SpanScanner</code></a>, which inherits from <code>LineScanner</code> and provides access to <a href="http://news.dartlang.org/2016/02/one-of-best-aspects-of-package.html">source spans</a> (specifically <a href="https://www.dartdocs.org/documentation/source_span/0.1.4+1/source_span/FileSpan-class.html"><code>FileSpan</code></a>s) for the text being parsed.</p> <p>The most commonly-used addition in <code>SpanScanner</code> is the <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/SpanScanner/lastSpan.html"><code>lastSpan</code></a> getter. It returns a span covering the same chunk of text as <code>lastMatch</code>, and it’s updated or set to <code>null</code> under the same circumstances.</p> <p>The <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/SpanScanner/emptySpan.html"><code>emptySpan</code></a> getter returns a span that covers no text. An empty span is useful for pointing to a specific locations in the source. This one always refers to the scanner’s current position.</p> <p>Finally, there’s <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/SpanScanner/spanFrom.html"><code>spanFrom</code></a>, the most powerful <code>SpanScanner</code> addition. It returns a span between two arbitrary points in the text, represented as <code>LineScannerState</code>s (which, if you recall, are returned by the <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/SpanScanner/state.html"><code>state</code></a> getter). The second state defaults to the current position, which makes it easy to get a span that covers a given chunk of scanning code.</p>   <h3 id="lazy-or-eager">Lazy or Eager?</h3> <p>For the advanced user, there’s a choice to be made when using a <code>SpanScanner</code>. The choice involves the implementation of the <code>line</code> and <code>column</code> getters: they can either be derived lazily from the current position, or computed eagerly as the scanner consumes text.</p> <p>Internally, a <code>SpanScanner</code> uses a <a href="https://www.dartdocs.org/documentation/source_span/0.1.4+1/source_span/SourceFile-class.html"><code>SourceFile</code></a> to generate its spans. By default, it also uses this file to get the line and column information for the current position, which means that—<a href="http://news.dartlang.org/2016/02/one-of-best-aspects-of-package.html#implementation-and-efficiency">as I discussed in my last article</a>—accessing these is not as efficient as possible. The trade-off is that scanning is faster because it doesn’t need to keep this information up-to-date.</p> <p>If that’s not the trade-off you want to make for your code, though, you can use <a href="https://www.dartdocs.org/documentation/string_scanner/0.1.4+1/string_scanner/SpanScanner-class.html"><code>new SpanScanner.eager()</code></a> instead of the default constructor. This returns a scanner that works like <code>LineScanner</code>: it updates the line and column as it goes, so accessing them is very fast.</p> <p>Which implementation is faster very much depends on the specifics of your use-case. Most of the time it won’t matter at all, but if parsing is a bottleneck for you, you should use Dart’s <a href="https://dart-lang.github.io/observatory/cpu-profile.html">excellent profiler</a> to see whether eager parsing makes a difference.</p>   <h2 id="parse-the-world">Parse the World</h2> <p>I love writing parsers. I’ve written parsers for <a href="https://pub.dartlang.org/packages/http_parser">existing formats</a>, and I’ve written parsers for <a href="https://pub.dartlang.org/packages/boolean_selector">entirely new ones</a>. The ability to write robust parsers with good APIs is an important tool in a programmer’s belt, and the <code>string_scanner</code> package makes it easy to get started. It makes it easy to write small parsers for small formats like the examples I’ve included here, and it makes it easy to expand those to large-scale parsers of complex formats like <a href="https://pub.dartlang.org/packages/http_parser">YAML</a>. Next time you need to parse some text, you’ll know what to use.</p> <p>Join me next week when I talk about how to bring structure to your asynchronous code.</p> <div class="footnotes"><hr><ol><li id="fn:1">Note that some Unicode characters appear as two code points, called <a href="https://en.wikipedia.org/wiki/UTF-16#U.2B10000_to_U.2B10FFFF">surrogate pairs</a>. This is an issue inherited from Dart’s string implementation, which in turn inherited it from JavaScript. <a href="#fnref:1" title="Return to article" class="reversefootnote">↩</a></li></ol></div>
